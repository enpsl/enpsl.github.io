<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"enpsl.github.io",root:"/",scheme:"Muse",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="my blog"><meta property="og:type" content="website"><meta property="og:title" content="彭诗亮的博客"><meta property="og:url" content="https://enpsl.github.io/page/2/index.html"><meta property="og:site_name" content="彭诗亮的博客"><meta property="og:description" content="my blog"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="enpsl"><meta property="article:tag" content="彭诗亮 psl pengshiliang blog"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://enpsl.github.io/page/2/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!0,isPost:!1,lang:"zh-CN"}</script><title>彭诗亮的博客</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">彭诗亮的博客</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档</a></li></ul></nav></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content index posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2022/02/24/2022-02-24-mysql(1)/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2022/02/24/2022-02-24-mysql(1)/" class="post-title-link" itemprop="url">Mysql锁</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-02-24 22:30:00" itemprop="dateCreated datePublished" datetime="2022-02-24T22:30:00+08:00">2022-02-24</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><h3 id="事物隔离场景"><a href="#事物隔离场景" class="headerlink" title="事物隔离场景"></a>事物隔离场景</h3><p>repeatable-read</p><h3 id="表语句准备"><a href="#表语句准备" class="headerlink" title="表语句准备"></a>表语句准备</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `d` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `c` (`c`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),</span><br><span class="line">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure><p>先假设一个没有堵塞的场景：</p><table><thead><tr><th></th><th>SessionA</th><th>SessionB</th><th>SessionC</th></tr></thead><tbody><tr><td>T1</td><td>begin;<br>select * from t where d&#x3D;5 for update;<br><font color="red">result:(5,5,5)</font></td><td></td><td></td></tr><tr><td>T2</td><td></td><td>update t set d&#x3D;5 where id&#x3D;0;</td><td></td></tr><tr><td>T3</td><td>select * from t where d&#x3D;5 for update;<br><font color="red">result:(0,0,5)(5,5,5)</font></td><td></td><td></td></tr><tr><td>T4</td><td></td><td></td><td>insert into t values(1,1,5);</td></tr><tr><td>T5</td><td>select * from t where d&#x3D;5 for update;<br><font color="red">result:(0,0,5)(1,1,5)(5,5,5)</font></td><td></td><td></td></tr><tr><td>T6</td><td>commit;</td><td></td><td></td></tr></tbody></table><p>可以看到，session A 里执行了三次查询，分别是 Q1、Q2 和 Q3。它们的 SQL 语句相同，都是 select * from t where d&#x3D;5 for update。查所有 d&#x3D;5 的行，而且使用的是当前读，并且加上写锁。现在，我们来看一下这三条 SQL 语句，分别会返回什么结果。</p><ol><li>Q1 只返回 id&#x3D;5 这一行；</li><li>在 T2 时刻，session B 把 id&#x3D;0 这一行的 d 值改成了 5，因此 T3 时刻 Q2 查出来的是 id&#x3D;0 和 id&#x3D;5 这两行；</li><li>在 T4 时刻，session C 又插入一行（1,1,5），因此 T5 时刻 Q3 查出来的是 id&#x3D;0、id&#x3D;1 和 id&#x3D;5 的这三行。</li></ol><p>其中，Q3 读到 id&#x3D;1 这一行的现象，被称为“幻读”。也就是说，幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。</p><h2 id="Mysql如何解决幻读"><a href="#Mysql如何解决幻读" class="headerlink" title="Mysql如何解决幻读"></a>Mysql如何解决幻读</h2><h3 id="本片需要用到的两种锁"><a href="#本片需要用到的两种锁" class="headerlink" title="本片需要用到的两种锁"></a>本片需要用到的两种锁</h3><p>LOCK IN SHARE MODE是读锁(只是不让别人写)，FOR UPDATE是写锁(还不让别人加读锁)</p><h3 id="InnoDB行锁"><a href="#InnoDB行锁" class="headerlink" title="InnoDB行锁"></a>InnoDB行锁</h3><p>InnoDB行锁是通过索引上的索引项来实现的，InnoDB这种行锁实现特点意味者：只有通过索引条件检索数据，InnoDB才会使用行级锁，否则，InnoDB将使用表锁！<br>如<code>select * from t where d=5 for update;</code>会锁住d&#x3D;5索引覆盖范围的相关行，如果没有索引则会锁住所有行</p><h3 id="间隙锁-Gap-Lock"><a href="#间隙锁-Gap-Lock" class="headerlink" title="间隙锁 (Gap Lock)"></a>间隙锁 (Gap Lock)</h3><p>行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB 只好引入新的锁，也就是间隙锁 (Gap Lock)。<br>间隙锁，锁的就是两个值之间的空隙。比如文章开头的表 t，初始化插入了 6 个记录，这就产生了 7 个间隙。<br>这样，当你执行 select * from t where d&#x3D;5 for update 的时候，就不止是给数据库中已有的 6 个记录加上了行锁，还同时加了 7 个间隙锁。这样就确保了无法再插入新的记录。</p><h3 id="行锁和间隙锁比较"><a href="#行锁和间隙锁比较" class="headerlink" title="行锁和间隙锁比较"></a>行锁和间隙锁比较</h3><p>行锁，分成读锁和写锁。下图就是这两种类型行锁的冲突关系。</p><table><thead><tr><th></th><th>读锁</th><th>写锁</th></tr></thead><tbody><tr><td>读锁</td><td><font color="green">兼容</font></td><td><font color="red">冲突</font></td></tr><tr><td>写锁</td><td><font color="red">冲突</font></td><td><font color="red">冲突</font></td></tr></tbody></table><p>也就是说，跟行锁有冲突关系的是“另外一个行锁”。<br>但是间隙锁不一样，<strong>跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。</strong>间隙锁之间都不存在冲突关系。</p><table><thead><tr><th>SessionA</th><th>SessionB</th></tr></thead><tbody><tr><td>begin;<br>select * from t where c&#x3D;7 lock in share mode;</td><td></td></tr><tr><td></td><td>begin;<br>select * from t where c&#x3D;7 for update;</td></tr></tbody></table><p>这里 session B 并不会被堵住。因为表 t 里并没有 c&#x3D;7 这个记录，因此 session A 加的是间隙锁 (5,10)。而 session B 也是在这个间隙加的间隙锁。它们有共同的目标，即：保护这个间隙，不允许插入值。但，它们之间是不冲突的。</p><p>间隙锁和行锁合称 next-key lock，每个 next-key lock 是前开后闭区间。也就是说，我们的表 t 初始化以后，如果用 select * from t for update 要把整个表所有记录锁起来，就形成了 7 个 next-key lock，分别是 (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +supremum]。</p><p><strong>间隙锁和 next-key lock 的引入，帮我们解决了幻读的问题，但同时也带来了一些“困扰”。</strong></p><p>看下面的实例</p><table><thead><tr><th>SessionA</th><th>SessionB</th></tr></thead><tbody><tr><td>begin;<br>select * from t where id&#x3D;9 for update;</td><td></td></tr><tr><td></td><td>begin;<br>select * from t where id&#x3D;9 for update;</td></tr><tr><td></td><td>insert into t values(9,9,9);<br><font color="red">result:(blocked)</font></td></tr><tr><td>insert into t values(9,9,9);<br><font color="red">result:(Deadlock)</font></td><td></td></tr></tbody></table><p>上面的场景形成死锁了。我们按语句执行顺序来分析一下：</p><ol><li>session A 执行 select … for update 语句，由于 id&#x3D;9 这一行并不存在，因此会加上间隙锁 (5,10);</li><li>session B 执行 select … for update 语句，同样会加上间隙锁 (5,10)，间隙锁之间不会冲突，因此这个语句可以执行成功；</li><li>session B 试图插入一行 (9,9,9)，被 session A 的间隙锁挡住了，只好进入等待；</li><li>session A 试图插入一行 (9,9,9)，被 session B 的间隙锁挡住了。</li></ol><p>至此，两个 session 进入互相等待状态，形成死锁。当然，InnoDB 的死锁检测马上就发现了这对死锁关系，让 session A 的 insert 语句报错返回了。</p><h2 id="mysql锁类型"><a href="#mysql锁类型" class="headerlink" title="mysql锁类型"></a>mysql锁类型</h2><p>锁规则里面，包含了两个“原则”、两个“优化”和一个“bug”。</p><blockquote><p>MySQL 后面的版本可能会改变加锁策略，所以这个规则只限于截止到现在的最新版本，即 5.x 系列 &lt;&#x3D;5.7.24，8.0 系列 &lt;&#x3D;8.0.13。</p></blockquote><p>原则 1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭区间。<br>原则 2：查找过程中访问到的对象才会加锁。<br>优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。<br>优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。<br>一个特殊场景：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</p><h3 id="等值查询间隙锁"><a href="#等值查询间隙锁" class="headerlink" title="等值查询间隙锁"></a>等值查询间隙锁</h3><table><thead><tr><th>SessionA</th><th>SessionB</th><th>SessionC</th></tr></thead><tbody><tr><td>begin;<br>update t set d&#x3D;d+1 where id&#x3D;7;</td><td></td><td></td></tr><tr><td></td><td>insert into t values(8,8,8);<br><font color="red">result:(blocked)</font></td><td></td></tr><tr><td></td><td></td><td>update t set d&#x3D;d+1 where id&#x3D;10;<br><font color="green">result:(ok)</font></td></tr></tbody></table><p>由于表 t 中没有 id&#x3D;7 的记录，所以用我们上面提到的加锁规则判断一下的话：</p><ol><li>根据原则 1，加锁单位是 next-key lock，session A 加锁范围就是 (5,10]；</li><li>同时根据优化 2，这是一个等值查询 (id&#x3D;7)，而 id&#x3D;10 不满足查询条件，next-key lock 退化成间隙锁，因此最终加锁的范围是 (5,10)。</li></ol><p>所以，session B 要往这个间隙里面插入 id&#x3D;8 的记录会被锁住，但是 session C 修改 id&#x3D;10 这行是可以的。</p><h3 id="非唯一索引等值锁"><a href="#非唯一索引等值锁" class="headerlink" title="非唯一索引等值锁"></a>非唯一索引等值锁</h3><table><thead><tr><th>SessionA</th><th>SessionB</th><th>SessionC</th></tr></thead><tbody><tr><td>begin;<br>select id from t where c&#x3D;5 lock in share mode(读锁);</td><td></td><td></td></tr><tr><td></td><td>update t set d&#x3D;d+1 where id&#x3D;5;<br><font color="green">result:(ok)</font></td><td></td></tr><tr><td></td><td></td><td>insert into t values(7,7,7);<br><font color="red">result:(blocked)</font></td></tr></tbody></table><p>看到这个例子，你是不是有一种“该锁的不锁，不该锁的乱锁”的感觉？我们来分析一下吧。</p><ol><li>根据原则 1，加锁单位是 next-key lock，因此会给 (0,5] 加上 next-key lock。</li><li>要注意 c 是普通索引，因此仅访问 c&#x3D;5 这一条记录是不能马上停下来的，需要向右遍历，查到 c&#x3D;10 才放弃。根据原则 2，访问到的都要加锁，因此要给 (5,10] 加 next-key lock。</li><li>但是同时这个符合优化 2：等值判断，向右遍历，最后一个值不满足 c&#x3D;5 这个等值条件，因此退化成间隙锁 (5,10)。</li><li>根据原则 2 ，<strong>只有访问到的对象才会加锁</strong>，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁，这就是为什么 session B 的 update 语句可以执行完成。</li></ol><p>但 session C 要插入一个 (7,7,7) 的记录，就会被 session A 的间隙锁 (5,10) 锁住。</p><blockquote><p>需要注意，在这个例子中，lock in share mode 只锁覆盖索引，但是如果是 for update 就不一样了。 执行 for update 时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁。</p></blockquote><p>这个例子说明，锁是加在索引上的；同时，它给我们的指导是，如果你要用 lock in share mode 来给行加读锁避免数据被更新的话，就必须得绕过覆盖索引的优化，在查询字段中加入索引中不存在的字段。比如，将 session A 的查询语句改成 select d from t where c&#x3D;5 lock in share mode。</p><h3 id="主键索引范围锁"><a href="#主键索引范围锁" class="headerlink" title="主键索引范围锁"></a>主键索引范围锁</h3><table><thead><tr><th>SessionA</th><th>SessionB</th><th>SessionC</th></tr></thead><tbody><tr><td>begin;<br>select * from t where id &gt;&#x3D;10 and id&lt;11 for update;</td><td></td><td></td></tr><tr><td></td><td>insert into t values(7,7,7);<br><font color="green">result:(ok)</font><br>insert into t values(13,13,13);<br><font color="red">result:(blocked)</font></td><td></td></tr><tr><td></td><td></td><td>update t set d&#x3D;d+1 where id&#x3D;15;<br><font color="red">result:(blocked)</font></td></tr></tbody></table><ol><li>开始执行的时候，要找到第一个 id&#x3D;10 的行，因此本该是 next-key lock(5,10]。 根据优化 1， 主键 id 上的等值条件，退化成行锁，只加了 id&#x3D;10 这一行的行锁。</li><li>范围查找就往后继续找，找到 id&#x3D;15 这一行停下来，因此需要加 next-key lock(10,15]。</li></ol><p>所以，session A 这时候锁的范围就是主键索引上，行锁 id&#x3D;10 和 next-key lock(10,15]。</p><h3 id="非唯一索引范围锁"><a href="#非唯一索引范围锁" class="headerlink" title="非唯一索引范围锁"></a>非唯一索引范围锁</h3><table><thead><tr><th>SessionA</th><th>SessionB</th><th>SessionC</th></tr></thead><tbody><tr><td>begin;<br>select * from t where c&gt;10 and c&lt;11 for update;</td><td></td><td></td></tr><tr><td></td><td>insert into t values(8,8,8);<br><font color="red">result:(blocked)</font></td><td></td></tr><tr><td></td><td></td><td>update t set d&#x3D;d+1 where id&#x3D;15;<br><font color="red">result:(blocked)</font></td></tr></tbody></table><p>这次 session A 用字段 c 来判断，加锁规则跟主键索引范围锁唯一的不同是：在第一次用 c&#x3D;10 定位记录的时候，索引 c 上加了 (5,10] 这个 next-key lock 后，由于索引 c 是非唯一索引，没有优化规则，也就是说不会蜕变为行锁，因此最终 sesion A 加的锁是，索引 c 上的 (5,10] 和 (10,15] 这两个 next-key lock。</p><h3 id="唯一索引范围锁特殊场景"><a href="#唯一索引范围锁特殊场景" class="headerlink" title="唯一索引范围锁特殊场景"></a>唯一索引范围锁特殊场景</h3><table><thead><tr><th>SessionA</th><th>SessionB</th><th>SessionC</th></tr></thead><tbody><tr><td>begin;<br>select * from t where id &gt;10 and id&lt;&#x3D;15 for update;</td><td></td><td></td></tr><tr><td></td><td>update t set d&#x3D;d+1 where id&#x3D;20;<br><font color="green">result:(blocked)</font></td><td></td></tr><tr><td></td><td></td><td>insert into t values(16,16,16);<br><font color="red">result:(blocked)</font></td></tr></tbody></table><p>session A 是一个范围查询，按照原则 1 的话，应该是索引 id 上只加 (10,15] 这个 next-key lock，并且因为 id 是唯一键，所以循环判断到 id&#x3D;15 这一行就应该停止了。<br>但是实现上，InnoDB 会往前扫描到第一个不满足条件的行为止，也就是 id&#x3D;20。而且由于这是个范围扫描，因此索引 id 上的 (15,20] 这个 next-key lock也会被锁上。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2022/01/20/2023-01-20-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2022/01/20/2023-01-20-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">动态规划基础算法分析</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-01-20 19:30:00" itemprop="dateCreated datePublished" datetime="2022-01-20T19:30:00+08:00">2022-01-20</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="什么是动态规划"><a href="#什么是动态规划" class="headerlink" title="什么是动态规划"></a>什么是动态规划</h2><p>动态规划，英文:Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使 用动态规划是最有效的。</p><h2 id="动态规划的解题步骤"><a href="#动态规划的解题步骤" class="headerlink" title="动态规划的解题步骤"></a>动态规划的解题步骤</h2><p>结合自己之前的经历分析，做动规题目的时候，只是把递归推导公式推出来就拉到了，然后就开始解题，提交题目的时候经常发现解题总是会出现一些细节问题，比如dp数组初始化不对，或者遍历的数组对象有问题等等…甚至很多时候把题目AC之后，都不太清楚dp[i]表示的是什么。<br>这就是一种朦胧的状态，然后就把题给过了，遇到稍稍难一点的，可能直接就不会了，然后 看题解，然后继续照葫芦画瓢陷入这种恶性循环中。<br>最近看了<a target="_blank" rel="noopener" href="https://github.com/youngyangyang04">Carl</a>的动态规划分析专栏，对这套算法体系有了一定的理解，并对解题思路进行了总结</p><p>对于动态规划问题，可拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了!</p><ol><li>确定dp数组(dp table)以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><h2 id="动态规划入门题目分析"><a href="#动态规划入门题目分析" class="headerlink" title="动态规划入门题目分析"></a>动态规划入门题目分析</h2><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fibonacci-number/">斐波那契数</a><br>通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后 面的每一项数字都是前面两项数字的和。也就是:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0，F(1) = 1</span><br><span class="line">F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</span><br></pre></td></tr></table></figure><p>给你n ，请计算 F(n) 。</p><p>示例 1:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入:2</span><br><span class="line">输出:1</span><br><span class="line">解释:F(2) = F(1) + F(0) = 1 + 0 = 1</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入:3 输出:2</span><br><span class="line">解释:F(3) = F(2) + F(1) = 1 + 1 = 2</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入:4</span><br><span class="line">输出:3</span><br><span class="line">解释:F(4) = F(3) + F(2) = 2 + 1 = 3</span><br></pre></td></tr></table></figure><p>提示:<code>0 &lt;= n &lt;= 30</code></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这道题比较简单，题目中已经给出了递推公式，所以不需要分析，直接实现即可</p><h4 id="dp5部曲"><a href="#dp5部曲" class="headerlink" title="dp5部曲"></a>dp5部曲</h4><p>按照动态规划5部曲进行分析</p><ol><li>确定dp数组以及下标的含义：表示第i个数的斐波那契数值dp<code>[i]</code></li><li>确定递推公式 <code>dp[i] = dp[i - 1] + dp[i - 2]</code></li><li>dp数组如何初始化 <code>dp[0] = 0</code>, <code>dp[1] = 1</code></li><li>确定遍历顺序 由于要保证第i个数的值为前两个数的和，所以要正向遍历</li><li>举例推导dp数组 打印dp数组应该是1,1,2,3,5,8,13,21…</li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fib</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> dp = <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(n)</li></ul><blockquote><p>动态规划题目一般往往可以优化空间复杂度，本道题也一样，可以将<code>dp[0]</code>、<code>dp[1]</code>作为两个变量值指针，然后用sum接收一下两个变量的和，在对dp[0]、dp[1]进行前移<code>dp[0] = dp[1]</code>,<code>dp[1] = sum</code></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fib</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> dp, sum = [<span class="number">2</span>]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        sum = dp[<span class="number">0</span>] + dp[<span class="number">1</span>]</span><br><span class="line">		dp[<span class="number">0</span>] = dp[<span class="number">1</span>]</span><br><span class="line">		dp[<span class="number">1</span>] = sum</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(1)</li></ul><h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">爬楼梯</a><br>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：有两种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶</span><br><span class="line">2. 2 阶</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：有三种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶 + 1 阶</span><br><span class="line">2. 1 阶 + 2 阶</span><br><span class="line">3. 2 阶 + 1 阶</span><br></pre></td></tr></table></figure><p>提示：<br><code>1 &lt;= n &lt;= 45</code></p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>爬到第一层楼梯有一种方法，爬到二层楼梯有两种方法。</p><p>那么第一层楼梯再跨两步就到第三层 ，第二层楼梯再跨一步就到第三层。</p><p>所以到第三层楼梯的状态可以由第二层楼梯 和 到第一层楼梯状态推导出来，那么就可以想 到动态规划了。</p><h4 id="dp5部曲-1"><a href="#dp5部曲-1" class="headerlink" title="dp5部曲"></a>dp5部曲</h4><p>动态规划5步</p><ol><li>确定dp数组以及下标的含义：表示爬到第n阶有<code>dp[n]</code>种爬法的</li><li>确定递推公式<br>首先是<code>dp[i - 1]</code>，上<code>i-1</code>层楼梯，有<code>dp[i - 1]</code>种方法，那么再一步跳一个台阶不就是<code>dp[i]</code>了<br>么。<br>还有就是<code>dp[i - 2]</code>，上<code>i-2</code>层楼梯，有<code>dp[i - 2]</code>种方法，那么再一步跳两个台阶不就是<code>dp[i]</code>了 么。<br>那么<code>dp[i]</code>就是 <code>dp[i - 1]</code>与<code>dp[i - 2]</code>之和!<br>所以<code>dp[i] = dp[i - 1] + dp[i - 2]</code> 。</li><li>dp数组如何初始化 <code>dp[0] = 1, dp[1] = 1, dp[2] = 2</code></li><li>确定遍历顺序 从递推公式<code>dp[i] = dp[i - 1] + dp[i - 2]</code>;中可以看出，遍历顺序一定是从前向后遍历的</li><li>举例推导dp数组 打印dp数组应该是1,2,3,5,8</li></ol><p>通过dp5步分析后，得知这道题其实就是实现斐波那契数列，题目立马变得清晰了，这也是动态规划分析的重要性!</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ClimbStairs</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">1</span> || n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> dp [<span class="number">3</span>]<span class="type">int</span></span><br><span class="line">	dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">	dp[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">3</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		sum = dp[<span class="number">1</span>] + dp[<span class="number">2</span>]</span><br><span class="line">		dp[<span class="number">1</span>] = dp[<span class="number">2</span>]</span><br><span class="line">		dp[<span class="number">2</span>] = sum</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(1)</li></ul><h3 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a>使用最小花费爬楼梯</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">使用最小花费爬楼梯</a><br>数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 <code>cost[i]</code>(下标从 0 开始)。</p><p>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向 上爬一个阶梯或者爬两个阶梯。</p><p>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p><p>示例 1：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：cost = [10,15,20]</span><br><span class="line">输出：15</span><br><span class="line">解释：你将从下标为 1 的台阶开始。</span><br><span class="line">- 支付 15 ，向上爬两个台阶，到达楼梯顶部。</span><br><span class="line">  总花费为 15 。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：cost = [1,100,1,1,1,100,1,1,100,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：你将从下标为 0 的台阶开始。</span><br><span class="line">- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。</span><br><span class="line">- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。</span><br><span class="line">- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。</span><br><span class="line">- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。</span><br><span class="line">- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。</span><br><span class="line">- 支付 1 ，向上爬一个台阶，到达楼梯顶部。</span><br><span class="line">  总花费为 6 。</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 &lt;= cost.length &lt;= 1000</span><br><span class="line">0 &lt;= cost[i] &lt;= 999</span><br></pre></td></tr></table></figure><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>这道题目可以说是昨天动态规划:爬楼梯的花费版本。 注意题目描述:每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，</p><p>你就可以选择向上爬一个阶梯或者爬两个阶梯</p><p>所以示例1中只花费一个15 就可以到阶梯顶，最后一步可以理解为 不用花费。</p><p><img src="/img/in-post/2023-01-20/img.png" alt="img.png"></p><h4 id="dp五部曲"><a href="#dp五部曲" class="headerlink" title="dp五部曲"></a>dp五部曲</h4><p>动态规划5步</p><p>cost &#x3D; <code>[0：10,1：15,2：20]</code></p><ol><li>确定dp数组以及下标的含义：<code>dp[i]</code>到达第i个台阶(顶层)的最小花费</li><li>确定递推公式<br>由题目可知，最小花费方案分为从第i-1阶走1步，或者从第i-2阶走2步到达两种方案<br>而不管选那种方案，由于最后一步一定要走，只不过选择的方案不同，所以，我的<code>dp[i]</code>都要固定花费<code>cost[i]</code><br>所以<code>dp[i] = dp[i-1] + cost[i -1]</code>或者<code>dp[i] = dp[i-2] + cost[i - 2]</code><br>最后的最小花费为<code>dp[i] = min(dp[i-1] + cost[i -1], dp[i-2] + cost[i - 2]) + 0</code><br>可得出爬i阶楼梯的最小花费为倒数第一步和倒数第二步的最小值 + 最后一步花费的费用<br><code>dp[i] = min(dp[i - 1], dp[i -2]) + cost[i]</code></li><li>dp数组如何初始化<br>那么看一下递归公式，<code>dp[i]</code>由<code>dp[i-1]，dp[i-2]</code>推出，既然初始化所有的<code>dp[i]</code>是不可能的，<br>那么只初始化<code>dp[0]</code>和<code>dp[1]</code>就够了，其他的最终都是<code>dp[0]dp[1]</code>推出。</li><li>确定遍历顺序 从递推公式<code>dp[i]</code>由<code>dp[i - 1]</code>和<code>dp[i - 2]</code>推导出的，所以遍历顺序一定是从前向后遍历的</li><li>举例推导dp数组 题目中打印dp数组应该是<br>题目中共有3阶<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[0] = 0 + cost[0] = 10</span><br><span class="line">dp[1] = 0 + cost[1] = 15</span><br><span class="line">dp[2] = min(dp[1], dp[0]) + cost[2] = 30</span><br><span class="line">dp[3] = min(dp[2], dp[1]) + cost[3] = 15 // cost[3] = 0</span><br></pre></td></tr></table></figure> <code>dp[3]</code>为我们最后返回的结果</li></ol><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MinCostClimbingStairs</span><span class="params">(cost []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> dp = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(cost))</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">0</span> + cost[<span class="number">0</span>]</span><br><span class="line">	dp[<span class="number">1</span>] = <span class="number">0</span> + cost[<span class="number">1</span>]</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">2</span>; i &lt; <span class="built_in">len</span>(cost); i++ &#123;</span><br><span class="line">		dp[i] = min(dp[i<span class="number">-1</span>], dp[i<span class="number">-2</span>]) + cost[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 这里实际上是dp[3] = min(dp[2], dp[1]) + cost[3] = 15, cost[3]=0所以被我们省略了</span></span><br><span class="line">	<span class="keyword">return</span> min(dp[<span class="built_in">len</span>(cost)<span class="number">-1</span>], dp[<span class="built_in">len</span>(cost)<span class="number">-2</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(n)<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MinCostClimbingStairsPlus</span><span class="params">(cost []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">var</span> dp0 = <span class="number">0</span> + cost[<span class="number">0</span>]</span><br><span class="line">   <span class="keyword">var</span> dp1 = <span class="number">0</span> + cost[<span class="number">1</span>]</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">2</span>; i &lt; <span class="built_in">len</span>(cost); i++ &#123;</span><br><span class="line">      dpi := min(dp0, dp1) + cost[i]</span><br><span class="line">      dp0 = dp1</span><br><span class="line">      dp1 = dpi</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> min(dp0, dp1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>优化空间复杂度后</p><ul><li>时间复杂度O(n)</li><li>空间复杂度O(1)</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2022/01/18/%E8%AE%B0%E4%B8%80%E6%AC%A1golang%20slice%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2022/01/18/%E8%AE%B0%E4%B8%80%E6%AC%A1golang%20slice%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">golang slice 问题排查</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-01-18 19:30:00" itemprop="dateCreated datePublished" datetime="2022-01-18T19:30:00+08:00">2022-01-18</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="前置知识点"><a href="#前置知识点" class="headerlink" title="前置知识点"></a>前置知识点</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="keyword">var</span> a = []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">    b := a</span><br><span class="line">    b[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1 3]</span><br></pre></td></tr></table></figure><p>先上一段简单代码,修改b[1]的值发现a[1]的值也跟着变化，原因是a和b里成员的地址是指向同一处的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">b := a</span><br><span class="line">b[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;a[0]地址:%p\n&quot;</span>, &amp;a[<span class="number">0</span>])</span><br><span class="line">fmt.Printf(<span class="string">&quot;a[1]地址:%p\n&quot;</span>, &amp;a[<span class="number">1</span>])</span><br><span class="line">fmt.Printf(<span class="string">&quot;b[0]地址:%p\n&quot;</span>, &amp;b[<span class="number">0</span>])</span><br><span class="line">fmt.Printf(<span class="string">&quot;b[1]地址:%p\n&quot;</span>, &amp;b[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a[0]地址:0xc0000b2010</span><br><span class="line">a[1]地址:0xc0000b2018</span><br><span class="line">b[0]地址:0xc0000b2010</span><br><span class="line">b[1]地址:0xc0000b2018</span><br></pre></td></tr></table></figure><h3 id="踩坑背景"><a href="#踩坑背景" class="headerlink" title="踩坑背景"></a>踩坑背景</h3><p>踩坑经历是发生在刷力扣题<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/description/">组合总和</a>这道题的时候，提交后发现一个case没通过<br><img src="/img/in-post/2022-01-15/img_1.png" alt="img_1.png"><br>思考🤔了几遍，没发现出代码逻辑上有什么问题，百思不得其解情况下在本地运行了下该case，发现出现了同样的情况😖<br>下面是当时刷题提交的代码:(为了方便问题分析，由于力扣原题输出项比较多，因此对该case简化了一下)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	res1 := CombinationSum1([]<span class="type">int</span>&#123;<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>&#125;, <span class="number">12</span>)</span><br><span class="line">	fmt.Println(res1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CombinationSum1</span><span class="params">(candidates []<span class="type">int</span>, target <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res = <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span> backtrack <span class="function"><span class="keyword">func</span><span class="params">([]<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, []<span class="type">int</span>, <span class="type">int</span>)</span></span></span><br><span class="line">    backtrack = <span class="function"><span class="keyword">func</span><span class="params">(candidate[]<span class="type">int</span>, begin, size <span class="type">int</span>, ints []<span class="type">int</span>, val <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> val &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> val == <span class="number">0</span> &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, ints)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := begin; i &lt; size; i++ &#123;</span><br><span class="line">            backtrack(candidate, i, size, <span class="built_in">append</span>(ints, candidate[i]), val - candidate[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtrack(candidates, <span class="number">0</span>, <span class="built_in">len</span>(candidates), []<span class="type">int</span>&#123;&#125;, target)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看输出:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[7 3 2] [3 3 3 2] [3 3 2 2 2] [2 2 2 2 2 2]]</span><br></pre></td></tr></table></figure><blockquote><p>很明显[3 3 3 2]加起来不是12，和leetcode出现的问题是一样的</p></blockquote><h3 id="踩坑原因分析"><a href="#踩坑原因分析" class="headerlink" title="踩坑原因分析"></a>踩坑原因分析</h3><p>一开始，先是在append处打印下<code>ints</code>变量内容，看看是不是路径和计算有问题</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> val == <span class="number">0</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;append ints %v\n&quot;</span>, ints)</span><br><span class="line">    res = <span class="built_in">append</span>(res, ints)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">append ints [7 3 2]</span><br><span class="line">append ints [3 3 3 3]</span><br><span class="line">append ints [3 3 2 2 2]</span><br><span class="line">append ints [2 2 2 2 2 2]</span><br><span class="line">[[7 3 2] [3 3 3 2] [3 3 2 2 2] [2 2 2 2 2 2]]</span><br></pre></td></tr></table></figure><p>此时，发现了事情的不妙，append<code>ints</code>时<code>ints</code>的成员是正确的，但是最终输出<code>ints</code>的成员确由<code>[3 3 3 3]</code>变为了<code>[3 3 3 2]</code>,<br>于是猜测一定函数<code>backtrack(...append(ints, candidate[i])...)</code>这个函数调用时<code>ints[3]</code>成员的地址的值在后面被修改了，因为通过先前的举例我们也知道了<code>slice</code>里的成员是引用的吗🔍<br>所以决定断点打印一下来印证自己的猜想，由于断点过程中需要每次查看栈空间函数各个参数的值已经函数递归调用是<code>ints</code>成员的地址值的变化，所以采用<code>gdb</code>工具进行断点</p><h3 id="断点追踪"><a href="#断点追踪" class="headerlink" title="断点追踪"></a>断点追踪</h3><p>通过上面的输出结果我们知道<code>ints</code>是在第二次append后输出的，所以直接从第二次append后开始分析,并且<code>ints[3]</code>发生了非预期结果，所以只分析<code>ints[3]</code>的地址和值即可</p><h4 id="追踪step1"><a href="#追踪step1" class="headerlink" title="追踪step1"></a>追踪step1</h4><p>首先，因为发现问题分歧的原因是在<code>res = append(res, ints)</code>这行产生的，因此在这里break一下(如下图所示)<br><img src="/img/in-post/2022-01-15/img_11.png" alt="img_11.png"></p><h4 id="追踪step2"><a href="#追踪step2" class="headerlink" title="追踪step2"></a>追踪step2</h4><p>看一下当前<code>栈</code>空间变量成员(如下图所示)<br><img src="/img/in-post/2022-01-15/img_12.png" alt="img_12.png"></p><blockquote><p>这时，<code>ints[3]</code>还是正常的，打印结果是<code>3</code>,我们记录下当前<code>ints[3]</code>的地址<code>0xc0000ae078</code>,ints变量的地址<code>0xc0000ae060</code>也记录下，后面会用到</p></blockquote><h4 id="追踪step3"><a href="#追踪step3" class="headerlink" title="追踪step3"></a>追踪step3</h4><p>当<code>beign=1;i=1</code>时(如下图所示)；<code>candidate[i]</code>会被append到ints中，看下<code>candidate[i] = 3</code>，这时即使<code>ints[3]</code>地址被重新赋值为<code>candidate[i]</code>，也还是会为3，看不出来什么变化，继续走<br><img src="/img/in-post/2022-01-15/img_13.png" alt="img_13.png"></p><h4 id="追踪step4"><a href="#追踪step4" class="headerlink" title="追踪step4"></a>追踪step4</h4><p>我们直接跳到i&#x3D;2;begin&#x3D;1(如下图所示)；此时发现下面的i&#x3D;1，证明函数还没开始调用，继续<br><img src="/img/in-post/2022-01-15/img_14.png" alt="img_14.png"></p><blockquote><p>为什么在i&#x3D;2后面i又变为了1，并且还有backtrack函数调用？<br>解释：因为在回溯递归场景中，当前循环里，函数可能还存在其他循环时递归调用的函数，而在其他循环里递归调用的函数成员内存地址是跟当前循环不一样的，所以这里不做追踪</p></blockquote><h4 id="追踪step5"><a href="#追踪step5" class="headerlink" title="追踪step5"></a>追踪step5</h4><p>打印<code>candidate[2]</code>，发现值为2(如下图所示),因为这时函数还未调用，<code>candidate[2]</code>还未append，函数将会在下一行调用，所以<code>ints[3]</code>还是3继续追踪<br><img src="/img/in-post/2022-01-15/img_15.png" alt="img_15.png"></p><h4 id="追踪step6"><a href="#追踪step6" class="headerlink" title="追踪step6"></a>追踪step6</h4><p>当backtrack函数执行后;<code>candidate[2]</code>被append到了<code>ints</code>中，此时<code>ints[3]</code>的地址的值发生了修改(如下图所示),所以<code>res</code>最后返回结果的切片也发生了修改<br><img src="/img/in-post/2022-01-15/img_16.png" alt="img_16.png"><br>此时<code>ints[]3</code>的地址<code>0xc0000ae078</code>还是之前的地址，证实了我们的猜想</p><h4 id="追踪step7"><a href="#追踪step7" class="headerlink" title="追踪step7"></a>追踪step7</h4><p>接着往下走，因为i&#x3D;2后，在++为3后不满足<code>i&lt;size</code>判断，所以退出当前循环，进入到下一次循环的函数栈<br><img src="/img/in-post/2022-01-15/img_17.png" alt="img_17.png"><br>此时ints[3]地址由<code>0xc0000ae078</code>变为了<code>0xc0000ac058</code>，ints地址由<code>0xc0000ae060</code>变为了<code>0xc0000ac040</code></p><blockquote><p>之前的ints地址和ints地址在追踪step2记录过</p></blockquote><h4 id="初步结论"><a href="#初步结论" class="headerlink" title="初步结论"></a>初步结论</h4><p>在当前函数栈内，ints成员的地址在每次循环调用时是不变的,所以在当前循环函数调用时,ints发生append后，由于是浅拷贝，所以会发生返回切片结果成员数据<code>被污染</code>的情况</p><h3 id="追踪结论印证"><a href="#追踪结论印证" class="headerlink" title="追踪结论印证"></a>追踪结论印证</h3><p>从前面的结论可知，由于<code>candidate[2]</code>是在循环最后被append的，所以对<code>ints[3]</code>地址指向的值发生了修改，我们可以通过在输入项中增加一个元素，来印证当前结论</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res1 := CombinationSum1([]<span class="type">int</span>&#123;<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>, <span class="number">8</span>&#125;, <span class="number">12</span>)</span><br></pre></td></tr></table></figure><p>打印输出结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">append ints [7 3 2]</span><br><span class="line">append ints [3 3 3 3]</span><br><span class="line">append ints [3 3 2 2 2]</span><br><span class="line">append ints [2 2 2 2 2 2]</span><br><span class="line">append ints [2 2 8]</span><br><span class="line">[[7 3 2] [3 3 3 8] [3 3 2 2 2] [2 2 2 2 2 8] [2 2 8]]</span><br></pre></td></tr></table></figure><p>可以看到<code>[3 3 3 2]</code>变为了<code>[3 3 3 8]</code></p><h3 id="How-To-Fix"><a href="#How-To-Fix" class="headerlink" title="How To Fix"></a>How To Fix</h3><p>了解问题根本原因后想解决就很简单了，我们只要在append时深拷贝一次ints就可以了<br>解决后完整代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	res1 := CombinationSum2([]<span class="type">int</span>&#123;<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>, <span class="number">8</span>&#125;, <span class="number">12</span>)</span><br><span class="line">	fmt.Println(res1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CombinationSum1</span><span class="params">(candidates []<span class="type">int</span>, target <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> res = <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">var</span> backtrack <span class="function"><span class="keyword">func</span><span class="params">([]<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, []<span class="type">int</span>, <span class="type">int</span>)</span></span></span><br><span class="line">	backtrack = <span class="function"><span class="keyword">func</span><span class="params">(candidate[]<span class="type">int</span>, begin, size <span class="type">int</span>, ints []<span class="type">int</span>, val <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> val &lt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> val == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">var</span> tmp = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(ints))</span><br><span class="line">			<span class="built_in">copy</span>(tmp, ints)</span><br><span class="line">			fmt.Println(<span class="string">&quot;append after copied ints&quot;</span>, tmp)</span><br><span class="line">			res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i := begin; i &lt; size; i++ &#123;</span><br><span class="line">			backtrack(candidate, i, size, <span class="built_in">append</span>(ints, candidate[i]), val - candidate[i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	backtrack(candidates, <span class="number">0</span>, <span class="built_in">len</span>(candidates), []<span class="type">int</span>&#123;&#125;, target)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">append</span> after copied ints [<span class="number">7</span> <span class="number">3</span> <span class="number">2</span>]</span><br><span class="line"><span class="built_in">append</span> after copied ints [<span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span>]</span><br><span class="line"><span class="built_in">append</span> after copied ints [<span class="number">3</span> <span class="number">3</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span>]</span><br><span class="line"><span class="built_in">append</span> after copied ints [<span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span>]</span><br><span class="line"><span class="built_in">append</span> after copied ints [<span class="number">2</span> <span class="number">2</span> <span class="number">8</span>]</span><br><span class="line">[[<span class="number">7</span> <span class="number">3</span> <span class="number">2</span>] [<span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span>] [<span class="number">3</span> <span class="number">3</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span>] [<span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span>] [<span class="number">2</span> <span class="number">2</span> <span class="number">8</span>]]</span><br></pre></td></tr></table></figure><p>算法提交通过👏<br><img src="/img/in-post/2022-01-15/img_18.png" alt="img_18.png"></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2022/01/15/%E5%9B%9E%E6%BA%AF%E6%A8%A1%E7%89%88/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2022/01/15/%E5%9B%9E%E6%BA%AF%E6%A8%A1%E7%89%88/" class="post-title-link" itemprop="url">回溯模版</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-01-15 19:30:00" itemprop="dateCreated datePublished" datetime="2022-01-15T19:30:00+08:00">2022-01-15</time></span></div></header><div class="post-body" itemprop="articleBody"><h4 id="回溯模版总结"><a href="#回溯模版总结" class="headerlink" title="回溯模版总结"></a>回溯模版总结</h4><p>适用于结果路径里元素不可重复使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">创建空slice</span><br><span class="line"><span class="keyword">for</span> 选择 in 选择列表:</span><br><span class="line">    # 做选择</span><br><span class="line">    将该选择从选择列表移除</span><br><span class="line">    slice = slice[<span class="number">1</span>:]</span><br><span class="line">    backtrack(路径.<span class="built_in">append</span>, 选择列表)</span><br><span class="line">    # 撤销选择</span><br><span class="line">	slice = slice[:<span class="built_in">len</span>(slice) - <span class="number">1</span>]</span><br><span class="line">    将该选择再加入选择列表</span><br></pre></td></tr></table></figure><p>适用于结果路径里元素可重复使用，排列顺序不能重复</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">创建空slice</span><br><span class="line"><span class="keyword">for</span> 选择 in 选择列表:</span><br><span class="line">    # 做选择</span><br><span class="line">    将该选择从选择列表移除</span><br><span class="line">    num := slice[i]</span><br><span class="line">    slice = <span class="built_in">append</span>(slice[:i], slice[i+<span class="number">1</span>:]...)</span><br><span class="line">    backtrack(路径.<span class="built_in">append</span>, 选择列表)</span><br><span class="line">    # 撤销选择</span><br><span class="line">	slice = <span class="built_in">append</span>(slice[:i], <span class="built_in">append</span>([]<span class="type">int</span>&#123;num&#125;, slice[i:]...)...)</span><br><span class="line">    将该选择再加入选择列表</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2022/01/14/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2022/01/14/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">回溯算法</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-01-14 19:30:00" itemprop="dateCreated datePublished" datetime="2022-01-14T19:30:00+08:00">2022-01-14</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><h4 id="回溯题目应用"><a href="#回溯题目应用" class="headerlink" title="回溯题目应用"></a>回溯题目应用</h4><p>以力扣<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/generate-parentheses/submissions/393569541/" title="https://leetcode.cn/problems/generate-parentheses/submissions/393569541/">https://leetcode.cn/problems/generate-parentheses/submissions/393569541/</a>算法为例:</p><p>题目要求：输入一个数字n:数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且有效的括号组合</p><h3 id="回溯分析过程"><a href="#回溯分析过程" class="headerlink" title="回溯分析过程"></a>回溯分析过程</h3><h4 id="先枚举"><a href="#先枚举" class="headerlink" title="先枚举"></a>先枚举</h4><p>根据题目要求：可分析得到要生成n对括号，并且括号是有效括号，由于题目要求列出所有组合可能，所以我们要将括号拆分成<code>(</code>和<code>)</code>,这样我们一共需要生成2n个这样的括号 先发挥我们的大脑想象😇，列举出这2n个括号的所有排列组合</p><p>已n&#x3D;2为例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">))))</span><br><span class="line">)))(</span><br><span class="line">))()</span><br><span class="line">))((</span><br><span class="line">)())</span><br><span class="line">)()(</span><br><span class="line">)(()</span><br><span class="line">)(((</span><br><span class="line">()))</span><br><span class="line">())(</span><br><span class="line">()()</span><br><span class="line">()((</span><br><span class="line">(())</span><br><span class="line">(()(</span><br><span class="line">((()</span><br><span class="line">((((</span><br></pre></td></tr></table></figure><p>可枚举出16种可能，但是这些结果集并不是我们都需要的，因此我们需要针对有效括号的特性做出一些筛减；分析至此，会很轻易发现，这是不是和<code>回溯</code>的思想很类似呢?回溯的核心思想是:在for循环里面进行递归，枚举出所有可能，在递归调用之前「做选择」，在递归调用之后「撤销选择」；而<code>做选择</code>就是对穷举的排列组合进行筛减，判断出不合法的选择，然后过滤掉，这种过程通常被叫做<code>剪枝</code>。<code>撤销选择</code>即探索过程中发现并不优或达不到目标，就退回一步重新选择</p><p>枚举所有可能的代码很好实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateParenthesis</span><span class="params">(n <span class="type">int</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> backtrack <span class="function"><span class="keyword">func</span> <span class="params">(<span class="type">int</span>, <span class="type">string</span>)</span></span></span><br><span class="line">	<span class="keyword">var</span> res = <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>)</span><br><span class="line">	n = n * <span class="number">2</span></span><br><span class="line">	backtrack = <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>, back <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">			res = <span class="built_in">append</span>(res, back)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		backtrack(n- <span class="number">1</span>, back + <span class="string">&quot;)&quot;</span>)</span><br><span class="line">		backtrack(n- <span class="number">1</span>, back + <span class="string">&quot;(&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	backtrack(n, <span class="string">&quot;&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>递归为什么可实现枚举？</p><p>分析过程:</p><p>如果输入为2，要生成2n个括号可得出n&#x3D;4,因为函数是在<code>栈</code>中调用的,并且递归嵌套调用<br>所以当：</p><ul><li><p>n&#x3D;1时:<code>backtrack(0, back + &quot;)&quot;)</code>和<code>backtrack(0, back + &quot;(&quot;)</code>都被压入到栈中</p></li><li><p>n&#x3D;2时:<code>backtrack(1, back + &quot;)&quot;)</code>和<code>backtrack(1, back + &quot;(&quot;)</code>都被压入到栈中</p></li><li><p>n&#x3D;3时:<code>backtrack(2, back + &quot;)&quot;)</code>和<code>backtrack(3, back + &quot;(&quot;)</code>都被压入到栈中</p></li><li><p>n&#x3D;4时:<code>backtrack(3, back + &quot;)&quot;)</code>和<code>backtrack(3, back + &quot;(&quot;)</code>都被压入到栈中</p></li></ul><p>不难分析，当:</p><ul><li><p>n&#x3D;0时为终止条件，直接输出</p></li><li><p>n&#x3D;1时<code>n = n-1</code> 函数调用为<code>backtrack(0, back + &quot;)&quot;)</code>,对应了两种结果集：<code>)</code>和<code>(</code>都被压入栈中,会输出<code>)</code>和<code>(</code>两种可能;函数被压入栈中2次</p></li><li><p>n&#x3D;2时<code>n = n-1</code> 函数调用为<code>backtrack(1, back + &quot;)&quot;)</code>,对应了刚才n&#x3D;1时两种输出结果集;<code>backtrack(1, back + &quot;(&quot;)</code>也对应了n&#x3D;1的两种输出结果集,想加后一共会输出<code>))</code>、<code>((</code>、<code>()</code>、<code>)(</code>四种可能;函数被压入栈中4次</p></li><li><p>n&#x3D;3时<code>n = n-1</code> 函数调用为<code>backtrack(2, back + &quot;)&quot;)</code>,对应了刚才n&#x3D;2时的两种输出结果集;<code>backtrack(2, back + &quot;(&quot;)</code>也对应了n&#x3D;2的两种输出结果集,想加后一共会输出<code>)))</code> <code>))(</code> <code>)()</code> <code>)((</code> <code>())</code> <code>()(</code> <code>(()</code> <code>(((</code>八种可能;函数被压入栈中8次</p></li><li><p>n&#x3D;4时<code>n = n-1</code> 函数调用为<code>backtrack(3, back + &quot;)&quot;)</code>,对应了刚才n&#x3D;3时的两种输出结果集;<code>backtrack(3, back + &quot;(&quot;)</code>也对应了n&#x3D;3的两种输出结果集,想加后一共会输出…十六种可能;函数被压入栈中16次</p></li><li><p>n&#x3D;x时<code>n = x-1</code> 函数调用为<code>backtrack(x-1, back + &quot;)&quot;)</code>和<code>backtrack(x-1, back + &quot;(&quot;)</code>对应了<code>2 * (backtrack(x-1))</code>种可能);函数被压入栈中次<code>2 * (backtrack(x-1))</code>次</p></li></ul><blockquote><p>总结：枚举不同可能是一个不断搜索尝试的过程，由于枚举过程需要保存上一次枚举的结果集，而函数参数值在每次函数调用的过程中会保存下来，利用这一特性我们只要在递归终止条件中，将递归后的结果集保存下来就可以穷举出所有可能。</p></blockquote><h4 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h4><p>剪枝就是在穷举的结果集中过滤到不合法的结果集</p><p>根据题意可分析到剪枝条件:</p><ul><li><p>左括号数量不能超出n&#x2F;2</p></li><li><p>左括号一定要先于右括号出现</p></li><li><p>右括号数量不能超出n&#x2F;2</p></li></ul><p>所以我们要在递归调用中增加函数参数，来保存左括号和右括号出现的次数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> backtrack <span class="function"><span class="keyword">func</span> <span class="params">(<span class="type">int</span>, <span class="type">string</span>, <span class="type">int</span>, <span class="type">int</span>)</span></span></span><br><span class="line">backtrack = <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>, back <span class="type">string</span>, left, right <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    backtrack(n- <span class="number">1</span>, back + <span class="string">&quot;)&quot;</span>, left, right + <span class="number">1</span>) <span class="comment">// 通过right+1实现右括号计数</span></span><br><span class="line">    backtrack(n- <span class="number">1</span>, back + <span class="string">&quot;(&quot;</span>, left + <span class="number">1</span>, right) <span class="comment">// 通过left+1实现左括号计数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据刚才的剪枝分析增加判断条件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须先保证左括号先出现，才能出现右括号</span></span><br><span class="line"><span class="keyword">if</span> left &gt; right &#123;</span><br><span class="line">    backtrack(n- <span class="number">1</span>, back + <span class="string">&quot;)&quot;</span>, left, right + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当左括号出现超过n/2时，剪掉多余的左括号，并且只添加右括号</span></span><br><span class="line"><span class="keyword">if</span> left &lt; n / <span class="number">2</span> &#123;</span><br><span class="line">    backtrack(n- <span class="number">1</span>, back + <span class="string">&quot;(&quot;</span>, left + <span class="number">1</span>, right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于保证了left出现次数不会超过n&#x2F;2,并且总出现次数限制为n（n&#x3D;0时函数会退出），所以右括号数量不能超出n&#x2F;2的判断代码不用实现</p></blockquote><p>由于函数在递归调用过程中,n由于减1会发生变化，我们需要在全局变量中声明<code>m</code>并保存<code>n</code>的初始值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> backtrack <span class="function"><span class="keyword">func</span> <span class="params">(<span class="type">int</span>, <span class="type">string</span>, <span class="type">int</span>, <span class="type">int</span>)</span></span></span><br><span class="line">n = n * <span class="number">2</span></span><br><span class="line">m := n</span><br><span class="line">backtrack = <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>, back <span class="type">string</span>, left, right <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    backtrack(n- <span class="number">1</span>, back + <span class="string">&quot;)&quot;</span>, left, right + <span class="number">1</span>) <span class="comment">// 通过right+1实现右括号计数</span></span><br><span class="line">    backtrack(n- <span class="number">1</span>, back + <span class="string">&quot;(&quot;</span>, left + <span class="number">1</span>, right) <span class="comment">// 通过left+1实现左括号计数</span></span><br><span class="line">    <span class="keyword">if</span> left &gt; right &#123;</span><br><span class="line">        backtrack(n- <span class="number">1</span>, back + <span class="string">&quot;)&quot;</span>, left, right + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当左括号出现超过n/2时，剪掉多余的左括号，并且只添加右括号</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; m / <span class="number">2</span> &#123;</span><br><span class="line">        backtrack(n- <span class="number">1</span>, back + <span class="string">&quot;(&quot;</span>, left + <span class="number">1</span>, right)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完整代码示例"><a href="#完整代码示例" class="headerlink" title="完整代码示例"></a>完整代码示例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateParenthesis</span><span class="params">(n <span class="type">int</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> backtrack <span class="function"><span class="keyword">func</span> <span class="params">(<span class="type">int</span>, <span class="type">string</span>, <span class="type">int</span>, <span class="type">int</span>)</span></span></span><br><span class="line">	<span class="keyword">var</span> res = <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>)</span><br><span class="line">	n = n * <span class="number">2</span></span><br><span class="line">	m := n</span><br><span class="line">	backtrack = <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>, back <span class="type">string</span>, left, right <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">			res = <span class="built_in">append</span>(res, back)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//必须先保证左括号先出现，才能出现右括号</span></span><br><span class="line">		<span class="keyword">if</span> left &gt; right &#123;</span><br><span class="line">			backtrack(n- <span class="number">1</span>, back + <span class="string">&quot;)&quot;</span>, left, right + <span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//当左括号出现超过n/2时，剪掉多余的左括号，并且只添加右括号</span></span><br><span class="line">		<span class="keyword">if</span> left &lt; m / <span class="number">2</span> &#123;</span><br><span class="line">			backtrack(n- <span class="number">1</span>, back + <span class="string">&quot;(&quot;</span>, left + <span class="number">1</span>, right)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	backtrack(n, <span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/in-post/2022-01-15/img.png" alt="img.png"></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2021/09/12/2021-09-12-%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2021/09/12/2021-09-12-%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">非连续内存管理</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-09-12 19:30:00" itemprop="dateCreated datePublished" datetime="2021-09-12T19:30:00+08:00">2021-09-12</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="为什么使用非连续内存分配"><a href="#为什么使用非连续内存分配" class="headerlink" title="为什么使用非连续内存分配"></a>为什么使用非连续内存分配</h2><p>考虑多道程序设计连续内存分配两种管理方式</p><ol><li>固定分配，缺乏灵活性，大量内部内存分片产生，内存利用率低</li><li>动态分配，大量外部内存分片产生，可通过”紧凑”技术解决，但是紧凑效率低<br>基于这一思想，产生了”非连续分配方式”</li></ol><p>非连续内存管理方式分为下图几种<br><img src="/../img/in-post/2021-09-12/img_1.png" alt="img.png"></p><h2 id="分页存储"><a href="#分页存储" class="headerlink" title="分页存储"></a>分页存储</h2><h3 id="分页存储思想"><a href="#分页存储思想" class="headerlink" title="分页存储思想"></a>分页存储思想</h3><p>假设进程A大小为23MB，但是每个分区大小只有10MB，如果进程只能占用一个分区，那显然放不下。</p><p>解决思路：如果允许进程占用多个分区，那么可以把进程拆分成<code>10MB+10MB+3MB</code>三个部分，再把这三个部分分别放到三个分区中（这些分区不要求连续）</p><p>进程A的最后一个部分是3MB，放入分区后会产生 7MB 的内部碎片。</p><p>如果每个分区大小为 2MB，那么进程A可以拆分成 11* 2MB + 1MB 共12个部分，只有最后一部分 1MB占不满分区，会产生 1MB 的内部碎片。</p><p>显然，如果把分区大小设置的更小一些，内部碎片会更小，内存利用率会更高。</p><h3 id="分页存储管理的重要概念"><a href="#分页存储管理的重要概念" class="headerlink" title="分页存储管理的重要概念"></a>分页存储管理的重要概念</h3><p>将内存空间分为一个个大小相等的分区（比如：每个分区4KB），每个分区就是一个“页框”，或称“页帧” “内存块” “物理块” 。每个页框有一个编号，即“页框号” （或 者“内存块号” “页帧号” “物理块号〞，页框号从O开 始 将用户进程的地址空问也分为与页框大人相等的一个个区城， 称为“页”或“页面” 。每个页面也有 一个编号，即“页号” 页号也是从0开始。</p><p>(注：进程的最后一个页面可能没有一个页框那么大。因此， 页框不能太大，否则可能产生过大的内部碎片）</p><p>操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的页面与内存的页 框有一对应的关系。 各个页面不必连续存放，也不必按先后顺序来，可以放到不相邻的各个页框中。</p><h3 id="地址转化"><a href="#地址转化" class="headerlink" title="地址转化"></a>地址转化</h3><h4 id="操作系统如何实现逻辑地址到物理地址的转化"><a href="#操作系统如何实现逻辑地址到物理地址的转化" class="headerlink" title="操作系统如何实现逻辑地址到物理地址的转化"></a>操作系统如何实现逻辑地址到物理地址的转化</h4><p>假设每页大小50b<br><img src="/../img/in-post/2021-09-12/img.png" alt="img.png"></p><p>逻辑地址为80的内存单元： 应该在1号页，该页在内存中的起始位置为450，逻辑地址为80的内存单元相对于该页的起始地址而言， “偏移量”应该是30。 实际物理地址450+30&#x3D;480</p><ol><li>要算出逻辑地址对应的页号</li><li>要知道该页号对应页面在内存中的起始地址</li><li>要算出逻辑地址在医面内的“偏移 量”</li><li>物理地址&#x3D;页面始址＋页内偏移量</li></ol><h4 id="偏移量和页号计算"><a href="#偏移量和页号计算" class="headerlink" title="偏移量和页号计算"></a>偏移量和页号计算</h4><p>页号：80 &#x2F; 50 &#x3D; 1</p><p>偏移量：80 % 50 &#x3D; 30</p><p>1号页在内存的起始位置为450</p><blockquote><p>为了方便计算页号，偏移量和页面大小一般为2的幂次方</p></blockquote><p>逻辑地址 4097，用二进制表示应该是 <code>00000000000000000001000000000001</code> 若 1号页在内存中的起始地址为x，则逻辑地址4097对应的物理地址应该是x+1000000000001</p><p>如何计算： 页号&#x3D;逻辑地址&#x2F; 页面长度（取除法的整数部分）</p><p>为了方便计算 页而大小一般 页内偏移量&#x3D;逻辑地址 % 页面长度（取除法的余数部分）<br>假设用32个二进制位表示逻辑地址，页面大小为 210B&#x3D;1024B&#x3D; 1KB</p><p>0号页的逻辑地址空间应该是 0~1023，用二进制表示应该是： <code>00000000000000000000000000000000 ~ 00000000000000000000001111111111</code></p><p>1号页的逻辑地址空间应该是 1024~2047，用二进制表示恩该是： <code>00000000000000000000010000000000 ~ 00000000000000000000011111111111</code></p><p>2号页的逻辑地址空间应该是 2048~3021，用二进制表示应该是： <code>00000000000000000000100000000000 ~ 00000000000000000000101111111111</code></p><p>结论：如果每个页面大小为 2^B，用二进制数表示逻辑地址，则末尾K位即为页内便宜量，其余部分就是页号，因此，如果让每个页面的大小为2的整数幂，计算机就可以很方便地得出一个逻辑地址和页内偏移量。</p><h4 id="为什么是2的幂次方？"><a href="#为什么是2的幂次方？" class="headerlink" title="为什么是2的幂次方？"></a>为什么是2的幂次方？</h4><p>例如计算1026和2055的页号和页面偏移量<br>1026的32位二进制表示为<code>00000000000000000000010000000010</code></p><p>如果每个页面大小为2^10,末尾10位为<code>0000000010</code>,可得出页面偏移量为2，其余部分为<code>0000000000000000000001</code>,可得出在1号页</p><p>2055的32位二进制表示为<code>00000000000000000000100000000111</code></p><p>如果每个页面大小为2^10,末尾10位为<code>0000000111</code>,可得出页面偏移量为7，其余部分为<code>0000000000000000000010</code>,可得出在2号页</p><h4 id="如何知道页面在内存的起始位置"><a href="#如何知道页面在内存的起始位置" class="headerlink" title="如何知道页面在内存的起始位置"></a>如何知道页面在内存的起始位置</h4><p>这里引入一个新概念<strong>页表</strong></p><p>为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表。</p><ol><li>一个进程对应一张页表</li><li>进程每一页对应一个页表项</li><li>每个页表由页号和块号组成</li><li>页表记录进程页面和世纪存放的内存块对应关系</li><li>每个页表项的长度是相同的，页号是隐含的</li></ol></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2021/09/10/2021-09-10-%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2021/09/10/2021-09-10-%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">连续内存管理</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-09-10 19:30:00" itemprop="dateCreated datePublished" datetime="2021-09-10T19:30:00+08:00">2021-09-10</time></span></div></header><div class="post-body" itemprop="articleBody"><p><img src="/../img/in-post/2021-09-10/img.png" alt="img.png"></p><h2 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h2><ul><li>内存只能有一道用户程序，内存分成2块，操作系统区和用户区，用户程序放在用户区</li><li>没有外部碎片，因为分配的是整一块，干干净净，容不下第二道程序；但是有内部碎片，因为一道程序可能没那么大</li><li>因为是只支持单道程序，可以采用覆盖技术扩充内存</li></ul><h2 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h2><ul><li>支持多道程序，将内存用户空间（一部分是系统空间）划分若干个分区，每个分区只能装一道作业</li><li>没有外部碎片，有内部碎片</li><li>2种划分方式，分区大小相等，分区大小不相等</li></ul><h2 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h2><ol><li><p>支持多道程序，在进程进入内存时，动态根据进程大小划分分区</p></li><li><p>2种数据结构</p><ul><li>空闲分区表</li><li>空闲分区链</li></ul></li><li><p>进程多大，分区就多大，所以没有内部碎片，但是有外部碎片,外部碎片可以用紧凑技术解决</p></li><li><p>回收内存分区时，有4种情况</p><ul><li>情况一：回收区的后面有一个相邻的空闲分区</li><li>情况二：回收区的前面有一个相邻的空闲分区</li><li>情况三：回收区的前、后各有一个相邻的空闲分区</li><li>情况四：回收区的前、后都没有相邻的空闲分区</li></ul></li></ol><p>总之，相连的空闲分区要合并</p><ol start="5"><li>当多个空闲分区都能满足要求时，应该选择哪个分区进行分配？<ul><li>首次适应算法first fit</li><li>最佳适应算法best fit</li><li>最坏适应算法worst fit</li><li>邻近适应算法next fit</li></ul></li></ol><table><thead><tr><th>算法</th><th>思想</th><th>分区排列顺序</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>首次适应</td><td>从头到尾找到适合的分区</td><td>空闲分区以地址递增次序排列</td><td>性能最好，<strong>算法开销小</strong>回收后不需要对空闲分区重新排序</td><td></td></tr><tr><td>最佳适应</td><td>优先使用更小的分区，以保留更多的分区</td><td>空闲分区以容量递增次序排列</td><td>会有更多的大分区被保留下来，更能满足大进程需求</td><td>会产生很多小、难以利用的碎片，<strong>算法开销大</strong>，回收后可能需要对空闲分区队列重新排序</td></tr><tr><td>最坏适应</td><td>优先使用更大的分区，以防止产生太多太小的不可用的碎片</td><td>空闲分区以容量递增次序排列</td><td>可以减少许多难以利用的小碎片</td><td>大分区容易被用完，不利于大进程，<strong>算法开销大</strong></td></tr><tr><td>邻近适应</td><td>由首次适应演变而来，每次从上次查找结束位置开始查找</td><td>空闲分区以地址递增次序排列</td><td>不用每次都从低地址的小分区开始检索，<strong>算法开销小</strong></td><td></td></tr></tbody></table></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2021/07/15/2021-07-15-%E8%B0%83%E5%BA%A6/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2021/07/15/2021-07-15-%E8%B0%83%E5%BA%A6/" class="post-title-link" itemprop="url">调度</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-07-15 19:30:00" itemprop="dateCreated datePublished" datetime="2021-07-15T19:30:00+08:00">2021-07-15</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="调度简介"><a href="#调度简介" class="headerlink" title="调度简介"></a>调度简介</h2><p>当计算机系统是多道程序设计系统时，通常会有多个进程或线程同时竞争cpu,只要有两个以上的进程处于就绪状态，并且只有一个cpu可用，那么就必须选择下一个要运行的进程<br>完成这项工作的这一程序称作<strong>调度程序</strong>,该程序使用的算法叫做<strong>调度算法</strong></p><h2 id="何时调度"><a href="#何时调度" class="headerlink" title="何时调度"></a>何时调度</h2><ul><li>创建进程：创建一个新进程后需要决策是优先运行父进程还是子进程，由于这两种进程都处于就绪状态，是一个正常的调度，调度程序可以合法选择先运行父进程还是子进程</li><li>进程退出：从就绪进程中选择一个进程，如果没有就绪的进程，通常会运行一个系统提供的空闲进程</li><li>IO阻塞：根据阻塞的原因决定选择调度的进程</li><li>IO中断：通过<strong>抢占式</strong>和<strong>非抢占式</strong>算法决定调度</li></ul><h3 id="抢占式"><a href="#抢占式" class="headerlink" title="抢占式"></a>抢占式</h3><p>一旦进程开始执行，调度就在进程从运行状态切换到就绪状态以及从等待状态切换到就绪状态时发生，称为抢先调度。<br>在这种调度中，资源(CPU周期)会在短时间内分配给该进程，如果遇到某些优先级更高的进程，则可以暂停当前进程以处理该进程。</p><h3 id="非抢占式"><a href="#非抢占式" class="headerlink" title="非抢占式"></a>非抢占式</h3><p>一旦进程开始执行，调度将在进程终止或进程从运行状态切换到等待状态时进行。<br>在非抢占式调度中，调度程序在执行过程中不会中断当前正在运行的进程。 但是它等待进程完成其与CPU的执行，然后可以将CPU分配给另一个进程。</p><p>抢占式调度在执行过程的中间，执行被中断，而; 在非抢占式调度中，在执行过程中不会中断执行。</p><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h3><h4 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h4><p>使用队列数据结构实现</p><ol><li>按照作业提交，或进程变为就绪状态的先后次序分派CPU；</li><li>新作业只有当当前作业或进程执行完或阻塞才获得CPU运行</li><li>被唤醒的作业或进程不立即恢复执行，通常等到当前作业或进程出让CPU,容易产生延迟。（所以，默认即是非抢占方式）</li><li>有利于CPU繁忙型的作业，而不利于I&#x2F;O繁忙的作业（进程）。</li></ol><h4 id="最短作业优先"><a href="#最短作业优先" class="headerlink" title="最短作业优先"></a>最短作业优先</h4><p>运行时间可以预知的非抢占式批处理调度算法，适用于所有作业都可同时运行</p><p>假设我们知道进程A,B,C,D的运行时间,A 8秒，B 4秒，C 4秒，D 4秒，由下图可知，选择B、C、D、A的顺序运行，平均等待时间最短</p><p><img src="/../img/in-post/2021-07-15/img.png" alt="img.png"></p><h4 id="最短剩余时间优先"><a href="#最短剩余时间优先" class="headerlink" title="最短剩余时间优先"></a>最短剩余时间优先</h4><p>调度程序总是选择运行时间最短的那个进程优先执行</p><h3 id="交互式"><a href="#交互式" class="headerlink" title="交互式"></a>交互式</h3><h4 id="轮转调度"><a href="#轮转调度" class="headerlink" title="轮转调度"></a>轮转调度</h4><p>为每个进程分配一个时间片，进程在被允许的时间范围内执行，如果超出时间范围还在执行,cpu会剥夺该进程，并分配给另一个进程，如果进程提前执行完，cpu立即切换，是一种最公平、最简单的调度算法</p><p>时间片轮转会维护一张进程表，当一个进程用完它的时间片后，就会被移动到队列末尾</p><p><img src="/../img/in-post/2021-07-15/img_1.png" alt="img_1.png"></p><p>由于进程切换时，需要维护管理所需要的保存和装入的寄存器值及内存映像，各种更新表格和列表，会产生进程上下文切换，所以当时间片过短时，进程频繁切换，降低cpu效率，如果过长，会引起短的交互请求等待过程，通常时间片设置到20～50ms是比较合适的折中</p><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>维护优先级队列，每个进程被分配优先级权重，按优先级高低分配到优先级队列<br><img src="/../img/in-post/2021-07-15/img_2.png" alt="img_2.png"></p><h4 id="多级队列"><a href="#多级队列" class="headerlink" title="多级队列"></a>多级队列</h4><p>多级队列调度算法将就绪队列分成多个单独队列。根据进程属性，如内存大小、进程优先级、进程类型等，一个进程永久分到一个队列，每个队列有自己的调度算法。</p><p>队列之间划分时间片</p><ul><li>最高优先级上进程运行一个时间片，次高优先级上进程运行两个时间片，再下级运行四个时间片，依次类推。</li><li>每次从队列头开始运行进程，每当一个进程在一个优先级队列中用完它时间片后就移到队列尾部；只有当高优先级队列为空时，才会从不为空的低优先级队列中选择进程运行；在低优先队列中等待时间过长进程将会移动高优先级队列</li></ul><h4 id="最短进程优先"><a href="#最短进程优先" class="headerlink" title="最短进程优先"></a>最短进程优先</h4><p>对于批处理系统而言，由于最短作业通常可以伴随着最短相应时间，所以如果被应用到交互式系统中，那将是非常好的，而最短进程就可以看作是最短作业被应用到交互式系统</p><h4 id="保证调度"><a href="#保证调度" class="headerlink" title="保证调度"></a>保证调度</h4><p>保证调度算法是另外一种类型的调度算法,它向用户所做出的保证并不是优先运行,而是明确的性能保证,该算法可以做到调度的公平性。<br>一种比较容易实现的性能保证是处理机分配的公平性。如果在系统中有n个相同类型的进程同时运行,为公平起见,须保证每个进程都获得相同的处理机时间1&#x2F;n</p><h4 id="彩票调度"><a href="#彩票调度" class="headerlink" title="彩票调度"></a>彩票调度</h4><p>彩票数（ticket）代表了进程（或用户或其他）占有某个资源的份额。一个进程拥有的彩票数占总彩票数的百分比，就是它占有资源的份额。</p><h3 id="实时"><a href="#实时" class="headerlink" title="实时"></a>实时</h3><p>实时系统通常可以分为硬实时和软实时，前者的含义是必须满足绝对的截止时间，后者的含义是虽然不希望偶尔错失截止时间，但是可以容忍。在这两种情形中，实时性能都是通过把程序划分为一组进程而实现的，其中每个进程的行为是可预测和提前掌握的。这些进程一般寿命较短，并且极快地就运行完成。在检测到一个外部信号时，调度程序的任务就是按照满足所有截止时间的要求调度进程。</p><p>实时系统中的事件可以按照响应方式进一步分类为周期性（以规则的时间间隔发生）事件或非周期性（发生时间不可预知）事件。一个系统可能要响应多个周期性事件流。根据每个事件需要处理时间的长短，系统甚至有可能无法处理完所有的事件。例如，如果有m个周期事件，事件i以周期Pi发生，并需要Ci秒CPU时间处理一个事件，那么可以处理负载的条件是</p><p><code>c1/p1+c2/p2+......+cm/pm≤1</code></p><p>满足这个条件的实时系统称为是可调度的。</p><p>作为一个例子，考虑一个有三个周期性事件的软实时系统，其周期分别是100ms、200ms和500ms。如果这些事件分别需要50ms、30ms和100 ms的CPU时间，那么该系统是可调度的，因为 0.5 + 0.15 + 0.2 &lt; 1。如果有第四个事件加入，其周期为1秒，那么只要这个事件是不超过每事件150ms的CPU时间，那么该系统就仍然是可调度的。在这个计算中隐含了一个假设，即上下文切换的开销很小，可以忽略不计。</p><p>实时系统的调度算法可以是静态或动态的。前者在系统开始运行之前作出调度决策；后者在运行过程中进行调度决策。只有在可以提前掌握所完成的工作以及必须满足的截止时间等全部信息时，静态调度才能工作。而动态调度算法不需要这些限制。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2021/07/01/2021-07-01-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2021/07/01/2021-07-01-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" class="post-title-link" itemprop="url">系统调用</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-07-01 19:30:00" itemprop="dateCreated datePublished" datetime="2021-07-01T19:30:00+08:00">2021-07-01</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><h3 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h3><p><strong>用户态</strong>和<strong>内核态</strong>是操作系统的两种运行状态，操作系统主要是为了对访问能力进行限制，用户态的权限较低，而内核态的权限较高</p><ul><li>用户态：用户态运行的程序只能受限地访问内存，只能直接读取用户程序的数据，并且不允许访问外围设备，用户态下的 CPU 不允许独占，也就是说 CPU 能够被其他程序获取。</li><li>内核态：内核态运行的程序可以访问计算机的任何数据和资源，不受限制，包括外围设备，比如网卡、硬盘等。处于内核态的 CPU 可以从一个程序切换到另外一个程序，并且占用 CPU 不会发生抢占情况。</li></ul><h3 id="系统调用流程"><a href="#系统调用流程" class="headerlink" title="系统调用流程"></a>系统调用流程</h3><p>当应用程序调用系统服务时、如读取文件内容，会发生如下调用过程</p><ul><li>调用程序首先把参数压入堆栈</li><li>把<code>read</code>代码通过汇编插入到寄存器，然后将操作系统控制由用户空间切换到内核空间</li><li>分派正确的系统调用处理器，之后执行<code>read</code>系统调用，执行完成后将操作系统控制转交给用户空间</li><li>切换到用户空间，记录栈帧，最后应用程序清楚堆栈信息</li></ul><p><img src="/../img/in-post/2021-07-01/img.png" alt="img.png"></p><blockquote><p>步骤3中，系统调用可能会阻塞调用者，比如试图读取键盘输入信息，如果没有键入，就会发生阻塞，稍后、当需要的键入输入时，操作系统会通知进程，之后会继续执行后面的流程</p></blockquote><p>参考文献:现代操作系统</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2021/06/02/2021-06-01-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2021/06/02/2021-06-01-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">进程与线程</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-06-02 19:30:00" itemprop="dateCreated datePublished" datetime="2021-06-02T19:30:00+08:00">2021-06-02</time></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><p>进程为操作系统提供了伪(并行)的能力，线程提高了操作系统伪(并行)的能力，没有进程和线程，现代计算是不复存在的<br>以下内容均为<code>UNIX</code>操作系统中描述</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>在进程模型中，所有在计算机上可运行的软件，包括操作系统，被组织成若干<strong>顺序进程</strong>，简称<strong>进程</strong></p><h3 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h3><p>一个进程包含程序计数器、寄存器和变量当前的值，从概念上来讲，每个进程拥有自己的cpu，实际上是cpu在进程间不断的切换导致的错觉，这种快速切换称为<strong>多道程序设计</strong><br>对于用户进程，其既有用户地址空间中的栈，也有它自己的内核栈。而内核进程就只有内核栈。</p><table><thead><tr><th>每个进程的内容</th></tr></thead><tbody><tr><td>地址空间</td></tr><tr><td>全局变量</td></tr><tr><td>打开文件</td></tr><tr><td>子进程</td></tr><tr><td>定时器</td></tr><tr><td>信号和信号处理程序</td></tr><tr><td>账户信息</td></tr></tbody></table><h4 id="多道程序设计模型"><a href="#多道程序设计模型" class="headerlink" title="多道程序设计模型"></a>多道程序设计模型</h4><p>采用多道程序设计可提高cpu的利用率</p><p>cpu利用率计算公式:<code>1-p^n</code></p><p>p表示进程等待时间和运行时间的之比,n表示多道程序设计的道数<br>例如：一个8g内存的操作系统，操作系统占了2G,每个应用程序占了2G,假如每个应用程序80%的时间都处于IO等待，那么cpu利用率等于<code>1-0.8^3</code>约为49%<br>这时候，增加8g内存，运行程序数量，可从3道程序设计提高到7道，cpu利用率为1-0.8^7,cpu利用率提升到79%</p><p>如果在增加8g内存，cpu利用率只能由79%提升到91%，显然不如之前的第一种投资好</p><h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><p>进程创建主要通过系统调用<code>fork</code>函数来实现的，调用后会创建后会创建一个与调用进程相同的副本，称之为<strong>子进程</strong>，这两个进程拥有相同的内存镜像，他们拥有各自不同的地址空间，其中不可写的内存区域是可共享的。可写的内存区是不共享的，通过<strong>写时复制</strong>共享</p><h3 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h3><p>进程终止由以下几个条件引起</p><ul><li>正常退出（自愿）</li><li>出错退出（自愿）</li><li>严重错误退出（非自愿）</li><li>被其他进程杀死退出（非自愿）</li></ul><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><ul><li>运行态</li><li>就绪态</li><li>阻塞态</li></ul><p>前两种状态是类似的，区别是第二种状态没有分配cpu资源，第三种状态与前两种不同，处于该状态进程不能运行，即使cpu是空闲的</p><h3 id="进程实现"><a href="#进程实现" class="headerlink" title="进程实现"></a>进程实现</h3><p>操作系统维护一个表格（结构数组或链表）即进程表，该表包含了进程状态的重要信息，包括程序各种状态转换时必须保存的信息，从而保证进程再次启动时，像从未中断过一样</p><table><thead><tr><th>进程管理</th><th>存储管理</th><th>文件管理</th></tr></thead><tbody><tr><td>寄存器</td><td>正文段指针</td><td>根目录</td></tr><tr><td>程序计数器</td><td>数据段指针</td><td>工作目录</td></tr><tr><td>程序状态字</td><td>堆栈段指针</td><td>文件描述符</td></tr><tr><td>堆栈指针</td><td></td><td>用户id</td></tr><tr><td>进程状态</td><td></td><td>组id</td></tr><tr><td>优先级</td><td></td><td></td></tr><tr><td>调度参数</td><td></td><td></td></tr><tr><td>进程id</td><td></td><td></td></tr><tr><td>父进程</td><td></td><td></td></tr><tr><td>进程组</td><td></td><td></td></tr><tr><td>信号</td><td></td><td></td></tr><tr><td>进程开始时间</td><td></td><td></td></tr><tr><td>使用cpu的时间</td><td></td><td></td></tr><tr><td>子进程cpu时间</td><td></td><td></td></tr><tr><td>下次定时器时间</td><td></td><td></td></tr></tbody></table><h3 id="进程分类"><a href="#进程分类" class="headerlink" title="进程分类"></a>进程分类</h3><ul><li><strong>系统进程</strong>：可以执行内存资源分配和进程切换等管理工作；而且，该进程的运行不受用户的干预，即使是root用户也不能干预系统进程的运行。</li><li><strong>用户进程</strong>：通过执行用户程序、应用程序或内核之外的系统程序而产生的进程，此类进程可以在用户的控制下运行或关闭。</li><li><strong>针对用户进程</strong>:又可以分为交互进程、批处理进程和守护进程三类。</li><li><strong>交互进程</strong>：由一个shell终端启动的进程，在执行过程中，需要与用户进行交互操作，可以运行于前台，也可以运行在后台。</li><li><strong>批处理进程</strong>：该进程是一个进程集合，负责按顺序启动其他的进程。</li><li><strong>守护进程</strong>:守护进程是一直运行的一种进程，经常在linux系统启动时启动，在系统关闭时终止。它们独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。例如httpd进程，一直处于运行状态，等待用户的访问。还有经常用的crond进程，这个进程类似与windows的计划任务，可以周期性的执行用户设定的某些任务</li></ul><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是cpu执行的最小单元，比进程更轻量级，更容易创建或撤销</p><h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><p>线程也包含程序计数器、寄存器和自己的堆栈</p><p>进程中的不同线程不像不同进程那样存在很大的独立性，所有的线程都有完全一样的地址空间，这意味着它们可以共享全局变量</p><table><thead><tr><th>每个线程的内容</th></tr></thead><tbody><tr><td>程序计数器</td></tr><tr><td>寄存器</td></tr><tr><td>堆栈</td></tr><tr><td>状态</td></tr></tbody></table><p>每个线程拥有自己的堆栈，原因是：<br>线程调用时需要使用栈帧存放局部变量和调用后返回的地址，而每个线程调用的过程是不同，要单独维护一套自己的执行历史</p><h3 id="线程的使用"><a href="#线程的使用" class="headerlink" title="线程的使用"></a>线程的使用</h3><p>需要多线程的原因有两个，</p><ul><li>并行实体拥有同一个地址空间和所有可用数据的能力</li><li>线程比进程更轻量级，创建一个线程比进程快10-100倍，当有大量线程需要动态和快速修改时，这一特性很有必要</li></ul><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>同进程一样，线程也可以处于运行、阻塞、就绪或终止状态</p><h3 id="线程实现方式"><a href="#线程实现方式" class="headerlink" title="线程实现方式"></a>线程实现方式</h3><h4 id="在用户空间实现"><a href="#在用户空间实现" class="headerlink" title="在用户空间实现"></a>在用户空间实现</h4><p>整个线程包处于用户空间，从内核角度考虑，就是按正常单进程单线程方式管理，这种方式好处是有些操作系统内核不支持多线程，也可以一样使用多线程模型</p><p>用户空间线程除了这点好处，还有以下几点优势：</p><ul><li>线程的状态和调度保存是本地过程，不需要内核来参与，也避免了上下问切换，cpu内存高速缓存刷新，调度敏捷</li><li>允许每个进程有自己的调度算法，例如，在某些应用程序中有垃圾回收线程，应用程序不需要担心线程会在不合适的时刻停止</li><li>拥有很好的扩展性，内核线程在内核空间需要固定的表格空间和堆栈空间，如果内核线程数量非常大，会出现问题</li></ul><p>当然，它也有一些不可避免的缺点：</p><ul><li>用户空间线程去做系统级调用是不可接受的，会停止所有的线程，而实现线程的目标是要允许每个线程使用阻塞调用，不会影响其他线程，相违背</li><li>该线程运行时，进程内其他线程不能运行，除非该线程放弃cpu</li></ul><h4 id="在内核实现"><a href="#在内核实现" class="headerlink" title="在内核实现"></a>在内核实现</h4><p>内核线程在操作系统内核中保存了每个线程的寄存器、状态、和其他信息，跟用户空间线程是一样的，区别是保存在了内核中</p><p>内核线程的管理工作由操作系统内核完成，这种实现的好处是当一个线程阻塞时，内核根据选择，可以切换到进程内另一个线程<br>如果当某个线程引发了页面故障，内核可以很方便的检测是否有其他可用的线程，让其执行</p><p>虽然内核解决了线程很多问题，但也不会解决所有问题，比如当一个新进程创建，是将进程里的所有线程都复制，还是只有一个线程？<br>还有一个问题是当过来一个信号，可以交给需要的线程执行，当时多个线程都注册了该信号，会发生什么？</p><h4 id="混合实现"><a href="#混合实现" class="headerlink" title="混合实现"></a>混合实现</h4><p>混合实现主要分为用户线程和内核线程多对1、1对1、和多对多模式，其中多对1模式就是前面介绍的在用户空间实现的线程模型，线程中使用阻塞时会阻塞其他线程<br><img src="/img/in-post/2021-06-02/img.png" alt="img.png"><br>混合模式解决了多对多和1对1模型解决了线程没办法使用阻塞问题，但是1对1模型会占用多个内核线程，对操作系统内核切换影响比较大，第三种多对多模型是并发效果最好的</p><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>进程通常需要与其他进程通信，以达到信息传递并能保证进程按照正确顺序执行</p><h4 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h4><p>多个进程读写某个共享数据，而最后的结果取决于进程运行的精准时序，称为竞争条件</p><h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><p>怎样避免竞争条件？主要目标是组织多个进程同时读取共享数据，即互斥<br>抽象描述就是，我们把共享内存进行访问的程序片段叫做<strong>临界资源</strong>或者<strong>临界区</strong>,我们只要保证两个进程不同时在临界区，就能避免竞争</p><p>尽管避免竞争条件，我们还是不能保证数据共享的并发进程能高效的执行：对于一个好的解决方案，需要满足以下条件</p><ul><li>任何两个进程不能同时处于临界区</li><li>不应对cpu的数量和速度做任何假设</li><li>临界区外的运行进程不得阻塞其他进程</li><li>不得使进程无限期等待进入临界区</li></ul><p><img src="/img/in-post/2021-06-02/img_1.png" alt="img_1.png"><br>对于理想的方案应该是如上图这样的，某一时刻对与临界区的访问只能有一个进程</p><h4 id="互斥方案"><a href="#互斥方案" class="headerlink" title="互斥方案"></a>互斥方案</h4><h5 id="屏蔽中断"><a href="#屏蔽中断" class="headerlink" title="屏蔽中断"></a>屏蔽中断</h5><p>最简单的实现方案，当进程进入临界区时，立即屏蔽所有中断，在离开之前打开中断，屏蔽中断后，cpu时钟中断也会屏蔽，cpu只有在发生时钟中断或其他中断时才会切换进程，这样，屏蔽中断后cpu不会切换进程，不必担心其他进程的介入</p><p>这个方案并不好，对于单核cpu，执行屏蔽中断如果不在打开，系统会因此而终止，对于多核cpu，仅对执行disable的那个cpu优先，其他cpu仍继续执行</p><h5 id="锁变量"><a href="#锁变量" class="headerlink" title="锁变量"></a>锁变量</h5><p>实现方案为设计一个锁变量，其值为0，如果有其他程序进入到临界区，会将值赋值为1，这样，其他进程读到1就不会在访问临界区了</p><p>这种方案也会出现疏忽，即两个进程同时进入临界区时，读到的临界变量都是0，执行了两次赋值1的操作，但还是发生了资源竞争</p><h5 id="严格轮换法"><a href="#严格轮换法" class="headerlink" title="严格轮换法"></a>严格轮换法</h5><p>进程a:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span>(turn != <span class="number">0</span>) &#123;&#125;</span><br><span class="line">    processstart()</span><br><span class="line">    turn = <span class="number">1</span></span><br><span class="line">    processend()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进程b:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span>(turn != <span class="number">1</span>) &#123;&#125;</span><br><span class="line">    processstart()</span><br><span class="line">    turn = <span class="number">0</span></span><br><span class="line">    processend()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始，进程a和b拿到的trun都是0，这时，只有进程a能进入并修改turn为1，这时进程b由于turn一直为0，会不断等待，直到turn变成1，这种忙等待行为被称为<strong>自旋锁</strong></p><p>这种方式如果两个进程的执行速度会相差很多，轮流进入时会有一方等待很长时间，显然是不合适的</p><h5 id="Person解法"><a href="#Person解法" class="headerlink" title="Person解法"></a>Person解法</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE  1</span></span><br><span class="line"><span class="comment">/* 进程数量 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N     2													</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 现在轮到谁 */</span></span><br><span class="line"><span class="type">int</span> turn;					</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 所有值初始化为 0 (FALSE) */</span></span><br><span class="line"><span class="type">int</span> interested[N];											</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 进程是 0 或 1 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enter_region</span><span class="params">(<span class="type">int</span> process)</span>&#123;					</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 另一个进程号 */</span></span><br><span class="line">  <span class="type">int</span> other;														</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 另一个进程 */</span></span><br><span class="line">  other = <span class="number">1</span> - process;				</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 表示愿意进入临界区 */</span></span><br><span class="line">  interested[process] = TRUE;						</span><br><span class="line">  turn = process;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 空循环 */</span></span><br><span class="line">  <span class="keyword">while</span>(turn == process </span><br><span class="line">        &amp;&amp; interested[other] == <span class="literal">true</span>)&#123;&#125; </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leave_region</span><span class="params">(<span class="type">int</span> process)</span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 表示离开临界区 */</span></span><br><span class="line">  interested[process] == FALSE;				 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用共享变量时（即进入其临界区）之前，各个进程使用各自的进程号 0 或 1 作为参数来调用 enter_region，这个函数调用在需要时将使进程等待，直到能够安全的临界区。在完成对共享变量的操作之后，进程将调用 leave_region 表示操作完成，并且允许其他进程进入。</p><p>现在来看看这个办法是如何工作的。一开始，没有任何进程处于临界区中，现在进程 0 调用 enter_region。它通过设置数组元素和将 turn 置为 0 来表示它希望进入临界区。由于进程 1 并不想进入临界区，所以 enter_region 很快便返回。如果进程现在调用 enter_region，进程 1 将在此处挂起直到 interested[0] 变为 FALSE，这种情况只有在进程 0 调用 leave_region 退出临界区时才会发生。</p><p>那么上面讨论的是顺序进入的情况，现在来考虑一种两个进程同时调用 enter_region 的情况。它们都将自己的进程存入 turn，但只有最后保存进去的进程号才有效，前一个进程的进程号因为重写而丢失。假如进程 1 是最后存入的，则 turn 为 1 。当两个进程都运行到 while 的时候，进程 0 将不会循环并进入临界区，而进程 1 将会无限循环且不会进入临界区，直到进程 0 退出位置。</p><h5 id="TSL指令"><a href="#TSL指令" class="headerlink" title="TSL指令"></a>TSL指令</h5><p>TSL指令是一个需要硬件支持的方案。TSL称为测试并加锁（test and set lock）。他将一个内存字LOCK读到寄存器RX中。然后在该内存地址上存一个非零值。读字和写字操作是不可分割的，即该指令结束前其他处理器均不允许访问该内存字。执行TSL指令的CPU将锁住内存中线，以禁止其他CPU在本指令结束前访问内存。TSL指令解决了忙等待的屏蔽中断方案中无法屏蔽多处理器访问共享内存的问题。 因为锁住内存总线不同于屏蔽中断，锁住内存总线后，所有处理器都无法通过内存总线访问内存字。 那些多处理器的计算机都有TSL指令。如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TSL RX, LOCK</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enter_region:</span><br><span class="line">    TSL REGISTER, LOCK</span><br><span class="line">    CMP REGISTER, #0</span><br><span class="line">    JNE enter_region       ; 如果不空闲(=0)，那么反复执行，处于忙等待状态</span><br><span class="line">    RET</span><br><span class="line"></span><br><span class="line">leave_region:</span><br><span class="line">    MOVE LOCK, #0</span><br><span class="line">    RET</span><br></pre></td></tr></table></figure><p>具体工作过程：第一条指令将lock原来的值复制到寄存器中并将lock设置为1，随后这个原来的值与0相比较。如果原来的值非零，则说明以前已被加锁，则程序将回到开始并再次测试。经过一段时间后，lock值变为0，于是过程返回，此时已加锁。要清除这个锁比较简单，程序只需将0存入lock即可，不需要特殊的同步指令。</p><p>一个可替代TSL的指令是XCHG，它原子性地交换两个位置的内容，例如，一个寄存器与一个存储字。它本质上与TSL的解决办法一样。所有的Intel x86 CPU在底层同步中使用XCHG指令。</p><h5 id="睡眠与唤醒"><a href="#睡眠与唤醒" class="headerlink" title="睡眠与唤醒"></a>睡眠与唤醒</h5><p>上述基于忙等待的互斥，不仅会浪费CPU时间，而且还可能引起预想不到的结果。例如，有两个进程L和H，L的优先级较低、H的优先级较高。调度规则规定，只要H处于就绪态它就会运行。在某一时刻，L处于临界区中，此时H变到就绪态，准备运行。现在H开始忙等待，待由于H就绪时，L就不会被调度，也就无法离开临界区，所以H将永远忙等待下去。这种情况有时被称作优先级反转问题。</p><p>最简单的进程间通信原语，它们在无法进入临界区时将阻塞，而不是忙等待。两条最简单的通信原语是：sleep和wakeup。sleep是一个将引起调用进程阻塞的系统调用，即被挂起，直到另外一个进程将其唤醒。wakeup调用有一个参数，即要被唤醒的进程。</p><h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><p>基于支持P、V操作的非负整数实现。</p><p>信号量的用处一：生产者-消费者问题</p><p>在使用信号量的系统中，隐藏中断的最自然的方法就是为每一个I&#x2F;O设备设置一个信号量，其初始值为0。在启动一个I&#x2F;O设备之后，管理进程就立即对相关联的信号量执行一个Down操作，于是进程立即被阻塞。当终端到来时，终端处理程序随即对相关信号量执行一个Up操作，从而将相关的进程设置为就绪状态。</p><p>为了解决生产者-消费者问题，可以使用三个信号量：full， 用于记录充满的缓冲槽数据；empty，用于记录空的缓冲槽总数；mutex，用来确保生产者和消费者不会同时访问缓冲区。</p><p>信号量的用处二：用于实现同步(Synchronization)</p><p>信号量full和empty用来保证某种时间的顺序发生或不发生。例如，当缓冲区满的时候生产者停止运行，而空的时候消费者停止运行。</p><h5 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h5><p>互斥量是一个可以处于两态之一的变量：加锁、解锁。相比于信号量，它没有计数功能。</p><p>由于互斥量非常简单，所以如果有TSL或XCHG指令，就可以很容易地在用户空间中实现它们。由于用户级线程包的mutex_lock和mutex_unlock代码下(0表示解锁)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mutex_lock:</span><br><span class="line">    TSL REGISTER, MUTEX</span><br><span class="line">    CMP REGISTER, #<span class="number">0</span></span><br><span class="line">    JZE ok                   ; 如果互斥锁空闲，那么就直接返回继续运行</span><br><span class="line">    CALL thread_yield        ; 如果互斥锁忙，那么就调用其它进程，这是与忙等待的区别</span><br><span class="line">    JMP mutex_lock           ; 稍后再试，也就是本代码段的开头</span><br><span class="line">ok: RET</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mutex_unlock:</span><br><span class="line">    MOVE MUTEX, #<span class="number">0</span></span><br><span class="line">    RET</span><br></pre></td></tr></table></figure><p>mutex_lock的代码与enter_region的代码很相似，但有一个关键的区别。当enter_region进入临界区失败后，它始终重复测试锁(忙等待)。实际上，由于时钟超时的作用，会调度其它进程运行，这样迟早拥有锁的进程会进入运行并释放锁。</p><p>在用户线程中，情形有所不同，因为没有时钟停止运行时间长度的线程。结果就是通过忙等待的方式来试图获取锁的线程将永远循环下去，绝不会得到锁，因为这个运行的线程不会让其它线程运行从而释放锁。</p><p>这就是enter_region与mutex_lock的区别</p><h5 id="Pthread中的互斥锁"><a href="#Pthread中的互斥锁" class="headerlink" title="Pthread中的互斥锁"></a>Pthread中的互斥锁</h5><p>pthread中提供了基于互斥锁的同步机制。提供的函数如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_init();      // 创建互斥锁</span><br><span class="line">pthread_mutex_destroy();   // 销毁互斥锁</span><br><span class="line">pthread_mutex_lock();      // 上锁</span><br><span class="line">pthread_mutex_trylock();   // 尝试上锁，若上锁不成功，会返回错误代码而不是阻塞调用者</span><br><span class="line">pthread_mutex_unlock();    // 对互斥锁解锁</span><br></pre></td></tr></table></figure><p>pthread中处理提供了互斥锁，还提供了条件变量用于实现同步。互斥量在允许或阻塞对临界区的访问上是很有用的，条件变量则允许线程由于一些未达到的条件而阻塞。绝大多数情况下，这两种方法是一起使用的。下面就是线程、互斥量、条件变量之间的关联。</p><h4 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h4><h5 id="为什么引入管程"><a href="#为什么引入管程" class="headerlink" title="为什么引入管程"></a>为什么引入管程</h5><p>信号量机制存在的问题：编写程序困难、易出错</p><p>能不能设计一种机制，让程序员写程序时不需要再关注复杂的PV操作，让写代码更轻松呢?</p><p>1973年，Brinch Hansen首次在程序设计语言(Pascal) 中引入了“管程”成分――一种高级同步机制</p><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>管程是一种特殊的软件模块，有这些部分组成:</p><ul><li><p>局部于管程的共享数据结构说明;</p></li><li><p>对该数据结构进行操作的一组过程;</p></li><li><p>对局部于管程的共享数据设置初始值的语句;</p></li><li><p>管程有一个名字。</p></li></ul><h5 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h5><p>管程的基本特征:</p><ul><li><p>局部于管程的数据只能被局部于管程的过程所访问;</p></li><li><p>一个进程只有通过调用管程内的过程（函数）才能进入管程访问共享数据;</p></li><li><p>每次仅允许一个进程在管程内执行某个内部过程。</p></li></ul><p>参考文献:现代操作系统</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><nav class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a> <a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a></nav></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">enpsl</p><div class="site-description" itemprop="description">my blog</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">37</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">7</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2023</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">enpsl</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动</div></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script></body></html>