<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"enpsl.github.io",root:"/",scheme:"Muse",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="my blog"><meta property="og:type" content="website"><meta property="og:title" content="彭诗亮的博客"><meta property="og:url" content="https://enpsl.github.io/page/3/index.html"><meta property="og:site_name" content="彭诗亮的博客"><meta property="og:description" content="my blog"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="enpsl"><meta property="article:tag" content="彭诗亮 psl pengshiliang blog"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://enpsl.github.io/page/3/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!0,isPost:!1,lang:"zh-CN"}</script><title>彭诗亮的博客</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">彭诗亮的博客</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档</a></li></ul></nav></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content index posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2021/07/01/2021-07-01-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2021/07/01/2021-07-01-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" class="post-title-link" itemprop="url">系统调用</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-07-01 19:30:00" itemprop="dateCreated datePublished" datetime="2021-07-01T19:30:00+08:00">2021-07-01</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><h3 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h3><p><strong>用户态</strong>和<strong>内核态</strong>是操作系统的两种运行状态，操作系统主要是为了对访问能力进行限制，用户态的权限较低，而内核态的权限较高</p><ul><li>用户态：用户态运行的程序只能受限地访问内存，只能直接读取用户程序的数据，并且不允许访问外围设备，用户态下的 CPU 不允许独占，也就是说 CPU 能够被其他程序获取。</li><li>内核态：内核态运行的程序可以访问计算机的任何数据和资源，不受限制，包括外围设备，比如网卡、硬盘等。处于内核态的 CPU 可以从一个程序切换到另外一个程序，并且占用 CPU 不会发生抢占情况。</li></ul><h3 id="系统调用流程"><a href="#系统调用流程" class="headerlink" title="系统调用流程"></a>系统调用流程</h3><p>当应用程序调用系统服务时、如读取文件内容，会发生如下调用过程</p><ul><li>调用程序首先把参数压入堆栈</li><li>把<code>read</code>代码通过汇编插入到寄存器，然后将操作系统控制由用户空间切换到内核空间</li><li>分派正确的系统调用处理器，之后执行<code>read</code>系统调用，执行完成后将操作系统控制转交给用户空间</li><li>切换到用户空间，记录栈帧，最后应用程序清楚堆栈信息</li></ul><p><img src="/../img/in-post/2021-07-01/img.png" alt="img.png"></p><blockquote><p>步骤3中，系统调用可能会阻塞调用者，比如试图读取键盘输入信息，如果没有键入，就会发生阻塞，稍后、当需要的键入输入时，操作系统会通知进程，之后会继续执行后面的流程</p></blockquote><p>参考文献:现代操作系统</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2021/06/02/2021-06-01-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2021/06/02/2021-06-01-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">进程与线程</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-06-02 19:30:00" itemprop="dateCreated datePublished" datetime="2021-06-02T19:30:00+08:00">2021-06-02</time></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><p>进程为操作系统提供了伪(并行)的能力，线程提高了操作系统伪(并行)的能力，没有进程和线程，现代计算是不复存在的<br>以下内容均为<code>UNIX</code>操作系统中描述</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>在进程模型中，所有在计算机上可运行的软件，包括操作系统，被组织成若干<strong>顺序进程</strong>，简称<strong>进程</strong></p><h3 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h3><p>一个进程包含程序计数器、寄存器和变量当前的值，从概念上来讲，每个进程拥有自己的cpu，实际上是cpu在进程间不断的切换导致的错觉，这种快速切换称为<strong>多道程序设计</strong><br>对于用户进程，其既有用户地址空间中的栈，也有它自己的内核栈。而内核进程就只有内核栈。</p><table><thead><tr><th>每个进程的内容</th></tr></thead><tbody><tr><td>地址空间</td></tr><tr><td>全局变量</td></tr><tr><td>打开文件</td></tr><tr><td>子进程</td></tr><tr><td>定时器</td></tr><tr><td>信号和信号处理程序</td></tr><tr><td>账户信息</td></tr></tbody></table><h4 id="多道程序设计模型"><a href="#多道程序设计模型" class="headerlink" title="多道程序设计模型"></a>多道程序设计模型</h4><p>采用多道程序设计可提高cpu的利用率</p><p>cpu利用率计算公式:<code>1-p^n</code></p><p>p表示进程等待时间和运行时间的之比,n表示多道程序设计的道数<br>例如：一个8g内存的操作系统，操作系统占了2G,每个应用程序占了2G,假如每个应用程序80%的时间都处于IO等待，那么cpu利用率等于<code>1-0.8^3</code>约为49%<br>这时候，增加8g内存，运行程序数量，可从3道程序设计提高到7道，cpu利用率为1-0.8^7,cpu利用率提升到79%</p><p>如果在增加8g内存，cpu利用率只能由79%提升到91%，显然不如之前的第一种投资好</p><h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><p>进程创建主要通过系统调用<code>fork</code>函数来实现的，调用后会创建后会创建一个与调用进程相同的副本，称之为<strong>子进程</strong>，这两个进程拥有相同的内存镜像，他们拥有各自不同的地址空间，其中不可写的内存区域是可共享的。可写的内存区是不共享的，通过<strong>写时复制</strong>共享</p><h3 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h3><p>进程终止由以下几个条件引起</p><ul><li>正常退出（自愿）</li><li>出错退出（自愿）</li><li>严重错误退出（非自愿）</li><li>被其他进程杀死退出（非自愿）</li></ul><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><ul><li>运行态</li><li>就绪态</li><li>阻塞态</li></ul><p>前两种状态是类似的，区别是第二种状态没有分配cpu资源，第三种状态与前两种不同，处于该状态进程不能运行，即使cpu是空闲的</p><h3 id="进程实现"><a href="#进程实现" class="headerlink" title="进程实现"></a>进程实现</h3><p>操作系统维护一个表格（结构数组或链表）即进程表，该表包含了进程状态的重要信息，包括程序各种状态转换时必须保存的信息，从而保证进程再次启动时，像从未中断过一样</p><table><thead><tr><th>进程管理</th><th>存储管理</th><th>文件管理</th></tr></thead><tbody><tr><td>寄存器</td><td>正文段指针</td><td>根目录</td></tr><tr><td>程序计数器</td><td>数据段指针</td><td>工作目录</td></tr><tr><td>程序状态字</td><td>堆栈段指针</td><td>文件描述符</td></tr><tr><td>堆栈指针</td><td></td><td>用户id</td></tr><tr><td>进程状态</td><td></td><td>组id</td></tr><tr><td>优先级</td><td></td><td></td></tr><tr><td>调度参数</td><td></td><td></td></tr><tr><td>进程id</td><td></td><td></td></tr><tr><td>父进程</td><td></td><td></td></tr><tr><td>进程组</td><td></td><td></td></tr><tr><td>信号</td><td></td><td></td></tr><tr><td>进程开始时间</td><td></td><td></td></tr><tr><td>使用cpu的时间</td><td></td><td></td></tr><tr><td>子进程cpu时间</td><td></td><td></td></tr><tr><td>下次定时器时间</td><td></td><td></td></tr></tbody></table><h3 id="进程分类"><a href="#进程分类" class="headerlink" title="进程分类"></a>进程分类</h3><ul><li><strong>系统进程</strong>：可以执行内存资源分配和进程切换等管理工作；而且，该进程的运行不受用户的干预，即使是root用户也不能干预系统进程的运行。</li><li><strong>用户进程</strong>：通过执行用户程序、应用程序或内核之外的系统程序而产生的进程，此类进程可以在用户的控制下运行或关闭。</li><li><strong>针对用户进程</strong>:又可以分为交互进程、批处理进程和守护进程三类。</li><li><strong>交互进程</strong>：由一个shell终端启动的进程，在执行过程中，需要与用户进行交互操作，可以运行于前台，也可以运行在后台。</li><li><strong>批处理进程</strong>：该进程是一个进程集合，负责按顺序启动其他的进程。</li><li><strong>守护进程</strong>:守护进程是一直运行的一种进程，经常在linux系统启动时启动，在系统关闭时终止。它们独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。例如httpd进程，一直处于运行状态，等待用户的访问。还有经常用的crond进程，这个进程类似与windows的计划任务，可以周期性的执行用户设定的某些任务</li></ul><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是cpu执行的最小单元，比进程更轻量级，更容易创建或撤销</p><h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><p>线程也包含程序计数器、寄存器和自己的堆栈</p><p>进程中的不同线程不像不同进程那样存在很大的独立性，所有的线程都有完全一样的地址空间，这意味着它们可以共享全局变量</p><table><thead><tr><th>每个线程的内容</th></tr></thead><tbody><tr><td>程序计数器</td></tr><tr><td>寄存器</td></tr><tr><td>堆栈</td></tr><tr><td>状态</td></tr></tbody></table><p>每个线程拥有自己的堆栈，原因是：<br>线程调用时需要使用栈帧存放局部变量和调用后返回的地址，而每个线程调用的过程是不同，要单独维护一套自己的执行历史</p><h3 id="线程的使用"><a href="#线程的使用" class="headerlink" title="线程的使用"></a>线程的使用</h3><p>需要多线程的原因有两个，</p><ul><li>并行实体拥有同一个地址空间和所有可用数据的能力</li><li>线程比进程更轻量级，创建一个线程比进程快10-100倍，当有大量线程需要动态和快速修改时，这一特性很有必要</li></ul><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>同进程一样，线程也可以处于运行、阻塞、就绪或终止状态</p><h3 id="线程实现方式"><a href="#线程实现方式" class="headerlink" title="线程实现方式"></a>线程实现方式</h3><h4 id="在用户空间实现"><a href="#在用户空间实现" class="headerlink" title="在用户空间实现"></a>在用户空间实现</h4><p>整个线程包处于用户空间，从内核角度考虑，就是按正常单进程单线程方式管理，这种方式好处是有些操作系统内核不支持多线程，也可以一样使用多线程模型</p><p>用户空间线程除了这点好处，还有以下几点优势：</p><ul><li>线程的状态和调度保存是本地过程，不需要内核来参与，也避免了上下问切换，cpu内存高速缓存刷新，调度敏捷</li><li>允许每个进程有自己的调度算法，例如，在某些应用程序中有垃圾回收线程，应用程序不需要担心线程会在不合适的时刻停止</li><li>拥有很好的扩展性，内核线程在内核空间需要固定的表格空间和堆栈空间，如果内核线程数量非常大，会出现问题</li></ul><p>当然，它也有一些不可避免的缺点：</p><ul><li>用户空间线程去做系统级调用是不可接受的，会停止所有的线程，而实现线程的目标是要允许每个线程使用阻塞调用，不会影响其他线程，相违背</li><li>该线程运行时，进程内其他线程不能运行，除非该线程放弃cpu</li></ul><h4 id="在内核实现"><a href="#在内核实现" class="headerlink" title="在内核实现"></a>在内核实现</h4><p>内核线程在操作系统内核中保存了每个线程的寄存器、状态、和其他信息，跟用户空间线程是一样的，区别是保存在了内核中</p><p>内核线程的管理工作由操作系统内核完成，这种实现的好处是当一个线程阻塞时，内核根据选择，可以切换到进程内另一个线程<br>如果当某个线程引发了页面故障，内核可以很方便的检测是否有其他可用的线程，让其执行</p><p>虽然内核解决了线程很多问题，但也不会解决所有问题，比如当一个新进程创建，是将进程里的所有线程都复制，还是只有一个线程？<br>还有一个问题是当过来一个信号，可以交给需要的线程执行，当时多个线程都注册了该信号，会发生什么？</p><h4 id="混合实现"><a href="#混合实现" class="headerlink" title="混合实现"></a>混合实现</h4><p>混合实现主要分为用户线程和内核线程多对1、1对1、和多对多模式，其中多对1模式就是前面介绍的在用户空间实现的线程模型，线程中使用阻塞时会阻塞其他线程<br><img src="/img/in-post/2021-06-02/img.png" alt="img.png"><br>混合模式解决了多对多和1对1模型解决了线程没办法使用阻塞问题，但是1对1模型会占用多个内核线程，对操作系统内核切换影响比较大，第三种多对多模型是并发效果最好的</p><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>进程通常需要与其他进程通信，以达到信息传递并能保证进程按照正确顺序执行</p><h4 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h4><p>多个进程读写某个共享数据，而最后的结果取决于进程运行的精准时序，称为竞争条件</p><h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><p>怎样避免竞争条件？主要目标是组织多个进程同时读取共享数据，即互斥<br>抽象描述就是，我们把共享内存进行访问的程序片段叫做<strong>临界资源</strong>或者<strong>临界区</strong>,我们只要保证两个进程不同时在临界区，就能避免竞争</p><p>尽管避免竞争条件，我们还是不能保证数据共享的并发进程能高效的执行：对于一个好的解决方案，需要满足以下条件</p><ul><li>任何两个进程不能同时处于临界区</li><li>不应对cpu的数量和速度做任何假设</li><li>临界区外的运行进程不得阻塞其他进程</li><li>不得使进程无限期等待进入临界区</li></ul><p><img src="/img/in-post/2021-06-02/img_1.png" alt="img_1.png"><br>对于理想的方案应该是如上图这样的，某一时刻对与临界区的访问只能有一个进程</p><h4 id="互斥方案"><a href="#互斥方案" class="headerlink" title="互斥方案"></a>互斥方案</h4><h5 id="屏蔽中断"><a href="#屏蔽中断" class="headerlink" title="屏蔽中断"></a>屏蔽中断</h5><p>最简单的实现方案，当进程进入临界区时，立即屏蔽所有中断，在离开之前打开中断，屏蔽中断后，cpu时钟中断也会屏蔽，cpu只有在发生时钟中断或其他中断时才会切换进程，这样，屏蔽中断后cpu不会切换进程，不必担心其他进程的介入</p><p>这个方案并不好，对于单核cpu，执行屏蔽中断如果不在打开，系统会因此而终止，对于多核cpu，仅对执行disable的那个cpu优先，其他cpu仍继续执行</p><h5 id="锁变量"><a href="#锁变量" class="headerlink" title="锁变量"></a>锁变量</h5><p>实现方案为设计一个锁变量，其值为0，如果有其他程序进入到临界区，会将值赋值为1，这样，其他进程读到1就不会在访问临界区了</p><p>这种方案也会出现疏忽，即两个进程同时进入临界区时，读到的临界变量都是0，执行了两次赋值1的操作，但还是发生了资源竞争</p><h5 id="严格轮换法"><a href="#严格轮换法" class="headerlink" title="严格轮换法"></a>严格轮换法</h5><p>进程a:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span>(turn != <span class="number">0</span>) &#123;&#125;</span><br><span class="line">    processstart()</span><br><span class="line">    turn = <span class="number">1</span></span><br><span class="line">    processend()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进程b:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span>(turn != <span class="number">1</span>) &#123;&#125;</span><br><span class="line">    processstart()</span><br><span class="line">    turn = <span class="number">0</span></span><br><span class="line">    processend()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始，进程a和b拿到的trun都是0，这时，只有进程a能进入并修改turn为1，这时进程b由于turn一直为0，会不断等待，直到turn变成1，这种忙等待行为被称为<strong>自旋锁</strong></p><p>这种方式如果两个进程的执行速度会相差很多，轮流进入时会有一方等待很长时间，显然是不合适的</p><h5 id="Person解法"><a href="#Person解法" class="headerlink" title="Person解法"></a>Person解法</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE  1</span></span><br><span class="line"><span class="comment">/* 进程数量 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N     2													</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 现在轮到谁 */</span></span><br><span class="line"><span class="type">int</span> turn;					</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 所有值初始化为 0 (FALSE) */</span></span><br><span class="line"><span class="type">int</span> interested[N];											</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 进程是 0 或 1 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enter_region</span><span class="params">(<span class="type">int</span> process)</span>&#123;					</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 另一个进程号 */</span></span><br><span class="line">  <span class="type">int</span> other;														</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 另一个进程 */</span></span><br><span class="line">  other = <span class="number">1</span> - process;				</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 表示愿意进入临界区 */</span></span><br><span class="line">  interested[process] = TRUE;						</span><br><span class="line">  turn = process;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 空循环 */</span></span><br><span class="line">  <span class="keyword">while</span>(turn == process </span><br><span class="line">        &amp;&amp; interested[other] == <span class="literal">true</span>)&#123;&#125; </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leave_region</span><span class="params">(<span class="type">int</span> process)</span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 表示离开临界区 */</span></span><br><span class="line">  interested[process] == FALSE;				 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用共享变量时（即进入其临界区）之前，各个进程使用各自的进程号 0 或 1 作为参数来调用 enter_region，这个函数调用在需要时将使进程等待，直到能够安全的临界区。在完成对共享变量的操作之后，进程将调用 leave_region 表示操作完成，并且允许其他进程进入。</p><p>现在来看看这个办法是如何工作的。一开始，没有任何进程处于临界区中，现在进程 0 调用 enter_region。它通过设置数组元素和将 turn 置为 0 来表示它希望进入临界区。由于进程 1 并不想进入临界区，所以 enter_region 很快便返回。如果进程现在调用 enter_region，进程 1 将在此处挂起直到 interested[0] 变为 FALSE，这种情况只有在进程 0 调用 leave_region 退出临界区时才会发生。</p><p>那么上面讨论的是顺序进入的情况，现在来考虑一种两个进程同时调用 enter_region 的情况。它们都将自己的进程存入 turn，但只有最后保存进去的进程号才有效，前一个进程的进程号因为重写而丢失。假如进程 1 是最后存入的，则 turn 为 1 。当两个进程都运行到 while 的时候，进程 0 将不会循环并进入临界区，而进程 1 将会无限循环且不会进入临界区，直到进程 0 退出位置。</p><h5 id="TSL指令"><a href="#TSL指令" class="headerlink" title="TSL指令"></a>TSL指令</h5><p>TSL指令是一个需要硬件支持的方案。TSL称为测试并加锁（test and set lock）。他将一个内存字LOCK读到寄存器RX中。然后在该内存地址上存一个非零值。读字和写字操作是不可分割的，即该指令结束前其他处理器均不允许访问该内存字。执行TSL指令的CPU将锁住内存中线，以禁止其他CPU在本指令结束前访问内存。TSL指令解决了忙等待的屏蔽中断方案中无法屏蔽多处理器访问共享内存的问题。 因为锁住内存总线不同于屏蔽中断，锁住内存总线后，所有处理器都无法通过内存总线访问内存字。 那些多处理器的计算机都有TSL指令。如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TSL RX, LOCK</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enter_region:</span><br><span class="line">    TSL REGISTER, LOCK</span><br><span class="line">    CMP REGISTER, #0</span><br><span class="line">    JNE enter_region       ; 如果不空闲(=0)，那么反复执行，处于忙等待状态</span><br><span class="line">    RET</span><br><span class="line"></span><br><span class="line">leave_region:</span><br><span class="line">    MOVE LOCK, #0</span><br><span class="line">    RET</span><br></pre></td></tr></table></figure><p>具体工作过程：第一条指令将lock原来的值复制到寄存器中并将lock设置为1，随后这个原来的值与0相比较。如果原来的值非零，则说明以前已被加锁，则程序将回到开始并再次测试。经过一段时间后，lock值变为0，于是过程返回，此时已加锁。要清除这个锁比较简单，程序只需将0存入lock即可，不需要特殊的同步指令。</p><p>一个可替代TSL的指令是XCHG，它原子性地交换两个位置的内容，例如，一个寄存器与一个存储字。它本质上与TSL的解决办法一样。所有的Intel x86 CPU在底层同步中使用XCHG指令。</p><h5 id="睡眠与唤醒"><a href="#睡眠与唤醒" class="headerlink" title="睡眠与唤醒"></a>睡眠与唤醒</h5><p>上述基于忙等待的互斥，不仅会浪费CPU时间，而且还可能引起预想不到的结果。例如，有两个进程L和H，L的优先级较低、H的优先级较高。调度规则规定，只要H处于就绪态它就会运行。在某一时刻，L处于临界区中，此时H变到就绪态，准备运行。现在H开始忙等待，待由于H就绪时，L就不会被调度，也就无法离开临界区，所以H将永远忙等待下去。这种情况有时被称作优先级反转问题。</p><p>最简单的进程间通信原语，它们在无法进入临界区时将阻塞，而不是忙等待。两条最简单的通信原语是：sleep和wakeup。sleep是一个将引起调用进程阻塞的系统调用，即被挂起，直到另外一个进程将其唤醒。wakeup调用有一个参数，即要被唤醒的进程。</p><h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><p>基于支持P、V操作的非负整数实现。</p><p>信号量的用处一：生产者-消费者问题</p><p>在使用信号量的系统中，隐藏中断的最自然的方法就是为每一个I&#x2F;O设备设置一个信号量，其初始值为0。在启动一个I&#x2F;O设备之后，管理进程就立即对相关联的信号量执行一个Down操作，于是进程立即被阻塞。当终端到来时，终端处理程序随即对相关信号量执行一个Up操作，从而将相关的进程设置为就绪状态。</p><p>为了解决生产者-消费者问题，可以使用三个信号量：full， 用于记录充满的缓冲槽数据；empty，用于记录空的缓冲槽总数；mutex，用来确保生产者和消费者不会同时访问缓冲区。</p><p>信号量的用处二：用于实现同步(Synchronization)</p><p>信号量full和empty用来保证某种时间的顺序发生或不发生。例如，当缓冲区满的时候生产者停止运行，而空的时候消费者停止运行。</p><h5 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h5><p>互斥量是一个可以处于两态之一的变量：加锁、解锁。相比于信号量，它没有计数功能。</p><p>由于互斥量非常简单，所以如果有TSL或XCHG指令，就可以很容易地在用户空间中实现它们。由于用户级线程包的mutex_lock和mutex_unlock代码下(0表示解锁)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mutex_lock:</span><br><span class="line">    TSL REGISTER, MUTEX</span><br><span class="line">    CMP REGISTER, #<span class="number">0</span></span><br><span class="line">    JZE ok                   ; 如果互斥锁空闲，那么就直接返回继续运行</span><br><span class="line">    CALL thread_yield        ; 如果互斥锁忙，那么就调用其它进程，这是与忙等待的区别</span><br><span class="line">    JMP mutex_lock           ; 稍后再试，也就是本代码段的开头</span><br><span class="line">ok: RET</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mutex_unlock:</span><br><span class="line">    MOVE MUTEX, #<span class="number">0</span></span><br><span class="line">    RET</span><br></pre></td></tr></table></figure><p>mutex_lock的代码与enter_region的代码很相似，但有一个关键的区别。当enter_region进入临界区失败后，它始终重复测试锁(忙等待)。实际上，由于时钟超时的作用，会调度其它进程运行，这样迟早拥有锁的进程会进入运行并释放锁。</p><p>在用户线程中，情形有所不同，因为没有时钟停止运行时间长度的线程。结果就是通过忙等待的方式来试图获取锁的线程将永远循环下去，绝不会得到锁，因为这个运行的线程不会让其它线程运行从而释放锁。</p><p>这就是enter_region与mutex_lock的区别</p><h5 id="Pthread中的互斥锁"><a href="#Pthread中的互斥锁" class="headerlink" title="Pthread中的互斥锁"></a>Pthread中的互斥锁</h5><p>pthread中提供了基于互斥锁的同步机制。提供的函数如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_init();      // 创建互斥锁</span><br><span class="line">pthread_mutex_destroy();   // 销毁互斥锁</span><br><span class="line">pthread_mutex_lock();      // 上锁</span><br><span class="line">pthread_mutex_trylock();   // 尝试上锁，若上锁不成功，会返回错误代码而不是阻塞调用者</span><br><span class="line">pthread_mutex_unlock();    // 对互斥锁解锁</span><br></pre></td></tr></table></figure><p>pthread中处理提供了互斥锁，还提供了条件变量用于实现同步。互斥量在允许或阻塞对临界区的访问上是很有用的，条件变量则允许线程由于一些未达到的条件而阻塞。绝大多数情况下，这两种方法是一起使用的。下面就是线程、互斥量、条件变量之间的关联。</p><h4 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h4><h5 id="为什么引入管程"><a href="#为什么引入管程" class="headerlink" title="为什么引入管程"></a>为什么引入管程</h5><p>信号量机制存在的问题：编写程序困难、易出错</p><p>能不能设计一种机制，让程序员写程序时不需要再关注复杂的PV操作，让写代码更轻松呢?</p><p>1973年，Brinch Hansen首次在程序设计语言(Pascal) 中引入了“管程”成分――一种高级同步机制</p><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>管程是一种特殊的软件模块，有这些部分组成:</p><ul><li><p>局部于管程的共享数据结构说明;</p></li><li><p>对该数据结构进行操作的一组过程;</p></li><li><p>对局部于管程的共享数据设置初始值的语句;</p></li><li><p>管程有一个名字。</p></li></ul><h5 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h5><p>管程的基本特征:</p><ul><li><p>局部于管程的数据只能被局部于管程的过程所访问;</p></li><li><p>一个进程只有通过调用管程内的过程（函数）才能进入管程访问共享数据;</p></li><li><p>每次仅允许一个进程在管程内执行某个内部过程。</p></li></ul><p>参考文献:现代操作系统</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2021/03/06/2021-03-06-docker-swarm/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2021/03/06/2021-03-06-docker-swarm/" class="post-title-link" itemprop="url">Docker Swarm</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-03-06 13:30:00" itemprop="dateCreated datePublished" datetime="2021-03-06T13:30:00+08:00">2021-03-06</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p><img src="/img/in-post/2019-03-06/5.png" alt="avatar"></p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>主节点：192.168.205.10<br>从节点1：192.168.205.11<br>从节点2：192.168.205.12</p><p><img src="/img/in-post/2019-03-06/1.png" alt="avatar"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm init --advertise-addr 192.168.205.10</span><br></pre></td></tr></table></figure><p>复制提示的命令到其它两个容器中执行</p><p><img src="/img/in-post/2019-03-06/2.png" alt="avatar"><br><img src="/img/in-post/2019-03-06/3.png" alt="avatar"></p><p>查看node信息</p><p><img src="/img/in-post/2019-03-06/4.png" alt="avatar"></p><h2 id="service-创建和水平扩展"><a href="#service-创建和水平扩展" class="headerlink" title="service 创建和水平扩展"></a>service 创建和水平扩展</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">docker service COMMAND</span><br><span class="line"></span><br><span class="line">Manage services</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  create      Create a new service</span><br><span class="line">  inspect     Display detailed information on one or more services</span><br><span class="line">  logs        Fetch the logs of a service or task</span><br><span class="line">  <span class="built_in">ls</span>          List services</span><br><span class="line">  ps          List the tasks of one or more services</span><br><span class="line">  <span class="built_in">rm</span>          Remove one or more services</span><br><span class="line">  rollback    Revert changes to a service<span class="string">&#x27;s configuration</span></span><br><span class="line"><span class="string">  scale       Scale one or multiple replicated services</span></span><br><span class="line"><span class="string">  update      Update a service</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Run &#x27;</span>docker service COMMAND --<span class="built_in">help</span><span class="string">&#x27; for more information on a command</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service create --name demo busybox /bin/sh -c <span class="string">&quot;while true; do sleep 3600; done&quot;</span></span><br></pre></td></tr></table></figure><p>查看容器详细信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker service <span class="built_in">ls</span>       </span><br><span class="line">docker service ps demo  //查看service存放在哪台机器</span><br><span class="line">docker ps   //查看当前机器下的service</span><br></pre></td></tr></table></figure><p><img src="/img/in-post/2019-03-06/Snip20190306_6.png" alt="avatar"></p><p>replicated表明可以横向扩展</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service scale demo=5</span><br></pre></td></tr></table></figure><p><img src="/img/in-post/2019-03-06/Snip20190306_7.png" alt="avatar"></p><p>5&#x2F;5表示5个都已经ready&#x2F;共5个scale</p><p>swarm 分布情况<br><img src="/img/in-post/2019-03-06/Snip20190306_1.png" alt="avatar"><br><img src="/img/in-post/2019-03-06/Snip20190306_2.png" alt="avatar"></p><p>删除swarm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service <span class="built_in">rm</span> demo</span><br></pre></td></tr></table></figure><h2 id="在docker-swarm下部署wordpress"><a href="#在docker-swarm下部署wordpress" class="headerlink" title="在docker swarm下部署wordpress"></a>在docker swarm下部署wordpress</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//创建overlay网络</span><br><span class="line">[vagrant@swarm-manager ~]$ docker network create -d overlay demo</span><br><span class="line">lqem7ybsxvsqupsamhs7gwuym</span><br><span class="line">[vagrant@swarm-manager ~]$ docker network <span class="built_in">ls</span></span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">81117831f35e        bridge              bridge              <span class="built_in">local</span></span><br><span class="line">lqem7ybsxvsq        demo                overlay             swarm</span><br><span class="line">f5cf7cd988bf        docker_gwbridge     bridge              <span class="built_in">local</span></span><br><span class="line">6fca47e6833e        host                host                <span class="built_in">local</span></span><br><span class="line">qn8r5p813ae9        ingress             overlay             swarm</span><br><span class="line">5d8be2887f8b        none                null                <span class="built_in">local</span></span><br></pre></td></tr></table></figure><p>创建mysql service</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service create --name mysql --<span class="built_in">env</span> MYSQL_ROOT_PASSWORD=root --<span class="built_in">env</span> MYSQL_DATABASE=wordpress --network demo --mount <span class="built_in">type</span>=volume,<span class="built_in">source</span>=mysql-data,destination=/var/lib/mysql mysql:5.7</span><br></pre></td></tr></table></figure><p>创建wordpress service</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service create --name wordpress -p 80:80 --<span class="built_in">env</span> WORDPRESS_DB_PASSWORD=root --<span class="built_in">env</span> WORDPRESS_DB_HOST=mysql --network demo wordpress</span><br></pre></td></tr></table></figure><p>部署成功<br><img src="/img/in-post/2019-03-06/Snip20190307_2.png" alt="avatar"></p><p>此时访问集群中任意一台机器的ip都可以访问到wordpress，实际上,docker在swarm中建立了一个虚拟ip来实现通信，关于通信方式可参考<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/bfb2c125d2bf">routingmesh</a></p><h2 id="Routing-Mesh的两种体现"><a href="#Routing-Mesh的两种体现" class="headerlink" title="Routing Mesh的两种体现"></a>Routing Mesh的两种体现</h2><ol><li>internal:Container与Container之间访问通过overlay网络(虚拟ip)</li><li>ingress: 如果服务有绑定接口，此服务可通过swarm中任意节点访问</li></ol><h2 id="ingress-负载均衡"><a href="#ingress-负载均衡" class="headerlink" title="ingress 负载均衡"></a>ingress 负载均衡</h2><p>作用：</p><ol><li>外部访问的负载均衡</li><li>服务端口被暴漏给各个swarm节点</li><li>内部通过ipvs进行负载均衡</li></ol><h2 id="docker-stack"><a href="#docker-stack" class="headerlink" title="docker stack"></a>docker stack</h2><h3 id="docker-compose-语法梳理"><a href="#docker-compose-语法梳理" class="headerlink" title="docker-compose 语法梳理"></a>docker-compose 语法梳理</h3><h4 id="ENDPOINT-MODE"><a href="#ENDPOINT-MODE" class="headerlink" title="ENDPOINT_MODE"></a>ENDPOINT_MODE</h4><p>ENDPOINT_MODE: vip | dnsrr</p><p>vip 通过lvs负载均衡虚拟ip的方式（默认推荐使用）<br>dnsrr：dns负载均衡轮询策略</p><h4 id="LABELS"><a href="#LABELS" class="headerlink" title="LABELS"></a>LABELS</h4><p>lables是起到帮助信息的作用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&quot;3&quot;</span></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    image: web</span><br><span class="line">    deploy:</span><br><span class="line">      labels:</span><br><span class="line">        com.example.description: <span class="string">&quot;This label will appear on the web service&quot;</span></span><br></pre></td></tr></table></figure><h4 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h4><p>mode: global | replicated(默认)</p><p>replicated可以做横向扩展，global不可以</p><h4 id="PLACEMENT"><a href="#PLACEMENT" class="headerlink" title="PLACEMENT"></a>PLACEMENT</h4><p>node.role &#x3D;&#x3D; manager 指定部署在swarm manager节点上<br>constraints 一些限制条件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3.3&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints:</span><br><span class="line">          - node.role == manager            </span><br><span class="line">          - engine.labels.operatingsystem == ubuntu 14.04</span><br><span class="line">        preferences:</span><br><span class="line">          - spread: node.labels.zone</span><br></pre></td></tr></table></figure><h4 id="REPLICAS"><a href="#REPLICAS" class="headerlink" title="REPLICAS"></a>REPLICAS</h4><p>在mode：replicated下有效<br>replicas: 6 部署6个service</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  worker:</span><br><span class="line">    image: dockersamples/examplevotingapp_worker</span><br><span class="line">    networks:</span><br><span class="line">      - frontend</span><br><span class="line">      - backend</span><br><span class="line">    deploy:</span><br><span class="line">      mode: replicated</span><br><span class="line">      replicas: 6</span><br></pre></td></tr></table></figure><h4 id="RESOURCES"><a href="#RESOURCES" class="headerlink" title="RESOURCES"></a>RESOURCES</h4><p>(cpu_shares, cpu_quota, cpuset, mem_limit, memswap_limit, mem_swappiness)的一些资源设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  redis:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    deploy:</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: <span class="string">&#x27;0.50&#x27;</span></span><br><span class="line">          memory: 50M</span><br><span class="line">        reservations:</span><br><span class="line">          cpus: <span class="string">&#x27;0.25&#x27;</span></span><br><span class="line">          memory: 20M</span><br></pre></td></tr></table></figure><p>表示redis服务被限制使用不超过50M的内存和0.50(50%)的可用处理时间(CPU)，并保留20M的内存和0.25 CPU时间(始终可用)</p><h4 id="RESTART-POLICY"><a href="#RESTART-POLICY" class="headerlink" title="RESTART_POLICY"></a>RESTART_POLICY</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&quot;3&quot;</span></span><br><span class="line">services:</span><br><span class="line">  redis:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    deploy:</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">        delay: 5s</span><br><span class="line">        max_attempts: 3</span><br><span class="line">        window: 120s</span><br></pre></td></tr></table></figure><p>表示服务停止时最大尝试次数为3,重启时间间隔是5秒，重启是否成功之前需要等待120s时间</p><h4 id="ROLLBACK-CONFIG"><a href="#ROLLBACK-CONFIG" class="headerlink" title="ROLLBACK_CONFIG"></a>ROLLBACK_CONFIG</h4><p>parallelism：最多可以同时update2个replicas，每次只能更新一个<br>delay：每次更新之间的间隔时间，<br>order: 更新期间的操作顺序。stop-first(旧任务在启动新任务之前停止)或start-first(新任务首先启动，正在运行的任务短暂搁置)(默认stop-first)注意:只支持v3.4或更高版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3.4&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  vote:</span><br><span class="line">    image: dockersamples/examplevotingapp_vote:before</span><br><span class="line">    depends_on:</span><br><span class="line">      - redis</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 2</span><br><span class="line">      update_config:</span><br><span class="line">        parallelism: 2</span><br><span class="line">        delay: 10s</span><br><span class="line">        order: stop-first</span><br></pre></td></tr></table></figure><p>详情参考<a target="_blank" rel="noopener" href="https://docs.docker.com/compose/compose-file/">compose-file</a></p><h3 id="通过docker-stack-部署wordpress"><a href="#通过docker-stack-部署wordpress" class="headerlink" title="通过docker stack 部署wordpress"></a>通过docker stack 部署wordpress</h3><p>sudo mkdir -p &#x2F;usr&#x2F;docker-vol&#x2F;mysql&#x2F;data</p><p>vim docker-compose.yml</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  web:</span><br><span class="line">    image: wordpress</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:80</span><br><span class="line">    environment:</span><br><span class="line">      WORDPRESS_DB_HOST: mysql</span><br><span class="line">      WORDPRESS_DB_PASSWORD: root</span><br><span class="line">    networks:</span><br><span class="line">      - my-network</span><br><span class="line">    depends_on:</span><br><span class="line">      - mysql</span><br><span class="line">    deploy:</span><br><span class="line">      mode: replicated</span><br><span class="line">      replicas: 3</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">        delay: 5s</span><br><span class="line">        max_attempts: 3</span><br><span class="line">      update_config:</span><br><span class="line">        parallelism: 1</span><br><span class="line">        delay: 10s</span><br><span class="line"></span><br><span class="line">  mysql:</span><br><span class="line">    image: mysql:5.7</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_ROOT_PASSWORD: root</span><br><span class="line">      MYSQL_DATABASE: wordpress</span><br><span class="line">    volumes:</span><br><span class="line">      - /usr/docker-vol/mysql/data:/var/lib/mysql</span><br><span class="line">    networks:</span><br><span class="line">      - my-network</span><br><span class="line">    deploy:</span><br><span class="line">      mode: global</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: <span class="string">&quot;0.2&quot;</span></span><br><span class="line">          memory: 512M</span><br><span class="line">      placement:</span><br><span class="line">        constraints:</span><br><span class="line">          - node.role == manager</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  mysql-data:</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  my-network:</span><br><span class="line">    driver: overlay</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack deploy wordpress --compose-file=docker-compose.yml</span><br></pre></td></tr></table></figure><p>docker stack services wordpress 查看service准备情况</p><p>docker stack ls 列举stack</p><p>docker stack ps wordpress 查看wordpress运行情况</p><p><img src="/img/in-post/2019-03-08/Snip20190308_5.png" alt="avatar"></p><p>看到如下界面配置成功</p><p><img src="/img/in-post/2019-03-08/Snip20190308_6.png" alt="avatar"></p><p>清空环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack <span class="built_in">rm</span> wordpress</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2021/03/04/2021-03-04-docker-volume/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2021/03/04/2021-03-04-docker-volume/" class="post-title-link" itemprop="url">Docker Volume</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-03-04 13:30:00" itemprop="dateCreated datePublished" datetime="2021-03-04T13:30:00+08:00">2021-03-04</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker volume <span class="built_in">ls</span>                // 列出所有volume</span><br><span class="line">docker volume <span class="built_in">rm</span> &lt;VOLUME...&gt;    // 删除一个或多个volume</span><br><span class="line">docker volume <span class="built_in">rm</span> $(docker volume <span class="built_in">ls</span> -qf dangling=<span class="literal">true</span>) //删除失效的volume:</span><br></pre></td></tr></table></figure><h2 id="Data-Volume"><a href="#Data-Volume" class="headerlink" title="Data Volume"></a>Data Volume</h2><p>volume是docker数据持久化的一种方式，那么怎样使用volume呢？</p><h3 id="Dockerfile使用"><a href="#Dockerfile使用" class="headerlink" title="Dockerfile使用"></a>Dockerfile使用</h3><p><img src="/img/in-post/2019-03-04/2.png"></p><p>可以通过mysql官方的Dockerfile看到volume的使用方式</p><h3 id="命令模式使用"><a href="#命令模式使用" class="headerlink" title="命令模式使用"></a>命令模式使用</h3><p>启动一台mysql;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name mysql1 -e MYSQL_ALLOW_EMPTY_PASSWORD=<span class="literal">true</span> mysql</span><br></pre></td></tr></table></figure><p>查看volume:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pengshiliang@pengshiliang-virtual-machine:~$ docker volume <span class="built_in">ls</span></span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>               195d16514c70f7990f190b1557fb2131a2b8942c48ef50025b7f08fc7b082dcd</span><br><span class="line">pengshiliang@pengshiliang-virtual-machine:~$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                 NAMES</span><br><span class="line">20752e526d9e        mysql               <span class="string">&quot;docker-entrypoint.s…&quot;</span>   14 seconds ago      Up 13 seconds       3306/tcp, 33060/tcp   mysql1</span><br><span class="line">pengshiliang@pengshiliang-virtual-machine:~$ docker volume inspect 195d16514c70f7990f190b1557fb2131a2b8942c48ef50025b7f08fc7b082dcd</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2019-03-04T21:41:29+08:00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: null,</span><br><span class="line">        <span class="string">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/195d16514c70f7990f190b1557fb2131a2b8942c48ef50025b7f08fc7b082dcd/_data&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;195d16514c70f7990f190b1557fb2131a2b8942c48ef50025b7f08fc7b082dcd&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">pengshiliang@pengshiliang-virtual-machine:~$</span><br></pre></td></tr></table></figure><p>可以通过inspect命令查看volume的存储路径</p><p>删掉mysql container</p><p><img src="/img/in-post/2019-03-04/1.png"></p><p>发现volume仍然存在，也确认了docker可以通过volume持久化存储数据</p><p>还可以通过下面的实例来证实</p><p>为了避免环境影响,删掉刚才产生的volume，重新启动一台mysql</p><p><img src="/img/in-post/2019-03-04/3.png"></p><p>valume的名称太长了,加入一个-v参数，来给volume起个别名,然后启动mysql,并指定volume存放位置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -v mysql:/var/lib/mysql --name mysql1 -e MYSQL_ALLOW_EMPTY_PASSWORD=<span class="literal">true</span> mysql</span><br></pre></td></tr></table></figure><p><img src="/img/in-post/2019-03-04/4.png"></p><p>进入当前container，并创建一个数据库</p><p><img src="/img/in-post/2019-03-04/5.png"></p><p>然后退出，把当前的mysql1容器删掉</p><p><img src="/img/in-post/2019-03-04/6.png"></p><p>检查volume</p><p><img src="/img/in-post/2019-03-04/7.png"></p><p>再去启动一台mysql2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -v mysql:/var/lib/mysql --name mysql2 -e MYSQL_ALLOW_EMPTY_PASSWORD=<span class="literal">true</span> mysql</span><br></pre></td></tr></table></figure><p>进入到当前容器的mysql数据库查看详情</p><p><img src="/img/in-post/2019-03-04/8.png"></p><p>发现刚才创建的数据库还在,也证明了volume是持久化存储的方式</p><h2 id="bind-mouting"><a href="#bind-mouting" class="headerlink" title="bind mouting"></a>bind mouting</h2><p>命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -run -v /home/aaa:/root/aaa</span><br></pre></td></tr></table></figure><p>通过docker bind mouting将本地和服务器(容器)上的资源绑定，改变一方都对数据同步，从而达到直接修改本地资源，服务器上的资源自动更新</p><p>准备一个目录，创建index.html文件</p><p><img src="/img/in-post/2019-03-04/9.png"></p><p><img src="/img/in-post/2019-03-04/10.png"></p><p>可以发现，当前目录下的文件是和container内部的&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html文件是同步的</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2021/03/04/2021-03-05-docker-compose/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2021/03/04/2021-03-05-docker-compose/" class="post-title-link" itemprop="url">Docker Compose</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-03-04 13:30:00" itemprop="dateCreated datePublished" datetime="2021-03-04T13:30:00+08:00">2021-03-04</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L <span class="string">&quot;https://github.com/docker/compose/releases/download/1.23.2/docker-compose-<span class="subst">$(uname -s)</span>-<span class="subst">$(uname -m)</span>&quot;</span> -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d nginx                     构建建启动nignx容器</span><br><span class="line"></span><br><span class="line">docker-compose <span class="built_in">exec</span> nginx bash            登录到nginx容器中</span><br><span class="line"></span><br><span class="line">docker-compose down                              删除所有nginx容器,镜像</span><br><span class="line"></span><br><span class="line">docker-compose ps                                   显示所有容器</span><br><span class="line"></span><br><span class="line">docker-compose restart nginx                   重新启动nginx容器</span><br><span class="line"></span><br><span class="line">docker-compose run --no-deps --<span class="built_in">rm</span> php-fpm php -v  在php-fpm中不启动关联容器，并容器执行php -v 执行完成后删除容器</span><br><span class="line"></span><br><span class="line">docker-compose build nginx                     构建镜像 。        </span><br><span class="line"></span><br><span class="line">docker-compose build --no-cache nginx   不带缓存的构建。</span><br><span class="line"></span><br><span class="line">docker-compose logs  nginx                     查看nginx的日志 </span><br><span class="line"></span><br><span class="line">docker-compose logs -f nginx                   查看nginx的实时日志</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">docker-compose config  -q                        验证（docker-compose.yml）文件配置，当配置正确时，不输出任何内容，当文件配置错误，输出错误信息。 </span><br><span class="line"></span><br><span class="line">docker-compose events --json nginx       以json的形式输出nginx的docker日志</span><br><span class="line"></span><br><span class="line">docker-compose pause nginx                 暂停nignx容器</span><br><span class="line"></span><br><span class="line">docker-compose unpause nginx             恢复ningx容器</span><br><span class="line"></span><br><span class="line">docker-compose <span class="built_in">rm</span> nginx                       删除容器（删除前必须关闭容器）</span><br><span class="line"></span><br><span class="line">docker-compose stop nginx                    停止nignx容器</span><br><span class="line"></span><br><span class="line">docker-compose start nginx                    启动nignx容器</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2021/03/03/2021-03-03-docker_network/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2021/03/03/2021-03-03-docker_network/" class="post-title-link" itemprop="url">Docker network</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-03-03 13:30:00" itemprop="dateCreated datePublished" datetime="2021-03-03T13:30:00+08:00">2021-03-03</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h2><p>两台vagrant 创建的 docker 虚拟机，虚拟机配置信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">boxes = [</span><br><span class="line">    &#123;</span><br><span class="line">        :name =&gt; <span class="string">&quot;docker-node1&quot;</span>,</span><br><span class="line">        :eth1 =&gt; <span class="string">&quot;192.168.205.10&quot;</span>,</span><br><span class="line">        :mem =&gt; <span class="string">&quot;1024&quot;</span>,</span><br><span class="line">        :cpu =&gt; <span class="string">&quot;1&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        :name =&gt; <span class="string">&quot;docker-node2&quot;</span>,</span><br><span class="line">        :eth1 =&gt; <span class="string">&quot;192.168.205.11&quot;</span>,</span><br><span class="line">        :mem =&gt; <span class="string">&quot;1024&quot;</span>,</span><br><span class="line">        :cpu =&gt; <span class="string">&quot;1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>启动两个 docker 容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d --name <span class="built_in">test</span> busybox /bin/sh -c <span class="string">&quot;while true; do sleep 3600; done&quot;</span></span><br><span class="line">sudo docker run -d --name test1 busybox /bin/sh -c <span class="string">&quot;while true; do sleep 3600; done&quot;</span></span><br></pre></td></tr></table></figure><p><img src="/img/in-post/2019-03-03/8.png" alt="avatar"></p><p>此时发现da678d729936的ip地址为172.17.0.3，cf393747710e的ip地址为172.17.0.2</p><p>执行<code>docker exec da678d729936 ping 172.17.0.2</code>试试可不可以ping通cf393747710e的ip</p><p><img src="/img/in-post/2019-03-03/9.png" alt="avatar"></p><p>发现可以ping通，证明docker两个container之间的ip namespace是隔离开的，但是两个ip之间是可以ping通的，那么具体原理是什么呢？<br>我们可以通过下面的实验模拟来理解一下</p><h2 id="network-namespace"><a href="#network-namespace" class="headerlink" title="network namespace"></a>network namespace</h2><h3 id="创建net-namespace"><a href="#创建net-namespace" class="headerlink" title="创建net namespace"></a>创建net namespace</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo ip netns add &lt;name&gt;        //  添加一个namespace</span><br><span class="line">sudo ip netns list</span><br><span class="line">sudo ip netns <span class="built_in">exec</span> <span class="built_in">test</span> ip a    //  查看<span class="built_in">test</span> ip info</span><br></pre></td></tr></table></figure><p>创建两个namespace</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ip netns add <span class="built_in">test</span></span><br><span class="line">sudo ip netns add test1</span><br></pre></td></tr></table></figure><p>执行<code>sudo ip netns exec test ip link</code> 查看ip信息<br><img src="/img/in-post/2019-03-03/2.png" alt="avatar"></p><p>接口启动命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip netns <span class="built_in">exec</span> <span class="built_in">test</span> ip <span class="built_in">link</span> <span class="built_in">set</span> dev lo up</span><br></pre></td></tr></table></figure><p>此时lo网卡是down状态</p><p>执行<code>sudo ip netns exec test ip link set dev lo up</code> 将lo 开启<br><img src="/img/in-post/2019-03-03/3.png" alt="avatar"></p><p>出现unknown原因是因为lo是单个接口，只有做link后的成对接口可以up</p><h3 id="link-namespace"><a href="#link-namespace" class="headerlink" title="link namespace"></a>link namespace</h3><p>添加一对veth接口，执行<code>sudo ip link add veth-test type veth peer name veth-test1</code></p><p><img src="/img/in-post/2019-03-03/4.png" alt="avatar"></p><p>添加 veth-test 到 test namespace 中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> veth-test netns <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>分别查看本地和test ip link 信息</p><p><img src="/img/in-post/2019-03-03/5.png" alt="avatar"></p><p>发现本地的veth-test接口被添加到了test中，同理，添加test1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> veth-test1 netns test1</span><br></pre></td></tr></table></figure><h3 id="ip-link"><a href="#ip-link" class="headerlink" title="ip link"></a>ip link</h3><p>执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ip netns <span class="built_in">exec</span> <span class="built_in">test</span> ip addr add 192.168.1.1/24 dev veth-test</span><br><span class="line">sudo ip netns <span class="built_in">exec</span> test1 ip addr add 192.168.1.2/24 dev veth-test1</span><br></pre></td></tr></table></figure><p>然后启动接口，参照上面启动lo接口的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ip netns <span class="built_in">exec</span> <span class="built_in">test</span> ip <span class="built_in">link</span> <span class="built_in">set</span> dev veth-test up</span><br><span class="line">sudo ip netns <span class="built_in">exec</span> test1 ip <span class="built_in">link</span> <span class="built_in">set</span> dev veth-test1 up</span><br></pre></td></tr></table></figure><p>查看test和test1 ip 状态<br><img src="/img/in-post/2019-03-03/6.png" alt="avatar"></p><p>发现两个接口状态都是state up，并且test和test1均已分配192.168.1.1和192.168.1.2表示接口已经启动成功,测试相互ping一下</p><p><img src="/img/in-post/2019-03-03/7.png" alt="avatar"></p><h2 id="docker-network"><a href="#docker-network" class="headerlink" title="docker network"></a>docker network</h2><h3 id="bridge"><a href="#bridge" class="headerlink" title="bridge"></a>bridge</h3><p>把之前docker container 中的两个容器stop和rm掉，重新启动一个test容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d --name <span class="built_in">test</span> busybox /bin/sh -c <span class="string">&quot;while true; do sleep 3600; done&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 列举出docker的网络</span><br><span class="line">sudo docker network <span class="built_in">ls</span></span><br><span class="line">// 查看某个docker network <span class="built_in">id</span> 的具体信息</span><br><span class="line">sudo docker network inspect &lt;networkid&gt;</span><br></pre></td></tr></table></figure><p>eg: 查看bridge网络的详细信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@docker-node1 labs]$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">8378c2ff8198        busybox             <span class="string">&quot;/bin/sh -c &#x27;while t…&quot;</span>   3 seconds ago       Up 3 seconds                            <span class="built_in">test</span></span><br><span class="line">[vagrant@docker-node1 labs]$ docker network <span class="built_in">ls</span></span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">1fb7b167deb2        bridge              bridge              <span class="built_in">local</span></span><br><span class="line">2d13173ae2bf        host                host                <span class="built_in">local</span></span><br><span class="line">6d2c375cd6cd        none                null                <span class="built_in">local</span></span><br><span class="line">[vagrant@docker-node1 labs]$ docker network inspect 1fb7b167deb2</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;bridge&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Id&quot;</span>: <span class="string">&quot;1fb7b167deb233148d61b85c03bb68d9b8e3cbb124b60deb7be8acf88abdac21&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Created&quot;</span>: <span class="string">&quot;2019-03-03T02:04:36.334606846Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;bridge&quot;</span>,</span><br><span class="line">        <span class="string">&quot;EnableIPv6&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;IPAM&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Options&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;Config&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;Subnet&quot;</span>: <span class="string">&quot;172.17.0.0/16&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Gateway&quot;</span>: <span class="string">&quot;172.17.0.1&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Internal&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Attachable&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Ingress&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;ConfigFrom&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Network&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;ConfigOnly&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Containers&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;8378c2ff8198bbac6647463286408de11a7814c7882e99232404ecab0e1517ad&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;test&quot;</span>,</span><br><span class="line">                <span class="string">&quot;EndpointID&quot;</span>: <span class="string">&quot;f976820b8133d11cd37602ece5f762106aba2f3735420272ad0ed3bd8b1dc58a&quot;</span>,</span><br><span class="line">                <span class="string">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:ac:11:00:02&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv4Address&quot;</span>: <span class="string">&quot;172.17.0.2/16&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv6Address&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;com.docker.network.bridge.default_bridge&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;com.docker.network.bridge.enable_icc&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;com.docker.network.bridge.enable_ip_masquerade&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;com.docker.network.bridge.host_binding_ipv4&quot;</span>: <span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">            <span class="string">&quot;com.docker.network.bridge.name&quot;</span>: <span class="string">&quot;docker0&quot;</span>,</span><br><span class="line">            <span class="string">&quot;com.docker.network.driver.mtu&quot;</span>: <span class="string">&quot;1500&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">[vagrant@docker-node1 labs]$</span><br></pre></td></tr></table></figure><p><img src="/img/in-post/2019-03-03/10.png" alt="avatar"></p><p>通过上图可以看出本地的 vethd347bdc@if11 和 容器内的 eth0@if12 是一对接口<br>这一对veth peer 连接到了docker0的网络上面，可以通过下面的演示验证</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install bridge-utils</span><br></pre></td></tr></table></figure><p>brctl命令说明</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@docker-node1 labs]$ brctl</span><br><span class="line">Usage: brctl [commands]</span><br><span class="line">commands:</span><br><span class="line">	addbr     	&lt;bridge&gt;		add bridge</span><br><span class="line">	delbr     	&lt;bridge&gt;		delete bridge</span><br><span class="line">	addif     	&lt;bridge&gt; &lt;device&gt;	add interface to bridge</span><br><span class="line">	delif     	&lt;bridge&gt; &lt;device&gt;	delete interface from bridge</span><br><span class="line">	hairpin   	&lt;bridge&gt; &lt;port&gt; &#123;on|off&#125;	turn hairpin on/off</span><br><span class="line">	setageing 	&lt;bridge&gt; &lt;time&gt;		<span class="built_in">set</span> ageing time</span><br><span class="line">	setbridgeprio	&lt;bridge&gt; &lt;prio&gt;		<span class="built_in">set</span> bridge priority</span><br><span class="line">	setfd     	&lt;bridge&gt; &lt;time&gt;		<span class="built_in">set</span> bridge forward delay</span><br><span class="line">	sethello  	&lt;bridge&gt; &lt;time&gt;		<span class="built_in">set</span> hello time</span><br><span class="line">	setmaxage 	&lt;bridge&gt; &lt;time&gt;		<span class="built_in">set</span> max message age</span><br><span class="line">	setpathcost	&lt;bridge&gt; &lt;port&gt; &lt;cost&gt;	<span class="built_in">set</span> path cost</span><br><span class="line">	setportprio	&lt;bridge&gt; &lt;port&gt; &lt;prio&gt;	<span class="built_in">set</span> port priority</span><br><span class="line">	show      	[ &lt;bridge&gt; ]		show a list of bridges</span><br><span class="line">	showmacs  	&lt;bridge&gt;		show a list of mac addrs</span><br><span class="line">	showstp   	&lt;bridge&gt;		show bridge stp info</span><br><span class="line">	stp       	&lt;bridge&gt; &#123;on|off&#125;	turn stp on/off</span><br><span class="line">[vagrant@docker-node1 labs]$</span><br></pre></td></tr></table></figure><p>启动test2容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d --name test1 busybox /bin/sh -c <span class="string">&quot;while true; do sleep 3600; done&quot;</span></span><br></pre></td></tr></table></figure><p>通过<code>brctl show</code>命令可以看到如下结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@docker-node1 labs]$ brctl show</span><br><span class="line">bridge name	bridge <span class="built_in">id</span>		STP enabled	interfaces</span><br><span class="line">docker0		8000.02425db75bb1	no		veth4de57f6</span><br><span class="line">							            vethd347bdc</span><br></pre></td></tr></table></figure><p>可以看到docker0和两个veth peer接口的关系</p><h3 id="host-和-none"><a href="#host-和-none" class="headerlink" title="host 和 none"></a>host 和 none</h3><h4 id="none"><a href="#none" class="headerlink" title="none"></a>none</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d --name test4 --network none busybox /bin/sh -c <span class="string">&quot;while true; do sleep 3600; done&quot;</span></span><br></pre></td></tr></table></figure><p><img src="/img/in-post/2019-03-03/25.png" alt="avatar"></p><p>这种方式创建的容器没有ip地址，只能通过exec的方式进入</p><p><img src="/img/in-post/2019-03-03/26.png" alt="avatar"></p><h4 id="host"><a href="#host" class="headerlink" title="host"></a>host</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d --name test5 --network host busybox /bin/sh -c <span class="string">&quot;while true; do sleep 3600; done&quot;</span></span><br></pre></td></tr></table></figure><p><img src="/img/in-post/2019-03-03/27.png" alt="avatar"></p><p>进入test5容器查看ip</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@docker-node1 ~]$ docker <span class="built_in">exec</span> test5 ip a</span><br><span class="line">...</span><br><span class="line">37: veth9cb9ecd@if36: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue master docker0</span><br><span class="line">    <span class="built_in">link</span>/ether ce:61:3e:72:57:f9 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet6 fe80::cc61:3eff:fe72:57f9/64 scope <span class="built_in">link</span></span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">...</span><br><span class="line">[vagrant@docker-node1 ~]$  ip a</span><br><span class="line">...</span><br><span class="line">37: veth9cb9ecd@if36: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP</span><br><span class="line">    <span class="built_in">link</span>/ether ce:61:3e:72:57:f9 brd ff:ff:ff:ff:ff:ff link-netnsid 4</span><br><span class="line">    inet6 fe80::cc61:3eff:fe72:57f9/64 scope <span class="built_in">link</span></span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们发现这种方式的docker container 共享了主机里面的ip namespace</p><h2 id="多机器通信"><a href="#多机器通信" class="headerlink" title="多机器通信"></a>多机器通信</h2><p><img src="/img/in-post/2019-03-03/28.png" alt="avatar"></p><h3 id="Mutil-host-networking-with-etcd"><a href="#Mutil-host-networking-with-etcd" class="headerlink" title="Mutil-host networking with etcd"></a>Mutil-host networking with etcd</h3><h4 id="setup-etcd-cluster"><a href="#setup-etcd-cluster" class="headerlink" title="setup etcd cluster"></a>setup etcd cluster</h4><p>在docker-node1上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vagrant@docker-node1:~$ wget https://github.com/coreos/etcd/releases/download/v3.0.12/etcd-v3.0.12-linux-amd64.tar.gz</span><br><span class="line">vagrant@docker-node1:~$ tar zxvf etcd-v3.0.12-linux-amd64.tar.gz</span><br><span class="line">vagrant@docker-node1:~$ cd etcd-v3.0.12-linux-amd64</span><br><span class="line">vagrant@docker-node1:~$ nohup ./etcd --name docker-node1 --initial-advertise-peer-urls http://192.168.205.10:2380 \</span><br><span class="line">--listen-peer-urls http://192.168.205.10:2380 \</span><br><span class="line">--listen-client-urls http://192.168.205.10:2379,http://127.0.0.1:2379 \</span><br><span class="line">--advertise-client-urls http://192.168.205.10:2379 \</span><br><span class="line">--initial-cluster-token etcd-cluster \</span><br><span class="line">--initial-cluster docker-node1=http://192.168.205.10:2380,docker-node2=http://192.168.205.11:2380 \</span><br><span class="line">--initial-cluster-state new&amp;</span><br></pre></td></tr></table></figure><p>在docker-node2上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vagrant@docker-node2:~$ wget https://github.com/coreos/etcd/releases/download/v3.0.12/etcd-v3.0.12-linux-amd64.tar.gz</span><br><span class="line">vagrant@docker-node2:~$ tar zxvf etcd-v3.0.12-linux-amd64.tar.gz</span><br><span class="line">vagrant@docker-node2:~$ cd etcd-v3.0.12-linux-amd64/</span><br><span class="line">vagrant@docker-node2:~$ nohup ./etcd --name docker-node2 --initial-advertise-peer-urls http://192.168.205.11:2380 \</span><br><span class="line">--listen-peer-urls http://192.168.205.11:2380 \</span><br><span class="line">--listen-client-urls http://192.168.205.11:2379,http://127.0.0.1:2379 \</span><br><span class="line">--advertise-client-urls http://192.168.205.11:2379 \</span><br><span class="line">--initial-cluster-token etcd-cluster \</span><br><span class="line">--initial-cluster docker-node1=http://192.168.205.10:2380,docker-node2=http://192.168.205.11:2380 \</span><br><span class="line">--initial-cluster-state new&amp;</span><br></pre></td></tr></table></figure><p>检查cluster状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vagrant@docker-node2:~/etcd-v3.0.12-linux-amd64$ ./etcdctl cluster-health</span><br><span class="line">member 21eca106efe4caee is healthy: got healthy result from http://192.168.205.10:2379</span><br><span class="line">member 8614974c83d1cc6d is healthy: got healthy result from http://192.168.205.11:2379</span><br><span class="line">cluster is healthy</span><br></pre></td></tr></table></figure><h4 id="重启docker服务"><a href="#重启docker服务" class="headerlink" title="重启docker服务"></a>重启docker服务</h4><p>在docker-node1上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service docker stop</span><br><span class="line">$ sudo /usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock --cluster-store=etcd://192.168.205.10:2379 --cluster-advertise=192.168.205.10:2375&amp;</span><br></pre></td></tr></table></figure><p>在docker-node2上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service docker stop</span><br><span class="line">$ sudo /usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock --cluster-store=etcd://192.168.205.11:2379 --cluster-advertise=192.168.205.11:2375&amp;</span><br></pre></td></tr></table></figure><h4 id="创建overlay-network"><a href="#创建overlay-network" class="headerlink" title="创建overlay network"></a>创建overlay network</h4><p>在docker-node1上创建一个demo的overlay network</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@docker-node1 etcd-v3.0.12-linux-amd64]$ sudo docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">22c070951371        bridge              bridge              local</span><br><span class="line">2d13173ae2bf        host                host                local</span><br><span class="line">c144a2167891        my-bridge           bridge              local</span><br><span class="line">6d2c375cd6cd        none                null                local</span><br><span class="line">[vagrant@docker-node1 etcd-v3.0.12-linux-amd64]$ sudo docker network create -d overlay demo</span><br><span class="line">6f58ba8913c3e0df5ac9086f79e87cc62e57ac723d26dcb05edb7635f19103c8</span><br><span class="line">[vagrant@docker-node1 etcd-v3.0.12-linux-amd64]$ sudo docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">22c070951371        bridge              bridge              local</span><br><span class="line">6f58ba8913c3        demo                overlay             global</span><br><span class="line">2d13173ae2bf        host                host                local</span><br><span class="line">c144a2167891        my-bridge           bridge              local</span><br><span class="line">6d2c375cd6cd        none                null                local</span><br><span class="line">[vagrant@docker-node1 etcd-v3.0.12-linux-amd64]$ sudo docker network inspect demo</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;demo&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;6f58ba8913c3e0df5ac9086f79e87cc62e57ac723d26dcb05edb7635f19103c8&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2019-03-03T13:03:20.535696601Z&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;global&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;overlay&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;10.0.0.0/24&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;10.0.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>我们会看到在node2上，这个demo的overlay network会被同步创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vagrant@docker-node2:~$ sudo docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">c9947d4c3669        bridge              bridge              local</span><br><span class="line">3d430f3338a2        demo                overlay             global</span><br><span class="line">fa5168034de1        host                host                local</span><br><span class="line">c2ca34abec2a        none                null                local</span><br></pre></td></tr></table></figure><p>通过查看etcd的key-value, 我们获取到，这个demo的network是通过etcd从node1同步到node2的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@docker-node2 etcd-v3.0.12-linux-amd64]$ ./etcdctl ls /docker</span><br><span class="line">/docker/network</span><br><span class="line">/docker/nodes</span><br><span class="line">[vagrant@docker-node2 etcd-v3.0.12-linux-amd64]$ ./etcdctl ls /docker/nodes</span><br><span class="line">/docker/nodes/192.168.205.10:2375</span><br><span class="line">/docker/nodes/192.168.205.11:2375</span><br><span class="line">[vagrant@docker-node2 etcd-v3.0.12-linux-amd64]$ ./etcdctl ls /docker/network/v1.0/network</span><br><span class="line">/docker/network/v1.0/network/6f58ba8913c3e0df5ac9086f79e87cc62e57ac723d26dcb05edb7635f19103c8</span><br><span class="line">[vagrant@docker-node2 etcd-v3.0.12-linux-amd64]$ ./etcdctl get /docker/network/v1.0/network/6f58ba8913c3e0df5ac9086f79e87cc62e57ac723d26dcb05edb7635f19103c8</span><br><span class="line">&#123;&quot;addrSpace&quot;:&quot;GlobalDefault&quot;,&quot;attachable&quot;:false,&quot;configFrom&quot;:&quot;&quot;,&quot;configOnly&quot;:false,&quot;created&quot;:&quot;2019-03-03T13:03:20.535696601Z&quot;,&quot;enableIPv6&quot;:false,&quot;generic&quot;:&#123;&quot;com.docker.network.enable_ipv6&quot;:false,&quot;com.docker.network.generic&quot;:&#123;&#125;&#125;,&quot;id&quot;:&quot;6f58ba8913c3e0df5ac9086f79e87cc62e57ac723d26dcb05edb7635f19103c8&quot;,&quot;inDelete&quot;:false,&quot;ingress&quot;:false,&quot;internal&quot;:false,&quot;ipamOptions&quot;:&#123;&#125;,&quot;ipamType&quot;:&quot;default&quot;,&quot;ipamV4Config&quot;:&quot;[&#123;\&quot;PreferredPool\&quot;:\&quot;\&quot;,\&quot;SubPool\&quot;:\&quot;\&quot;,\&quot;Gateway\&quot;:\&quot;\&quot;,\&quot;AuxAddresses\&quot;:null&#125;]&quot;,&quot;ipamV4Info&quot;:&quot;[&#123;\&quot;IPAMData\&quot;:\&quot;&#123;\\\&quot;AddressSpace\\\&quot;:\\\&quot;GlobalDefault\\\&quot;,\\\&quot;Gateway\\\&quot;:\\\&quot;10.0.0.1/24\\\&quot;,\\\&quot;Pool\\\&quot;:\\\&quot;10.0.0.0/24\\\&quot;&#125;\&quot;,\&quot;PoolID\&quot;:\&quot;GlobalDefault/10.0.0.0/24\&quot;&#125;]&quot;,&quot;labels&quot;:&#123;&#125;,&quot;loadBalancerIP&quot;:&quot;&quot;,&quot;loadBalancerMode&quot;:&quot;NAT&quot;,&quot;name&quot;:&quot;demo&quot;,&quot;networkType&quot;:&quot;overlay&quot;,&quot;persist&quot;:true,&quot;postIPv6&quot;:false,&quot;scope&quot;:&quot;global&quot;&#125;</span><br><span class="line">[vagrant@docker-node2 etcd-v3.0.12-linux-amd64]$</span><br></pre></td></tr></table></figure><p>在node1中执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d --name test1 --net demo busybox /bin/sh -c <span class="string">&quot;while true; do sleep 3600; done&quot;</span></span><br></pre></td></tr></table></figure><p>在node2中执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d --name test2 --net demo busybox /bin/sh -c <span class="string">&quot;while true; do sleep 3600; done&quot;</span></span><br></pre></td></tr></table></figure><p>分别查看test1,test2 ip</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@docker-node1 etcd-v3.0.12-linux-amd64]$ docker <span class="built_in">exec</span> test1 ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">19: eth0@if20: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1450 qdisc noqueue</span><br><span class="line">    <span class="built_in">link</span>/ether 02:42:0a:00:00:02 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.0.0.2/24 brd 10.0.0.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">21: eth1@if22: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue</span><br><span class="line">    <span class="built_in">link</span>/ether 02:42:ac:13:00:02 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.19.0.2/16 brd 172.19.255.255 scope global eth1</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> test2 ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">7: eth0@if8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1450 qdisc noqueue</span><br><span class="line">    <span class="built_in">link</span>/ether 02:42:0a:00:00:03 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.0.0.3/24 brd 10.0.0.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">10: eth1@if11: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue</span><br><span class="line">    <span class="built_in">link</span>/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.18.0.2/16 brd 172.18.255.255 scope global eth1</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>查看是否能ping通</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@docker-node2 etcd-v3.0.12-linux-amd64]$ docker <span class="built_in">exec</span> test2 ping 10.0.0.2</span><br><span class="line">PING 10.0.0.2 (10.0.0.2): 56 data bytes</span><br><span class="line">64 bytes from 10.0.0.2: <span class="built_in">seq</span>=0 ttl=64 time=9.354 ms</span><br><span class="line">64 bytes from 10.0.0.2: <span class="built_in">seq</span>=1 ttl=64 time=0.789 ms</span><br><span class="line">64 bytes from 10.0.0.2: <span class="built_in">seq</span>=2 ttl=64 time=1.062 ms</span><br><span class="line">^C</span><br><span class="line">[vagrant@docker-node2 etcd-v3.0.12-linux-amd64]$ docker <span class="built_in">exec</span> test2 ping test1</span><br><span class="line">PING test1 (10.0.0.2): 56 data bytes</span><br><span class="line">64 bytes from 10.0.0.2: <span class="built_in">seq</span>=0 ttl=64 time=0.724 ms</span><br><span class="line">64 bytes from 10.0.0.2: <span class="built_in">seq</span>=1 ttl=64 time=0.590 ms</span><br><span class="line">ç64 bytes from 10.0.0.2: <span class="built_in">seq</span>=2 ttl=64 time=0.789 ms</span><br><span class="line">64 bytes from 10.0.0.2: <span class="built_in">seq</span>=3 ttl=64 time=0.651 ms</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2021/03/03/2021-03-03-docker-port/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2021/03/03/2021-03-03-docker-port/" class="post-title-link" itemprop="url">Docker network port</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-03-03 11:30:00" itemprop="dateCreated datePublished" datetime="2021-03-03T11:30:00+08:00">2021-03-03</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name web -d nginx</span><br></pre></td></tr></table></figure><p><img src="/img/in-post/2019-03-03/19.png" alt="avatar"></p><p>由上图可以看到我们在虚拟机内部访问container的ip的方式可以访问到nginx欢迎页，但是访问本地地址映射不到,<br>可以通过端口映射来解决这个问题</p><p>删除刚才的nginx container,重新启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker stop web</span><br><span class="line">docker <span class="built_in">rm</span> web</span><br><span class="line">docker run --name web -d -p 80:80 nginx</span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><img src="/img/in-post/2019-03-03/20.png" alt="avatar"></p><p>映射成功</p><p>我的vagrant ip 映射配置<br><img src="/img/in-post/2019-03-03/21.png" alt="avatar"><br><img src="/img/in-post/2019-03-03/22.png" alt="avatar"></p><p>映射流程</p><p><img src="/img/in-post/2019-03-03/24.png" alt="avatar"></p><p>图中的192.168.205.10:80为我本机的ip私有地址，外网不能访问，如果我们是在一个云主机上创建的web服务，云主机就可以分配一个public的ip就可以作为外网的出口ip来提供服务</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2021/03/03/2021-03-03-docker-link/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2021/03/03/2021-03-03-docker-link/" class="post-title-link" itemprop="url">Docker network link</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-03-03 10:30:00" itemprop="dateCreated datePublished" datetime="2021-03-03T10:30:00+08:00">2021-03-03</time></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="docker-link"><a href="#docker-link" class="headerlink" title="docker link"></a>docker link</h1><h2 id="docker-link-1"><a href="#docker-link-1" class="headerlink" title="docker link"></a>docker link</h2><p>由于docker container 之中的 ip在为创建之前是未知的，不利于服务与服务之间的配置连接，所以docker 提供了一种办法来解决这个问题，<br>可以通过 docker name 之间的link来解决</p><p><img src="/img/in-post/2019-03-03/11.png" alt="avatar"></p><p>创建test2并link到test1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name test2 --<span class="built_in">link</span> test1 busybox /bin/sh -c <span class="string">&quot;while true; do sleep 3600; done&quot;</span></span><br></pre></td></tr></table></figure><p>进入到test2容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it test2 /bin/sh</span><br><span class="line">ping test1</span><br></pre></td></tr></table></figure><p><img src="/img/in-post/2019-03-03/12.png" alt="avatar"></p><p>这种方式的优点是：<br>假如test1有一个数据库，我们可以在test2容器中通过<code>mysql -u &lt;name&gt; -P &lt;port&gt; -h test1</code>来访问了</p><blockquote><p>由于是test2 去link test1 所以，在test1容器中，ping test2是不可用的</p></blockquote><h2 id="network-创建"><a href="#network-创建" class="headerlink" title="network 创建"></a>network 创建</h2><p>删除掉test2容器并重新创建test2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name test2 busybox /bin/sh -c <span class="string">&quot;while true; do sleep 3600; done&quot;</span></span><br></pre></td></tr></table></figure><h3 id="创建bridge"><a href="#创建bridge" class="headerlink" title="创建bridge"></a>创建bridge</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d bridge my-bridge</span><br><span class="line">docker network <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p><img src="/img/in-post/2019-03-03/13.png" alt="avatar"></p><p>创建test3并指定network到my-bridge</p><blockquote><p>如果不指定network默认连接是docker0</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name test3 --network my-bridge busybox /bin/sh -c <span class="string">&quot;while true; do sleep 3600; done&quot;</span></span><br></pre></td></tr></table></figure><p><img src="/img/in-post/2019-03-03/14.png" alt="avatar"></p><p>查看test3 container network信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect &lt;my-bridge <span class="built_in">id</span>&gt;</span><br></pre></td></tr></table></figure><p><img src="/img/in-post/2019-03-03/15.png" alt="avatar"></p><h3 id="bridge连接"><a href="#bridge连接" class="headerlink" title="bridge连接"></a>bridge连接</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect my-bridge test2</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect bridge</span><br><span class="line">docker network inspect my-bridge</span><br></pre></td></tr></table></figure><p>我们可以看到bridge和my-bridge的container中都包含了test2</p><p>进入到test2容器中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it test2 /bin/sh</span><br></pre></td></tr></table></figure><p><img src="/img/in-post/2019-03-03/16.png" alt="avatar"></p><p>可以发现在test2容器中可以ping通test3但是不能ping test1, 实际上docker在用户自己创建的bridge中做了一层link，所以test2和test3容器可以相互ping 通对方</p><p>把test1也加入到my-bridge中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect my-bridge test1</span><br></pre></td></tr></table></figure><p><img src="/img/in-post/2019-03-03/17.png" alt="avatar"></p><p>此时test1也可以ping通了</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2021/03/02/2021-03-02-vagrant/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2021/03/02/2021-03-02-vagrant/" class="post-title-link" itemprop="url">Vagrant基本命令</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-03-02 21:30:00" itemprop="dateCreated datePublished" datetime="2021-03-02T21:30:00+08:00">2021-03-02</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="vagrant-使用"><a href="#vagrant-使用" class="headerlink" title="vagrant 使用"></a>vagrant 使用</h2><h2 id="init-centos"><a href="#init-centos" class="headerlink" title="init centos"></a>init centos</h2><p>centos7 box 下载地址<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1kVlAz59">centos7</a></p><p><strong>添加vagrant box到box list</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant box add centos7 Vagrant-CentOS-7.box</span><br></pre></td></tr></table></figure><p><strong>初始化一个虚拟机使用刚才添加的vagrant box</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> centos</span><br><span class="line"><span class="built_in">cd</span> centos</span><br><span class="line">vim Vagrantfile</span><br></pre></td></tr></table></figure><p><strong>添加下面内容到Vagrantfile中</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- mode: ruby -*-</span></span><br><span class="line"><span class="comment"># vi: set ft=ruby :</span></span><br><span class="line"></span><br><span class="line">Vagrant.require_version <span class="string">&quot;&gt;= 1.6.0&quot;</span></span><br><span class="line"></span><br><span class="line">boxes = [</span><br><span class="line">    &#123;</span><br><span class="line">        :name =&gt; <span class="string">&quot;docker-node1&quot;</span>,</span><br><span class="line">        :eth1 =&gt; <span class="string">&quot;192.168.205.10&quot;</span>,</span><br><span class="line">        :mem =&gt; <span class="string">&quot;1024&quot;</span>,</span><br><span class="line">        :cpu =&gt; <span class="string">&quot;1&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        :name =&gt; <span class="string">&quot;docker-node2&quot;</span>,</span><br><span class="line">        :eth1 =&gt; <span class="string">&quot;192.168.205.11&quot;</span>,</span><br><span class="line">        :mem =&gt; <span class="string">&quot;1024&quot;</span>,</span><br><span class="line">        :cpu =&gt; <span class="string">&quot;1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Vagrant.configure(2) <span class="keyword">do</span> |config|</span><br><span class="line"></span><br><span class="line">  config.vm.box = <span class="string">&quot;centos7&quot;</span></span><br><span class="line"></span><br><span class="line">  boxes.each <span class="keyword">do</span> |opts|</span><br><span class="line">      config.vm.define opts[:name] <span class="keyword">do</span> |config|</span><br><span class="line">        config.vm.hostname = opts[:name]</span><br><span class="line">        config.vm.provider <span class="string">&quot;vmware_fusion&quot;</span> <span class="keyword">do</span> |v|</span><br><span class="line">          v.vmx[<span class="string">&quot;memsize&quot;</span>] = opts[:mem]</span><br><span class="line">          v.vmx[<span class="string">&quot;numvcpus&quot;</span>] = opts[:cpu]</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        config.vm.provider <span class="string">&quot;virtualbox&quot;</span> <span class="keyword">do</span> |v|</span><br><span class="line">          v.customize [<span class="string">&quot;modifyvm&quot;</span>, :<span class="built_in">id</span>, <span class="string">&quot;--memory&quot;</span>, opts[:mem]]</span><br><span class="line">          v.customize [<span class="string">&quot;modifyvm&quot;</span>, :<span class="built_in">id</span>, <span class="string">&quot;--cpus&quot;</span>, opts[:cpu]]</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        config.vm.network :private_network, ip: opts[:eth1]</span><br><span class="line">      end</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  config.vm.provision <span class="string">&quot;shell&quot;</span>, privileged: <span class="literal">true</span>, path: <span class="string">&quot;./setup.sh&quot;</span></span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>install docker的setup.sh文件</strong></p><p>在当前目录创建setup.sh文件并添加如下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># install some tools</span></span><br><span class="line">sudo yum install -y git vim gcc glibc-static telnet bridge-utils</span><br><span class="line"></span><br><span class="line"><span class="comment"># install docker</span></span><br><span class="line">curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line">sh get-docker.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># start docker service</span></span><br><span class="line">sudo groupadd docker</span><br><span class="line">sudo usermod -aG docker vagrant</span><br><span class="line">sudo systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -rf get-docker.sh</span><br></pre></td></tr></table></figure><p><strong>启动安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant up</span><br></pre></td></tr></table></figure><h2 id="vagrant-报unknown-filesystem-type-‘vboxsf’-解决方案"><a href="#vagrant-报unknown-filesystem-type-‘vboxsf’-解决方案" class="headerlink" title="vagrant 报unknown filesystem type ‘vboxsf’ 解决方案"></a>vagrant 报unknown filesystem type ‘vboxsf’ 解决方案</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vagrant plugin install vagrant-vbguest</span><br><span class="line">vagrant destroy &amp;&amp; vagrant up</span><br></pre></td></tr></table></figure><h2 id="init-ubuntu"><a href="#init-ubuntu" class="headerlink" title="init ubuntu"></a>init ubuntu</h2><p>使用<a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-cloud-images/bionic/current/">清华源</a></p><p><strong>ubuntu18的box，终端运行如下命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vagrant box add \</span><br><span class="line">https://mirrors.tuna.tsinghua.edu.cn/ubuntu-cloud-images/bionic/current/bionic-server-cloudimg-amd64-vagrant.box \</span><br><span class="line">--name ubuntu/bionic</span><br></pre></td></tr></table></figure><p>Vagrantfile这样写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">config.vm.box = <span class="string">&quot;ubuntu/bionic&quot;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>接着就是<code>vagrant up &amp;&amp; vagrant ssh</code>了</p><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h3 id="列出所有Box"><a href="#列出所有Box" class="headerlink" title="列出所有Box"></a>列出所有Box</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant box list</span><br></pre></td></tr></table></figure><h3 id="添加一个Box"><a href="#添加一个Box" class="headerlink" title="添加一个Box"></a>添加一个Box</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant box add [options] &lt;name, url, or path</span><br></pre></td></tr></table></figure><h3 id="可以从https-app-vagrantup-com-boxes-search下载各种Vagrant映像文件"><a href="#可以从https-app-vagrantup-com-boxes-search下载各种Vagrant映像文件" class="headerlink" title="可以从https://app.vagrantup.com/boxes/search下载各种Vagrant映像文件"></a>可以从<a target="_blank" rel="noopener" href="https://app.vagrantup.com/boxes/search%E4%B8%8B%E8%BD%BD%E5%90%84%E7%A7%8DVagrant%E6%98%A0%E5%83%8F%E6%96%87%E4%BB%B6">https://app.vagrantup.com/boxes/search下载各种Vagrant映像文件</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant box add ubuntu/trusty64</span><br></pre></td></tr></table></figure><h3 id="通过指定的URL添加远程box"><a href="#通过指定的URL添加远程box" class="headerlink" title="通过指定的URL添加远程box"></a>通过指定的URL添加远程box</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant box add https://atlas.hashicorp.com/ubuntu/boxes/trusty64</span><br></pre></td></tr></table></figure><h3 id="添加一个本地box"><a href="#添加一个本地box" class="headerlink" title="添加一个本地box"></a>添加一个本地box</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant box add &#123;box_name&#125; &#123;file_path&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化一个新VM"><a href="#初始化一个新VM" class="headerlink" title="初始化一个新VM"></a>初始化一个新VM</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant init ubuntu/trustry64</span><br></pre></td></tr></table></figure><p>此命令会在当前目录创建一个名为Vagrantfile的配置文件，内容大致如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(<span class="string">&quot;2&quot;</span>) <span class="keyword">do</span> |config|</span><br><span class="line">  config.vm.box = <span class="string">&quot;ubuntu/trusty64&quot;</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="初始化一个新VM-1"><a href="#初始化一个新VM-1" class="headerlink" title="初始化一个新VM"></a>初始化一个新VM</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant up</span><br></pre></td></tr></table></figure><h3 id="启用SSH登陆VM"><a href="#启用SSH登陆VM" class="headerlink" title="启用SSH登陆VM"></a>启用SSH登陆VM</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant ssh &lt;node_name&gt;</span><br></pre></td></tr></table></figure><p>如果需要从虚拟机中退出，直接在虚拟机中的命令行输入exit命令即可</p><h3 id="查看VM当前的状态"><a href="#查看VM当前的状态" class="headerlink" title="查看VM当前的状态"></a>查看VM当前的状态</h3><p>进入Vagrantfile配置文件所在的目录，执行以下命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant status</span><br></pre></td></tr></table></figure><h3 id="关闭VM"><a href="#关闭VM" class="headerlink" title="关闭VM"></a>关闭VM</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant halt</span><br></pre></td></tr></table></figure><h3 id="销毁VM"><a href="#销毁VM" class="headerlink" title="销毁VM"></a>销毁VM</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant destory [name|<span class="built_in">id</span>]</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2021/03/02/2021-03-02-dockerfile/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2021/03/02/2021-03-02-dockerfile/" class="post-title-link" itemprop="url">Dockerfile 语法梳理</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-03-02 13:30:00" itemprop="dateCreated datePublished" datetime="2021-03-02T13:30:00+08:00">2021-03-02</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="Dockerfile语法梳理"><a href="#Dockerfile语法梳理" class="headerlink" title="Dockerfile语法梳理"></a>Dockerfile语法梳理</h2><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>from 后面接base image</p><p>eg:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">FROM</span> ubuntu</span><br></pre></td></tr></table></figure><blockquote><p>尽量使用官方的image 作为base image</p></blockquote><h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer=<span class="string">&quot;username@gmail.com&quot;</span> </span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> version=<span class="string">&quot;1.0&quot;</span> </span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> description=<span class="string">&quot;this is description&quot;</span> </span></span><br></pre></td></tr></table></figure><blockquote><p>MetaData 不可少</p></blockquote><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>执行命令并创建新的IMAGE LAYER</p><p>为了美观，复杂的RUN用反斜杠换行，避免无用分层，合并多条命令成一行。</p><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum update &amp;&amp; yum install -y vim \</span></span><br><span class="line"><span class="language-bash">python-dev</span></span><br></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y perl \</span></span><br><span class="line"><span class="language-bash">pwgen --no-install-recommends &amp;&amp; <span class="built_in">rm</span> -rf \</span></span><br><span class="line"><span class="language-bash">/var/lib/apt/lists/*     <span class="comment">#清理cache</span></span></span><br></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> /bin/bash -c <span class="string">&#x27;source $HOME/.bashrc;echo #HOME&#x27;</span></span></span><br></pre></td></tr></table></figure><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> <span class="built_in">test</span>       <span class="comment"># 如果没有会自动创建test文件夹</span></span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> demo</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">pwd</span>            <span class="comment"># 打印/test/demo</span></span></span><br></pre></td></tr></table></figure><blockquote><p>尽量使用WORKDIR,不要使用RUN cd,尽量使用绝对路径</p></blockquote><h3 id="ADD-and-COPY"><a href="#ADD-and-COPY" class="headerlink" title="ADD and COPY"></a>ADD and COPY</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="language-bash"> hello /</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> test.tar.gz / <span class="comment"># 添加到根目录并解压缩</span></span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> hello <span class="built_in">test</span> /    <span class="comment"># /root/test/hello</span></span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> hello <span class="built_in">test</span> /</span></span><br></pre></td></tr></table></figure><blockquote><p>大部分情况COPY优于，ADD有额外的解压功能，添加远程文件或目录用curl或wget</p></blockquote><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> MYSQL_VERSION <span class="number">5.6</span> <span class="comment">#常量</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y mysql-server= <span class="string">&quot;<span class="variable">$&#123;MYSQL_VERSION&#125;</span>&quot;</span> \</span></span><br><span class="line"><span class="language-bash">&amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br></pre></td></tr></table></figure><h3 id="CMD-amp-ENTRYPOINT"><a href="#CMD-amp-ENTRYPOINT" class="headerlink" title="CMD &amp; ENTRYPOINT"></a>CMD &amp; ENTRYPOINT</h3><p>CMD:设置容器启动后默认执行的命令和参数<br>如果docker run指定了其它的命令，则忽略CMD命令<br>定义多个CMD,只有最后一个会执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run &lt;image&gt;</span><br><span class="line">docker run -it &lt;image&gt; /bin/bash    //此命令会忽略CMD中的命令</span><br></pre></td></tr></table></figure><p>ENTRYPOINT:设置容器启动时运行的命令<br>让容器已应用程序或者服务的方式执行<br>不会被忽略，一定会执行</p><h4 id="SHELL-amp-EXEC"><a href="#SHELL-amp-EXEC" class="headerlink" title="SHELL &amp; EXEC"></a>SHELL &amp; EXEC</h4><p>SHELL:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y vim</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;hello docker&quot;</span></span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;hello docker&quot;</span></span></span><br></pre></td></tr></table></figure><p>EXEC:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [<span class="string">&quot;apt-get&quot;</span>, <span class="string">&quot;install&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;vim&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/bin/echo&quot;</span>, <span class="string">&quot;hello docker&quot;</span>]</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/bin/echo&quot;</span>, <span class="string">&quot;hello docker&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>EXEC方式需要指明运行环境，eg:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">ENV</span> name word</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;echo hello <span class="variable">$name</span>&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>更多详见<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/">扩展阅读</a></p><h2 id="Dockerfile实战"><a href="#Dockerfile实战" class="headerlink" title="Dockerfile实战"></a>Dockerfile实战</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> flask-hello-word</span><br><span class="line"><span class="built_in">cd</span> flask-hello-word</span><br><span class="line">vim app.py</span><br></pre></td></tr></table></figure><p>app.py内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello docker&quot;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, port=<span class="number">5000</span>)</span><br></pre></td></tr></table></figure><p>编写Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">2.7</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer=<span class="string">&quot;peng.shiliang&lt;1390509500@qq.com&gt;&quot;</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install flask</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.py /app/       <span class="comment"># app后面必须接/，否则会当作文件</span></span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">5000</span>             <span class="comment"># 端口映射,保证远程能够访问</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t pengshiliang/flask-hello-word .</span><br><span class="line">docker push pengshiliang/flask-hello-word:latest</span><br></pre></td></tr></table></figure><p>运行flask-hello-word</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name=demo pengshiliang/flask-hello-word     //--name 便于docker container 操作</span><br><span class="line">docker <span class="built_in">exec</span> -it demo ip a       //查看docker容器ip</span><br><span class="line">curl &lt;demo ip&gt;      //输出hello docker</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article><nav class="pagination"><a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a> <a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a></nav></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">enpsl</p><div class="site-description" itemprop="description">my blog</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">39</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">7</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2023</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">enpsl</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动</div></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script></body></html>