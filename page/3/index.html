<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"enpsl.github.io",root:"/",scheme:"Muse",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="my blog"><meta property="og:type" content="website"><meta property="og:title" content="彭诗亮的博客"><meta property="og:url" content="https://enpsl.github.io/page/3/index.html"><meta property="og:site_name" content="彭诗亮的博客"><meta property="og:description" content="my blog"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="enpsl"><meta property="article:tag" content="彭诗亮 psl pengshiliang blog"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://enpsl.github.io/page/3/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!0,isPost:!1,lang:"zh-CN"}</script><title>彭诗亮的博客</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">彭诗亮的博客</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档</a></li></ul></nav></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content index posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2021/03/03/2021-03-03-docker-link/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2021/03/03/2021-03-03-docker-link/" class="post-title-link" itemprop="url">Docker network link</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-03-03 10:30:00" itemprop="dateCreated datePublished" datetime="2021-03-03T10:30:00+08:00">2021-03-03</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-01-19 15:31:17" itemprop="dateModified" datetime="2023-01-19T15:31:17+08:00">2023-01-19</time></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="docker-link"><a href="#docker-link" class="headerlink" title="docker link"></a>docker link</h1><h2 id="docker-link-1"><a href="#docker-link-1" class="headerlink" title="docker link"></a>docker link</h2><p>由于docker container 之中的 ip在为创建之前是未知的，不利于服务与服务之间的配置连接，所以docker 提供了一种办法来解决这个问题，<br>可以通过 docker name 之间的link来解决</p><p><img src="/img/in-post/2019-03-03/11.png" alt="avatar"></p><p>创建test2并link到test1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name test2 --<span class="built_in">link</span> test1 busybox /bin/sh -c <span class="string">&quot;while true; do sleep 3600; done&quot;</span></span><br></pre></td></tr></table></figure><p>进入到test2容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it test2 /bin/sh</span><br><span class="line">ping test1</span><br></pre></td></tr></table></figure><p><img src="/img/in-post/2019-03-03/12.png" alt="avatar"></p><p>这种方式的优点是：<br>假如test1有一个数据库，我们可以在test2容器中通过<code>mysql -u &lt;name&gt; -P &lt;port&gt; -h test1</code>来访问了</p><blockquote><p>由于是test2 去link test1 所以，在test1容器中，ping test2是不可用的</p></blockquote><h2 id="network-创建"><a href="#network-创建" class="headerlink" title="network 创建"></a>network 创建</h2><p>删除掉test2容器并重新创建test2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name test2 busybox /bin/sh -c <span class="string">&quot;while true; do sleep 3600; done&quot;</span></span><br></pre></td></tr></table></figure><h3 id="创建bridge"><a href="#创建bridge" class="headerlink" title="创建bridge"></a>创建bridge</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d bridge my-bridge</span><br><span class="line">docker network <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p><img src="/img/in-post/2019-03-03/13.png" alt="avatar"></p><p>创建test3并指定network到my-bridge</p><blockquote><p>如果不指定network默认连接是docker0</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name test3 --network my-bridge busybox /bin/sh -c <span class="string">&quot;while true; do sleep 3600; done&quot;</span></span><br></pre></td></tr></table></figure><p><img src="/img/in-post/2019-03-03/14.png" alt="avatar"></p><p>查看test3 container network信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect &lt;my-bridge <span class="built_in">id</span>&gt;</span><br></pre></td></tr></table></figure><p><img src="/img/in-post/2019-03-03/15.png" alt="avatar"></p><h3 id="bridge连接"><a href="#bridge连接" class="headerlink" title="bridge连接"></a>bridge连接</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect my-bridge test2</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect bridge</span><br><span class="line">docker network inspect my-bridge</span><br></pre></td></tr></table></figure><p>我们可以看到bridge和my-bridge的container中都包含了test2</p><p>进入到test2容器中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it test2 /bin/sh</span><br></pre></td></tr></table></figure><p><img src="/img/in-post/2019-03-03/16.png" alt="avatar"></p><p>可以发现在test2容器中可以ping通test3但是不能ping test1, 实际上docker在用户自己创建的bridge中做了一层link，所以test2和test3容器可以相互ping 通对方</p><p>把test1也加入到my-bridge中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect my-bridge test1</span><br></pre></td></tr></table></figure><p><img src="/img/in-post/2019-03-03/17.png" alt="avatar"></p><p>此时test1也可以ping通了</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2021/03/02/2021-03-02-vagrant/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2021/03/02/2021-03-02-vagrant/" class="post-title-link" itemprop="url">Vagrant基本命令</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-03-02 21:30:00" itemprop="dateCreated datePublished" datetime="2021-03-02T21:30:00+08:00">2021-03-02</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-01-19 15:31:17" itemprop="dateModified" datetime="2023-01-19T15:31:17+08:00">2023-01-19</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="vagrant-使用"><a href="#vagrant-使用" class="headerlink" title="vagrant 使用"></a>vagrant 使用</h2><h2 id="init-centos"><a href="#init-centos" class="headerlink" title="init centos"></a>init centos</h2><p>centos7 box 下载地址<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1kVlAz59">centos7</a></p><p><strong>添加vagrant box到box list</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant box add centos7 Vagrant-CentOS-7.box</span><br></pre></td></tr></table></figure><p><strong>初始化一个虚拟机使用刚才添加的vagrant box</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> centos</span><br><span class="line"><span class="built_in">cd</span> centos</span><br><span class="line">vim Vagrantfile</span><br></pre></td></tr></table></figure><p><strong>添加下面内容到Vagrantfile中</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- mode: ruby -*-</span></span><br><span class="line"><span class="comment"># vi: set ft=ruby :</span></span><br><span class="line"></span><br><span class="line">Vagrant.require_version <span class="string">&quot;&gt;= 1.6.0&quot;</span></span><br><span class="line"></span><br><span class="line">boxes = [</span><br><span class="line">    &#123;</span><br><span class="line">        :name =&gt; <span class="string">&quot;docker-node1&quot;</span>,</span><br><span class="line">        :eth1 =&gt; <span class="string">&quot;192.168.205.10&quot;</span>,</span><br><span class="line">        :mem =&gt; <span class="string">&quot;1024&quot;</span>,</span><br><span class="line">        :cpu =&gt; <span class="string">&quot;1&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        :name =&gt; <span class="string">&quot;docker-node2&quot;</span>,</span><br><span class="line">        :eth1 =&gt; <span class="string">&quot;192.168.205.11&quot;</span>,</span><br><span class="line">        :mem =&gt; <span class="string">&quot;1024&quot;</span>,</span><br><span class="line">        :cpu =&gt; <span class="string">&quot;1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Vagrant.configure(2) <span class="keyword">do</span> |config|</span><br><span class="line"></span><br><span class="line">  config.vm.box = <span class="string">&quot;centos7&quot;</span></span><br><span class="line"></span><br><span class="line">  boxes.each <span class="keyword">do</span> |opts|</span><br><span class="line">      config.vm.define opts[:name] <span class="keyword">do</span> |config|</span><br><span class="line">        config.vm.hostname = opts[:name]</span><br><span class="line">        config.vm.provider <span class="string">&quot;vmware_fusion&quot;</span> <span class="keyword">do</span> |v|</span><br><span class="line">          v.vmx[<span class="string">&quot;memsize&quot;</span>] = opts[:mem]</span><br><span class="line">          v.vmx[<span class="string">&quot;numvcpus&quot;</span>] = opts[:cpu]</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        config.vm.provider <span class="string">&quot;virtualbox&quot;</span> <span class="keyword">do</span> |v|</span><br><span class="line">          v.customize [<span class="string">&quot;modifyvm&quot;</span>, :<span class="built_in">id</span>, <span class="string">&quot;--memory&quot;</span>, opts[:mem]]</span><br><span class="line">          v.customize [<span class="string">&quot;modifyvm&quot;</span>, :<span class="built_in">id</span>, <span class="string">&quot;--cpus&quot;</span>, opts[:cpu]]</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        config.vm.network :private_network, ip: opts[:eth1]</span><br><span class="line">      end</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  config.vm.provision <span class="string">&quot;shell&quot;</span>, privileged: <span class="literal">true</span>, path: <span class="string">&quot;./setup.sh&quot;</span></span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>install docker的setup.sh文件</strong></p><p>在当前目录创建setup.sh文件并添加如下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># install some tools</span></span><br><span class="line">sudo yum install -y git vim gcc glibc-static telnet bridge-utils</span><br><span class="line"></span><br><span class="line"><span class="comment"># install docker</span></span><br><span class="line">curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line">sh get-docker.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># start docker service</span></span><br><span class="line">sudo groupadd docker</span><br><span class="line">sudo usermod -aG docker vagrant</span><br><span class="line">sudo systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -rf get-docker.sh</span><br></pre></td></tr></table></figure><p><strong>启动安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant up</span><br></pre></td></tr></table></figure><h2 id="vagrant-报unknown-filesystem-type-‘vboxsf’-解决方案"><a href="#vagrant-报unknown-filesystem-type-‘vboxsf’-解决方案" class="headerlink" title="vagrant 报unknown filesystem type ‘vboxsf’ 解决方案"></a>vagrant 报unknown filesystem type ‘vboxsf’ 解决方案</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vagrant plugin install vagrant-vbguest</span><br><span class="line">vagrant destroy &amp;&amp; vagrant up</span><br></pre></td></tr></table></figure><h2 id="init-ubuntu"><a href="#init-ubuntu" class="headerlink" title="init ubuntu"></a>init ubuntu</h2><p>使用<a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-cloud-images/bionic/current/">清华源</a></p><p><strong>ubuntu18的box，终端运行如下命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vagrant box add \</span><br><span class="line">https://mirrors.tuna.tsinghua.edu.cn/ubuntu-cloud-images/bionic/current/bionic-server-cloudimg-amd64-vagrant.box \</span><br><span class="line">--name ubuntu/bionic</span><br></pre></td></tr></table></figure><p>Vagrantfile这样写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">config.vm.box = <span class="string">&quot;ubuntu/bionic&quot;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>接着就是<code>vagrant up &amp;&amp; vagrant ssh</code>了</p><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h3 id="列出所有Box"><a href="#列出所有Box" class="headerlink" title="列出所有Box"></a>列出所有Box</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant box list</span><br></pre></td></tr></table></figure><h3 id="添加一个Box"><a href="#添加一个Box" class="headerlink" title="添加一个Box"></a>添加一个Box</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant box add [options] &lt;name, url, or path</span><br></pre></td></tr></table></figure><h3 id="可以从https-app-vagrantup-com-boxes-search下载各种Vagrant映像文件"><a href="#可以从https-app-vagrantup-com-boxes-search下载各种Vagrant映像文件" class="headerlink" title="可以从https://app.vagrantup.com/boxes/search下载各种Vagrant映像文件"></a>可以从<a target="_blank" rel="noopener" href="https://app.vagrantup.com/boxes/search%E4%B8%8B%E8%BD%BD%E5%90%84%E7%A7%8DVagrant%E6%98%A0%E5%83%8F%E6%96%87%E4%BB%B6">https://app.vagrantup.com/boxes/search下载各种Vagrant映像文件</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant box add ubuntu/trusty64</span><br></pre></td></tr></table></figure><h3 id="通过指定的URL添加远程box"><a href="#通过指定的URL添加远程box" class="headerlink" title="通过指定的URL添加远程box"></a>通过指定的URL添加远程box</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant box add https://atlas.hashicorp.com/ubuntu/boxes/trusty64</span><br></pre></td></tr></table></figure><h3 id="添加一个本地box"><a href="#添加一个本地box" class="headerlink" title="添加一个本地box"></a>添加一个本地box</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant box add &#123;box_name&#125; &#123;file_path&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化一个新VM"><a href="#初始化一个新VM" class="headerlink" title="初始化一个新VM"></a>初始化一个新VM</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant init ubuntu/trustry64</span><br></pre></td></tr></table></figure><p>此命令会在当前目录创建一个名为Vagrantfile的配置文件，内容大致如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(<span class="string">&quot;2&quot;</span>) <span class="keyword">do</span> |config|</span><br><span class="line">  config.vm.box = <span class="string">&quot;ubuntu/trusty64&quot;</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="初始化一个新VM-1"><a href="#初始化一个新VM-1" class="headerlink" title="初始化一个新VM"></a>初始化一个新VM</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant up</span><br></pre></td></tr></table></figure><h3 id="启用SSH登陆VM"><a href="#启用SSH登陆VM" class="headerlink" title="启用SSH登陆VM"></a>启用SSH登陆VM</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant ssh &lt;node_name&gt;</span><br></pre></td></tr></table></figure><p>如果需要从虚拟机中退出，直接在虚拟机中的命令行输入exit命令即可</p><h3 id="查看VM当前的状态"><a href="#查看VM当前的状态" class="headerlink" title="查看VM当前的状态"></a>查看VM当前的状态</h3><p>进入Vagrantfile配置文件所在的目录，执行以下命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant status</span><br></pre></td></tr></table></figure><h3 id="关闭VM"><a href="#关闭VM" class="headerlink" title="关闭VM"></a>关闭VM</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant halt</span><br></pre></td></tr></table></figure><h3 id="销毁VM"><a href="#销毁VM" class="headerlink" title="销毁VM"></a>销毁VM</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant destory [name|<span class="built_in">id</span>]</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2021/03/02/2021-03-02-dockerfile/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2021/03/02/2021-03-02-dockerfile/" class="post-title-link" itemprop="url">Dockerfile 语法梳理</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-03-02 13:30:00" itemprop="dateCreated datePublished" datetime="2021-03-02T13:30:00+08:00">2021-03-02</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-01-19 15:31:17" itemprop="dateModified" datetime="2023-01-19T15:31:17+08:00">2023-01-19</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="Dockerfile语法梳理"><a href="#Dockerfile语法梳理" class="headerlink" title="Dockerfile语法梳理"></a>Dockerfile语法梳理</h2><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>from 后面接base image</p><p>eg:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">FROM</span> ubuntu</span><br></pre></td></tr></table></figure><blockquote><p>尽量使用官方的image 作为base image</p></blockquote><h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer=<span class="string">&quot;username@gmail.com&quot;</span> </span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> version=<span class="string">&quot;1.0&quot;</span> </span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> description=<span class="string">&quot;this is description&quot;</span> </span></span><br></pre></td></tr></table></figure><blockquote><p>MetaData 不可少</p></blockquote><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>执行命令并创建新的IMAGE LAYER</p><p>为了美观，复杂的RUN用反斜杠换行，避免无用分层，合并多条命令成一行。</p><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum update &amp;&amp; yum install -y vim \</span></span><br><span class="line"><span class="language-bash">python-dev</span></span><br></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y perl \</span></span><br><span class="line"><span class="language-bash">pwgen --no-install-recommends &amp;&amp; <span class="built_in">rm</span> -rf \</span></span><br><span class="line"><span class="language-bash">/var/lib/apt/lists/*     <span class="comment">#清理cache</span></span></span><br></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> /bin/bash -c <span class="string">&#x27;source $HOME/.bashrc;echo #HOME&#x27;</span></span></span><br></pre></td></tr></table></figure><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> <span class="built_in">test</span>       <span class="comment"># 如果没有会自动创建test文件夹</span></span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> demo</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">pwd</span>            <span class="comment"># 打印/test/demo</span></span></span><br></pre></td></tr></table></figure><blockquote><p>尽量使用WORKDIR,不要使用RUN cd,尽量使用绝对路径</p></blockquote><h3 id="ADD-and-COPY"><a href="#ADD-and-COPY" class="headerlink" title="ADD and COPY"></a>ADD and COPY</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="language-bash"> hello /</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> test.tar.gz / <span class="comment"># 添加到根目录并解压缩</span></span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> hello <span class="built_in">test</span> /    <span class="comment"># /root/test/hello</span></span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> hello <span class="built_in">test</span> /</span></span><br></pre></td></tr></table></figure><blockquote><p>大部分情况COPY优于，ADD有额外的解压功能，添加远程文件或目录用curl或wget</p></blockquote><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> MYSQL_VERSION <span class="number">5.6</span> <span class="comment">#常量</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y mysql-server= <span class="string">&quot;<span class="variable">$&#123;MYSQL_VERSION&#125;</span>&quot;</span> \</span></span><br><span class="line"><span class="language-bash">&amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br></pre></td></tr></table></figure><h3 id="CMD-amp-ENTRYPOINT"><a href="#CMD-amp-ENTRYPOINT" class="headerlink" title="CMD &amp; ENTRYPOINT"></a>CMD &amp; ENTRYPOINT</h3><p>CMD:设置容器启动后默认执行的命令和参数<br>如果docker run指定了其它的命令，则忽略CMD命令<br>定义多个CMD,只有最后一个会执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run &lt;image&gt;</span><br><span class="line">docker run -it &lt;image&gt; /bin/bash    //此命令会忽略CMD中的命令</span><br></pre></td></tr></table></figure><p>ENTRYPOINT:设置容器启动时运行的命令<br>让容器已应用程序或者服务的方式执行<br>不会被忽略，一定会执行</p><h4 id="SHELL-amp-EXEC"><a href="#SHELL-amp-EXEC" class="headerlink" title="SHELL &amp; EXEC"></a>SHELL &amp; EXEC</h4><p>SHELL:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y vim</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;hello docker&quot;</span></span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;hello docker&quot;</span></span></span><br></pre></td></tr></table></figure><p>EXEC:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [<span class="string">&quot;apt-get&quot;</span>, <span class="string">&quot;install&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;vim&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/bin/echo&quot;</span>, <span class="string">&quot;hello docker&quot;</span>]</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/bin/echo&quot;</span>, <span class="string">&quot;hello docker&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>EXEC方式需要指明运行环境，eg:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">ENV</span> name word</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;echo hello <span class="variable">$name</span>&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>更多详见<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/">扩展阅读</a></p><h2 id="Dockerfile实战"><a href="#Dockerfile实战" class="headerlink" title="Dockerfile实战"></a>Dockerfile实战</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> flask-hello-word</span><br><span class="line"><span class="built_in">cd</span> flask-hello-word</span><br><span class="line">vim app.py</span><br></pre></td></tr></table></figure><p>app.py内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello docker&quot;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, port=<span class="number">5000</span>)</span><br></pre></td></tr></table></figure><p>编写Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">2.7</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer=<span class="string">&quot;peng.shiliang&lt;1390509500@qq.com&gt;&quot;</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install flask</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.py /app/       <span class="comment"># app后面必须接/，否则会当作文件</span></span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">5000</span>             <span class="comment"># 端口映射,保证远程能够访问</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t pengshiliang/flask-hello-word .</span><br><span class="line">docker push pengshiliang/flask-hello-word:latest</span><br></pre></td></tr></table></figure><p>运行flask-hello-word</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name=demo pengshiliang/flask-hello-word     //--name 便于docker container 操作</span><br><span class="line">docker <span class="built_in">exec</span> -it demo ip a       //查看docker容器ip</span><br><span class="line">curl &lt;demo ip&gt;      //输出hello docker</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2021/03/02/2021-03-02-docker/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2021/03/02/2021-03-02-docker/" class="post-title-link" itemprop="url">Docker入门</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-03-02 10:30:00" itemprop="dateCreated datePublished" datetime="2021-03-02T10:30:00+08:00">2021-03-02</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-01-19 15:31:17" itemprop="dateModified" datetime="2023-01-19T15:31:17+08:00">2023-01-19</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="赋予docker权限"><a href="#赋予docker权限" class="headerlink" title="赋予docker权限"></a>赋予docker权限</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vagrant@ubuntu-bionic:~$ sudo groupadd docker</span><br><span class="line">groupadd: group <span class="string">&#x27;docker&#x27;</span> already exists</span><br><span class="line">vagrant@ubuntu-bionic:~$ sudo gpasswd -a vagrant docker</span><br><span class="line">Adding user vagrant to group docker</span><br><span class="line">vagrant@ubuntu-bionic:~$ sudo service docker restart</span><br></pre></td></tr></table></figure><p>退出vagrant在重新进入</p><h2 id="docker基本命令"><a href="#docker基本命令" class="headerlink" title="docker基本命令"></a>docker基本命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 列举所有镜像</span><br><span class="line">docker image <span class="built_in">ls</span></span><br><span class="line">// 查看image build 历史</span><br><span class="line">docker <span class="built_in">history</span> &lt;image <span class="built_in">id</span>&gt;</span><br><span class="line">// 运行一个image</span><br><span class="line">docker run &lt;image <span class="built_in">id</span>&gt;</span><br><span class="line">// 列举所有正在运行的容器</span><br><span class="line">docker container <span class="built_in">ls</span></span><br><span class="line">// 列举所有的容器</span><br><span class="line">docker container <span class="built_in">ls</span> -a</span><br><span class="line">// 交互式运行运行（常驻运行）</span><br><span class="line">docker run -it &lt;image&gt;</span><br></pre></td></tr></table></figure><h2 id="docker-image-命令"><a href="#docker-image-命令" class="headerlink" title="docker image 命令"></a>docker image 命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker images   (docker image <span class="built_in">ls</span>缩写)</span><br><span class="line">docker rmi &lt;image <span class="built_in">id</span>&gt;   (docker image <span class="built_in">rm</span> &lt;image <span class="built_in">id</span>&gt;缩写)//移除一个镜像</span><br></pre></td></tr></table></figure><h2 id="docker-container命令"><a href="#docker-container命令" class="headerlink" title="docker container命令"></a>docker container命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a    (docker container <span class="built_in">ls</span> -a缩写)</span><br><span class="line">docker <span class="built_in">rm</span> &lt;image <span class="built_in">id</span>&gt;    (docker container <span class="built_in">rm</span> &lt;image <span class="built_in">id</span>&gt;缩写)  //删除一个容器</span><br><span class="line">docker ps -aq   //列举所有容器<span class="built_in">id</span></span><br><span class="line">docker ps -f <span class="string">&quot;status=exited&quot;</span> -q     //列举所有已退出的容器</span><br><span class="line">docker <span class="built_in">rm</span> $(docker ps -aq)</span><br><span class="line">docker <span class="built_in">rm</span> $(docker ps -f <span class="string">&quot;status=exited&quot;</span> -q)</span><br></pre></td></tr></table></figure><p><img src="/img/in-post/2019-03-02/3.png" alt="avatar"><br><img src="/img/in-post/2019-03-02/4.png" alt="avatar"></p><h2 id="build一个hello-word-image"><a href="#build一个hello-word-image" class="headerlink" title="build一个hello word image"></a>build一个hello word image</h2><h3 id="生成hello-word程序"><a href="#生成hello-word程序" class="headerlink" title="生成hello-word程序"></a>生成hello-word程序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> hello-word</span><br><span class="line"><span class="built_in">cd</span> hello-word</span><br><span class="line">vim hello.c</span><br></pre></td></tr></table></figure><p>hello.c内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello word\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc</span><br><span class="line">sudo apt-get install build-essential</span><br><span class="line">gcc -static hello.c -o hello</span><br></pre></td></tr></table></figure><p><img src="/img/in-post/2019-03-02/1.png" alt="avatar"></p><h3 id="编写Dockerfile"><a href="#编写Dockerfile" class="headerlink" title="编写Dockerfile"></a>编写Dockerfile</h3><p>执行<code>vim Dockerfile</code></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> hello /</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/hello&quot;</span>]</span></span><br></pre></td></tr></table></figure><h3 id="build命令"><a href="#build命令" class="headerlink" title="build命令"></a>build命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t &lt;tag&gt; &lt;<span class="built_in">dir</span>&gt;</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t pengshiliang/hello-word .</span><br></pre></td></tr></table></figure><p><img src="/img/in-post/2019-03-02/2.png" alt="avatar"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run pengshiliang/hello-word</span><br></pre></td></tr></table></figure><p>出现hello word 即为正常build</p><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push pengshiliang/hello-word:latest</span><br></pre></td></tr></table></figure><h2 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h2><ol><li>通过image创建</li><li>在Image layer之上建立一个Cotainer layer</li><li>类面向对象：类和实例</li><li>image复制存储和分发，container负责运行app</li></ol></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2020/10/02/2020-01-10-redis-slave/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2020/10/02/2020-01-10-redis-slave/" class="post-title-link" itemprop="url">Redis高可用</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-10-02 13:30:00" itemprop="dateCreated datePublished" datetime="2020-10-02T13:30:00+08:00">2020-10-02</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-01-19 15:31:17" itemprop="dateModified" datetime="2023-01-19T15:31:17+08:00">2023-01-19</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="单机版Redis问题"><a href="#单机版Redis问题" class="headerlink" title="单机版Redis问题"></a>单机版Redis问题</h2><ul><li>机器故障需要做数据手动迁移</li><li>容量瓶颈</li><li>QPS瓶颈</li></ul><h2 id="引入正题"><a href="#引入正题" class="headerlink" title="引入正题"></a>引入正题</h2><p>前面列出的容量瓶颈和QPS瓶颈是redis分布式要解决的问题，本篇还是主要解决<br>redis怎么实现高可用，机器故障的问题</p><h2 id="主从复制介绍"><a href="#主从复制介绍" class="headerlink" title="主从复制介绍"></a>主从复制介绍</h2><p>作用：</p><ul><li>流量分流和负载均衡</li><li>提供多个数据分布</li><li>扩展redis读性能</li></ul><h3 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h3><ul><li>一个master可以有多个slave</li><li>一个slave只能有一个master</li><li>数据流向是单向的，master到slave</li></ul><h2 id="主从复制操作"><a href="#主从复制操作" class="headerlink" title="主从复制操作"></a>主从复制操作</h2><p>master节点:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp $&#123;redis_src&#125;/redis.conf redis-6379.conf</span><br><span class="line">vim redis-6379.conf</span><br></pre></td></tr></table></figure><p>改动项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis-6379.pid</span><br><span class="line">logfile &quot;6379.log&quot;</span><br><span class="line">logfile &quot;6379.log&quot;</span><br><span class="line">#save 900 1</span><br><span class="line">#save 300 10</span><br><span class="line">#save 60 10000</span><br><span class="line">dbfilename dump-6379.rdb</span><br><span class="line">dir /opt/soft/data</span><br></pre></td></tr></table></figure><p>slave节点:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp $&#123;redis_src&#125;/redis.conf redis-6380.conf</span><br><span class="line">vim redis-6380.conf</span><br></pre></td></tr></table></figure><p>改动项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis-6380.pid</span><br><span class="line">logfile &quot;6380.log&quot;</span><br><span class="line">logfile &quot;6380.log&quot;</span><br><span class="line">#save 900 1</span><br><span class="line">#save 300 10</span><br><span class="line">#save 60 10000</span><br><span class="line">dbfilename dump-6380.rdb</span><br><span class="line">dir /opt/soft/data</span><br><span class="line">salveof 127.0.0.1 6379  #master节点 ip port</span><br><span class="line">masterauth  #主节点设置密码时需要配置</span><br></pre></td></tr></table></figure><p>启动:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-server 6379.conf</span><br><span class="line">redis-server 6380.conf</span><br></pre></td></tr></table></figure><p>检查主从状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line">127.0.0.1:6379&gt; set hello world</span><br><span class="line">127.0.0.1:6380&gt; get hello</span><br></pre></td></tr></table></figure><h2 id="runid和复制偏移量"><a href="#runid和复制偏移量" class="headerlink" title="runid和复制偏移量"></a>runid和复制偏移量</h2><h3 id="runid"><a href="#runid" class="headerlink" title="runid"></a>runid</h3><p>redis每次启动后都会随机生成一个runid执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6379 info server |grep run</span><br><span class="line">redis-cli -p 6380 info server |grep run</span><br></pre></td></tr></table></figure><blockquote><p>redis每次重启runid会发生变化，redis从节点每次会检测主节点runid变化来进行一次全量复制</p></blockquote><h3 id="偏移量"><a href="#偏移量" class="headerlink" title="偏移量"></a>偏移量</h3><p>主节点和从节点都会记录执行一条命令时数据写入的字节数，当偏移量达到一致时，数据才会同步完成</p><h2 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h2><p><img src="/img/in-post/2018-01-10/1.png"></p><p><strong>全量复制开销</strong></p><ul><li>bgsave时间</li><li>RDB文件网络传输时间</li><li>从节点清空数据时间</li><li>从节点加载RDB时间</li><li>如果配置AOF开启会有AOF重写时间</li></ul><h2 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h2><p><img src="/img/in-post/2018-01-10/2.png"></p><h2 id="开发运维中的问题"><a href="#开发运维中的问题" class="headerlink" title="开发运维中的问题"></a>开发运维中的问题</h2><p><strong>规避全量复制：</strong></p><p>1：第一次全量复制</p><ul><li>问题：第一次不可避免</li><li>解决：小主节点，低峰</li></ul><p>2：节点运行ID不匹配</p><ul><li>问题：主节点重启runid变化</li><li>解决：故障转移，例如哨兵或集群</li></ul><p>3：复制积压缓冲区不足</p><ul><li>问题：网络中断，部分复制无法满足</li><li>解决：增大复制缓冲区配置rel_backlog_size</li></ul><p><strong>规避复制风暴：</strong></p><p>1：单主节点复制风暴</p><ul><li>问题：主节点重启，多从节点复制</li><li>解决：更换复制拓扑(树形架构)</li></ul><p>1：单机器复制风暴</p><ul><li>问题：机器宕机后，大量全量复制</li><li>解决：主节点分散多机器</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2020/10/01/2020-01-08-redis/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2020/10/01/2020-01-08-redis/" class="post-title-link" itemprop="url">Redis持久化</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-10-01 13:30:00" itemprop="dateCreated datePublished" datetime="2020-10-01T13:30:00+08:00">2020-10-01</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-01-19 15:31:17" itemprop="dateModified" datetime="2023-01-19T15:31:17+08:00">2023-01-19</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>话不多说直奔主题…</p><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><h3 id="主要触发机制"><a href="#主要触发机制" class="headerlink" title="主要触发机制"></a>主要触发机制</h3><h4 id="save"><a href="#save" class="headerlink" title="save"></a>save</h4><p><strong>cli命令:</strong> save</p><p><strong>文件策略：</strong> 如果存在老的RDB文件，新的将其替换掉</p><p><strong>时间复杂度：</strong> O(n)</p><p>我们把客户端和服务端用一个图来表示，save时会帮我们生成一个RDB文件<br><img src="/img/in-post/2019-01-08/1.png"></p><blockquote><p>由于它是同步命令，并且在单线程中执行,在数据量非常多的时候，此时执行save命令，他会将数据进行完整拷贝，可能会造成redis阻塞。</p></blockquote><h4 id="bgsave"><a href="#bgsave" class="headerlink" title="bgsave"></a>bgsave</h4><p><img src="/img/in-post/2019-01-08/2.png"></p><blockquote><p>通过在后台fork一个子进程完成复制</p></blockquote><h4 id="自动"><a href="#自动" class="headerlink" title="自动"></a>自动</h4><p>根据REDIS配置定时同步数据到RDB文件</p><table><tr><th>配置</th><th>Seconds</th><th>Changes</th></tr><tr><td>save</td><td>900</td><td>1</td></tr><tr><td>save</td><td>300</td><td>10</td></tr><tr><td>save</td><td>60</td><td>10000</td></tr></table><blockquote><p>eg:60秒中改变了10000次会发生备份RDB</p></blockquote><h4 id="触发机制-不容忽略的方式"><a href="#触发机制-不容忽略的方式" class="headerlink" title="触发机制-不容忽略的方式"></a>触发机制-不容忽略的方式</h4><ul><li>全量复制</li><li>Debug Reload</li><li>shutdown</li></ul><h3 id="save-or-bgsave"><a href="#save-or-bgsave" class="headerlink" title="save or bgsave ?"></a>save or bgsave ?</h3><table><tr><th>命令</th><th>save</th><th>bgsave</th></tr><tr><td>IO类型</td><td>同步</td><td>异步</td></tr><tr><td>阻塞</td><td>是</td><td>发生在fork时</td></tr><tr><td>复杂度</td><td>O(N)</td><td>O(N)</td></tr><tr><td>优点</td><td>不会消耗内存</td><td>不阻塞客户端命令</td></tr><tr><td>缺点</td><td>阻塞客户端命令</td><td>消耗内存</td></tr></table> ### 配置<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">dir ./</span><br><span class="line">stop-writes-on-bgsave-error yes //bgsave出现问题会停止写入</span><br><span class="line">rdbcompression yes  //压缩模式</span><br><span class="line">rdbchecksum yes //对RDB进行校验和检验</span><br></pre></td></tr></table></figure> #### 最佳配置<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dbfilename dump-$&#123;port&#125;.rdb</span><br><span class="line">dir bigdiskpath //选择大的硬盘</span><br><span class="line">stop-writes-on-bgsave-error yes //bgsave出现问题会停止写入</span><br><span class="line">rdbcompression yes  //压缩模式</span><br><span class="line">rdbchecksum yes //对RDB进行校验和检验</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>RDB是Redis内存到硬盘的快照，用于持久化</li><li>save通常会阻塞Redis</li><li>bgsave不会阻塞Redis，但是会fork子进程</li><li>save自动配置满足其一就会被执行</li><li>有些触发机制不容忽视</li></ul><h3 id="RDB问题"><a href="#RDB问题" class="headerlink" title="RDB问题"></a>RDB问题</h3><p><strong>耗时耗性能</strong></p><blockquote><p>O(N)数据耗时<br><br>fork耗内存<br><br>Disk I&#x2F;O:IO性能</p></blockquote><p><strong>不可控丢失数据</strong></p><table><tr><th>时间戳</th><th>save</th></tr><tr><td>T1</td><td>执行多个命令</td></tr><tr><td>T2</td><td>满足RDB自动创建条件</td></tr><tr><td>T3</td><td>再次执行多条命令</td></tr><tr><td>T4</td><td>宕机</td></tr></table><blockquote><p>宕机会发生数据丢失</p></blockquote><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><h3 id="三种策略"><a href="#三种策略" class="headerlink" title="三种策略"></a>三种策略</h3><h4 id="everysec"><a href="#everysec" class="headerlink" title="everysec"></a>everysec</h4><p><img src="/img/in-post/2019-01-08/4.png"></p><h4 id="always"><a href="#always" class="headerlink" title="always"></a>always</h4><p>同everysec流程，只不过always会把每条命令都写入到AOF文件中</p><h4 id="no"><a href="#no" class="headerlink" title="no"></a>no</h4><p>由操作系统来决定是否刷新</p><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><table><tr><th>命令</th><th>always</th><th>everysec</th><th>no</th></tr><tr><td>优点</td><td>不丢失数据</td><td>每秒一次fsync丢1秒数据</td><td>不用管理</td></tr><tr><td>缺点</td><td>IO开销比较大</td><td>丢1秒数据</td><td>不可控</td></tr></table> ### AOF重写<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li>减少硬盘占用量</li><li>加快回复速度</li></ul><h3 id="重写两种方式"><a href="#重写两种方式" class="headerlink" title="重写两种方式"></a>重写两种方式</h3><h4 id="bgrewriteaof"><a href="#bgrewriteaof" class="headerlink" title="bgrewriteaof"></a>bgrewriteaof</h4><p><strong>命令：bgrewriteaof</strong></p><p><img src="/img/in-post/2019-01-08/6.png"></p><p><strong>重写配置</strong></p><table><tr><th>配置名</th><th>含义</th></tr><tr><td>auto-aof-rewirte-min-size</td><td>auto-aof-rewirte-percentage</td></tr><tr><td>AOF文件重写尺寸</td><td>AOF文件增长率</td></tr></table> **统计**<table><tr><th>统计名</th><th>含义</th></tr><tr><td>auto-current-size</td><td>auto-base-size</td></tr><tr><td>AOF当前尺寸</td><td>AOF上次启动和重写的尺寸</td></tr></table> #### 自动触发时机<ul><li>auto-current-size &gt; auto-aof-rewirte-min-size</li><li>(auto-current-size - auto-base-size) &#x2F; auto-base-size &gt; auto-aof-rewirte-percentage</li></ul><h3 id="AOF重写流程"><a href="#AOF重写流程" class="headerlink" title="AOF重写流程"></a>AOF重写流程</h3><p><img src="/img/in-post/2019-01-08/8.jpg"></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul><li>appendonly yes</li><li>appendfilename “appendonly-${port}.aof”</li><li>appendfsync everysec</li><li>dir &#x2F;bigdisk</li><li>no-appendfsync-on-rewrite no &#x2F;&#x2F;aof重写失败是否允许丢失数据</li><li>auto-aof-rewrite-percentage 100 &#x2F;&#x2F;增长率</li><li>auto-aof-rewrite-min-size 64mb &#x2F;&#x2F;最小尺寸</li></ul><h2 id="RDB-和-AOF-抉择"><a href="#RDB-和-AOF-抉择" class="headerlink" title="RDB 和 AOF 抉择"></a>RDB 和 AOF 抉择</h2><table><tr><th>命令</th><th>RDB</th><th>AOF</th></tr><tr><td>启动优先级</td><td>低</td><td>高</td></tr><tr><td>体积</td><td>小</td><td>大</td></tr><tr><td>恢复速度</td><td>快</td><td>慢</td></tr><tr><td>数据安全性</td><td>丢数据</td><td>根据策略决定</td></tr><tr><td>轻重</td><td>重</td><td>轻</td></tr></table></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2020/01/25/2020-01-25-redis-cluster-out/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2020/01/25/2020-01-25-redis-cluster-out/" class="post-title-link" itemprop="url">Redis cluster 故障转移</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-01-25 21:30:00" itemprop="dateCreated datePublished" datetime="2020-01-25T21:30:00+08:00">2020-01-25</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-01-19 15:31:17" itemprop="dateModified" datetime="2023-01-19T15:31:17+08:00">2023-01-19</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="故障发现"><a href="#故障发现" class="headerlink" title="故障发现"></a>故障发现</h2><p>通过ping&#x2F;pong消息实现故障发现，不依赖sentinel</p><h2 id="主观下线"><a href="#主观下线" class="headerlink" title="主观下线"></a>主观下线</h2><p>定义：某个节点认为另外一个节点不可用“偏见”</p><p>主观下线流程：<br><img src="/img/in-post/2019-01-25/1.png"></p><h2 id="客观下线"><a href="#客观下线" class="headerlink" title="客观下线"></a>客观下线</h2><p>定义：当半数以上持有槽的主节点都标记某节点主观下线</p><p>客观下线流程：<br><img src="/img/in-post/2019-01-25/2.png"></p><h2 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h2><h3 id="资格检查"><a href="#资格检查" class="headerlink" title="资格检查"></a>资格检查</h3><ul><li>每个从节点检查与故障节点的断线时间</li><li>超过cluster-node-timeout*cluster-slave-validity-factor取消资格</li><li>cluster-slave-validity-factor：默认为10</li></ul><h3 id="准备选举时间"><a href="#准备选举时间" class="headerlink" title="准备选举时间"></a>准备选举时间</h3><p><img src="/img/in-post/2019-01-25/3.png"></p><h3 id="选举投票"><a href="#选举投票" class="headerlink" title="选举投票"></a>选举投票</h3><p><img src="/img/in-post/2019-01-25/4.png"></p><h3 id="替换主节点"><a href="#替换主节点" class="headerlink" title="替换主节点"></a>替换主节点</h3><ul><li>当前从节点复制变为主节点。(slaveof no one)</li><li>执行clusterDelSlot撤销故障主节点负责的槽，并执行clusterAddSlot<br>把这些槽分配给自己</li><li>向群广播自己的pong消息，表明已替换了故障从节点</li></ul><h2 id="redis-cluster-开发常见问题"><a href="#redis-cluster-开发常见问题" class="headerlink" title="redis cluster 开发常见问题"></a>redis cluster 开发常见问题</h2><h3 id="集群完整性"><a href="#集群完整性" class="headerlink" title="集群完整性"></a>集群完整性</h3><p><code>cluster-require-full-coverage</code>默认为yes<br>问题：</p><ul><li>集群中16384个槽全部可用，保证完整性</li><li>节点故障转移或正在转移<br>大多数业务无法容忍，建议设置为no<blockquote><p>当其中一台机器发生故障，此时集群状态不可用，不可以set ket,不建议设置为yes</p></blockquote></li></ul><h3 id="宽带消耗"><a href="#宽带消耗" class="headerlink" title="宽带消耗"></a>宽带消耗</h3><p>官方建议：1000个节点</p><ul><li>消息频率 节点发现和节点最后通信时间超过cluster-node-timeout&#x2F;2时会发送ping消息</li><li>消息数据量 slots数据组(2k)和整个集群1&#x2F;10的状态数据(10个节点状态数据约1k)</li><li>节点部署机器规模 分布机器越多且每台机器划分的节点越均匀，整体的可用带宽越高<br>例子：200个节点，20个物理机器（每台10个节点）</li></ul><p>cluster-node-timeout&#x3D;15000 ping&#x2F;pong带宽约25MB</p><p>cluster-node-timeout&#x3D;20000 ping&#x2F;pong带低于15MB</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li>避免多业务使用多集群，大业务可以多集群</li><li>cluster-node-timeout 带宽和故障转移速度的均衡</li><li>尽量均匀分配多个机器，保证带宽</li></ul><h3 id="PUB-x2F-SUB广播"><a href="#PUB-x2F-SUB广播" class="headerlink" title="PUB&#x2F;SUB广播"></a>PUB&#x2F;SUB广播</h3><p>问题：publish在集群每个节点广播：加重带宽<br>解决：单独走一套redis sentinel</p><h3 id="数据倾斜"><a href="#数据倾斜" class="headerlink" title="数据倾斜"></a>数据倾斜</h3><p><strong>数据倾斜：内存不均匀</strong></p><p><strong>节点和槽分配不均匀</strong></p><p><strong>不同槽对应键值数差异大</strong></p><ul><li>可能存在has_tag</li><li>cluster countkeysinslot {slot}获取槽对应键值个数</li></ul><p><strong>包含bigkey</strong></p><ul><li>例如大字符串，几百万元素的hash,set等</li><li>从节点，redis-cli –bigkeys</li><li>优化数据结构，拆分key</li></ul><p><strong>内存相关配置不一致</strong></p><ul><li>hash-max-ziplist-value, set-max-intset-entries等</li></ul><p><strong>请求倾斜：key热点</strong>重要的key或者bigkey<br>优化：</p><ul><li>避免big_key</li><li>热键不要使用hash_tag（避免落在一个节点）</li><li>当一致性不高时可以使用本地缓存+MQ</li></ul><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>只读连接：集群模式的从节点不接受任何读写请求</p><ul><li>重定向到负责槽的主节点</li><li>readonly命令可以读：连接级的命令<br>读写分离：更加复杂</li><li>复制延迟，从节点故障，读取过期数据</li><li>修改客户端：cluster slaves {nodeid}</li></ul><h3 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h3><p>官方工具：redis-trib.rb import</p><ul><li>只能从单机迁移到集群</li><li>不支持在线迁移，source需要停写</li><li>不支持断点续传</li><li>单线程迁移，影响速度<br>在线迁移：</li></ul><p>唯品会：redis-migrate-tool</p><p>豌豆荚：redis-port</p><h3 id="集群VS单机"><a href="#集群VS单机" class="headerlink" title="集群VS单机"></a>集群VS单机</h3><p>集群限制<br></p><ul><li>key批量操作限制</li><li>key事物和lua支持有限，操作的key必须在同一个节点</li><li>key是数据分区的最小粒度：不支持bigkey分区</li><li>不支持多个数据库：集群模式下只有一个db0</li><li>复制只支持一层，不支持树形</li></ul><ol><li>Redis Cluster: 满足容量和性能的扩展性：很多业务不需要</li><li>很多场景Redis Sentinel足够好</li></ol></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2020/01/24/2020-01-24-redis-cluster-route/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2020/01/24/2020-01-24-redis-cluster-route/" class="post-title-link" itemprop="url">Redis cluster 客户端路由</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-01-24 21:30:00" itemprop="dateCreated datePublished" datetime="2020-01-24T21:30:00+08:00">2020-01-24</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-01-19 15:31:17" itemprop="dateModified" datetime="2023-01-19T15:31:17+08:00">2023-01-19</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="MOVED重定向"><a href="#MOVED重定向" class="headerlink" title="MOVED重定向"></a>MOVED重定向</h2><p><img src="/img/in-post/2019-01-24/1.png"></p><h3 id="槽命中：直接返回"><a href="#槽命中：直接返回" class="headerlink" title="槽命中：直接返回"></a>槽命中：直接返回</h3><p><img src="/img/in-post/2019-01-24/2.png"></p><p>算出key的slot值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;127.0.0.1&gt; 6379 cluster keyslot hello</span><br></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(integer) 866</span><br></pre></td></tr></table></figure><h3 id="槽不命中：moved异常"><a href="#槽不命中：moved异常" class="headerlink" title="槽不命中：moved异常"></a>槽不命中：moved异常</h3><p>算出key的slot值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;127.0.0.1&gt; 6379 cluster keyslot php</span><br></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(integer) 9244</span><br></pre></td></tr></table></figure><p><img src="/img/in-post/2019-01-24/3.png"></p><p>看一个小例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -c -p 7000    //集群模式</span><br><span class="line">127.0.0.1:7000&gt; cluster keyslot hello</span><br><span class="line">(integer) 866</span><br><span class="line">127.0.0.1:7000&gt; set hello word</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7000&gt; cluster keyslot php</span><br><span class="line">(integer) 9244</span><br><span class="line">127.0.0.1:7000&gt; set php best</span><br><span class="line">-&gt; Redirected to slot [9244] located at 127.0.0.1:7001</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7001&gt; get php</span><br><span class="line">&quot;best&quot;</span><br><span class="line">127.0.0.1:7001&gt; </span><br><span class="line">redis-cli -p 7000</span><br><span class="line">127.0.0.1:7000&gt; cluster keyslot php</span><br><span class="line">(integer) 9244</span><br><span class="line">127.0.0.1:7000&gt; set php best</span><br><span class="line">(error) MOVED 9244 127.0.0.1:7001</span><br><span class="line">127.0.0.1:7000&gt;</span><br></pre></td></tr></table></figure><p><img src="/img/in-post/2019-01-24/4.png"></p><h2 id="ASK重定向"><a href="#ASK重定向" class="headerlink" title="ASK重定向"></a>ASK重定向</h2><p><img src="/img/in-post/2019-01-24/5.png"></p><p>在集群缩容扩容的时候，要对槽进行迁移，槽迁移过程中要遍历进行migrate,迁移时间比较长，<br>此时在此过程中访问一个key,但是key已经迁移到目标节点，就需要一个新的方案来解决这个问题，redis cluster 对这个问题已经有解决方案</p><p>我们来看它的一个实现演示：<br><img src="/img/in-post/2019-01-24/6.png"></p><h2 id="moved-amp-ask"><a href="#moved-amp-ask" class="headerlink" title="moved &amp; ask"></a>moved &amp; ask</h2><ul><li>两者都是客户端重定向</li><li>moved:槽已确定迁移</li><li>ask:槽还在迁移中</li></ul><h2 id="smart客户端"><a href="#smart客户端" class="headerlink" title="smart客户端"></a>smart客户端</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>追求性能：</p><ol><li>从集群中选一个可运行的节点，使用cluster slots 初始化槽和节点映射</li><li>将cluster slots结果映射到本地，为每个节点创建redisPool</li><li>执行命令</li></ol><p>基本流程：<br><img src="/img/in-post/2019-01-24/7.png"></p><blockquote><p>关于redis cluster 客户端使用可参考<br><a target="_blank" rel="noopener" href="https://github.com/enpsl/redis-go-cluster/tree/master/example">redis-go-cluster</a></p></blockquote><h3 id="批量操作优化"><a href="#批量操作优化" class="headerlink" title="批量操作优化"></a>批量操作优化</h3><p><strong>批量操作怎么实现?meget meset必须在一个槽</strong></p><h4 id="串行mget"><a href="#串行mget" class="headerlink" title="串行mget"></a>串行mget</h4><p><img src="/img/in-post/2019-01-24/8.png"></p><h4 id="串行IO"><a href="#串行IO" class="headerlink" title="串行IO"></a>串行IO</h4><p><img src="/img/in-post/2019-01-24/9.png"></p><h4 id="并行IO"><a href="#并行IO" class="headerlink" title="并行IO"></a>并行IO</h4><p><img src="/img/in-post/2019-01-24/10.png"></p><h4 id="hash-tag"><a href="#hash-tag" class="headerlink" title="hash_tag"></a>hash_tag</h4><p><img src="/img/in-post/2019-01-24/11.png"></p><h3 id="四种方案优缺点对比"><a href="#四种方案优缺点对比" class="headerlink" title="四种方案优缺点对比"></a>四种方案优缺点对比</h3><table><tr><td>方案</td><td>优点</td><td>缺点</td><td>网络IO</td></tr><tr><td>串行mget</td><td>编程简单，少量keys满足需求</td><td>大量keys请求延迟严重</td><td>O(keys)</td></tr><tr><td>串行IO</td><td>编程简单，少量节点满足需求</td><td>大量node延迟严重</td><td>O(nodes)</td></tr><tr><td>并行IO</td><td>利用并行特性，延迟取决于最慢的节点</td><td>编程复杂，超市定位问题难</td><td>O(max(node))</td></tr><tr><td>hash_tag</td><td>性能最高</td><td>读写增加tag维护成本，tag分布易出现数据倾斜</td><td>O(1))</td></tr></table></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2020/01/23/2020-01-23-redis-cluster-operator/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2020/01/23/2020-01-23-redis-cluster-operator/" class="post-title-link" itemprop="url">Redis cluster 伸缩</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-01-23 22:30:00" itemprop="dateCreated datePublished" datetime="2020-01-23T22:30:00+08:00">2020-01-23</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-01-19 15:31:17" itemprop="dateModified" datetime="2023-01-19T15:31:17+08:00">2023-01-19</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="集群伸缩原理"><a href="#集群伸缩原理" class="headerlink" title="集群伸缩原理"></a>集群伸缩原理</h2><p><img src="/img/in-post/2019-01-23/1.png"><br><img src="/img/in-post/2019-01-23/2.png"></p><center style="font-weight:700">集群伸缩=槽和数据在节点之间的移动</center><h2 id="扩容集群"><a href="#扩容集群" class="headerlink" title="扩容集群"></a>扩容集群</h2><h3 id="准备新节点"><a href="#准备新节点" class="headerlink" title="准备新节点"></a>准备新节点</h3><p>新节点：</p><ul><li>集群模式</li><li>配置和其它节点统一</li><li>启动后仍是孤儿节点</li></ul><p><img src="/img/in-post/2019-01-23/3.png"></p><h3 id="加入集群"><a href="#加入集群" class="headerlink" title="加入集群"></a>加入集群</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cluster meet 127.0.0.1 6385</span><br><span class="line">cluster meet 127.0.0.1 6386</span><br></pre></td></tr></table></figure><p><img src="/img/in-post/2019-01-23/4.png"></p><center style="font-weight:700">加入后的效果</center><p>加入集群的作用：</p><ul><li>为它迁移槽和数据实现扩容</li><li>作为从节点负责故障转移</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster add-node new_host:new_port existing_host:existing_port --cluster-slave --cluster-master-id &lt;arg&gt;</span><br></pre></td></tr></table></figure><blockquote><p>建议使用redis-trib.rb能够避免新节点已经加入了其它集群，造成故障</p></blockquote><h3 id="迁移槽和数据"><a href="#迁移槽和数据" class="headerlink" title="迁移槽和数据"></a>迁移槽和数据</h3><h4 id="槽迁移计划"><a href="#槽迁移计划" class="headerlink" title="槽迁移计划:"></a>槽迁移计划:</h4><p><img src="/img/in-post/2019-01-23/6.png"><br><img src="/img/in-post/2019-01-23/7.png"></p><h4 id="迁移数据："><a href="#迁移数据：" class="headerlink" title="迁移数据："></a>迁移数据：</h4><ol><li>对目标节点发送: cluster setslot{slot} importing {sourceNodeId}命令，让目标节点准备导入槽的数据。</li><li>对源节点发送: cluster setslot{slot} migrating {targetNodeId}命令，让源节点准备迁出槽的数据。</li><li>源节点循环执行: cluster getkeysinslot{slot}{count}命令，每次获取count个属于槽的键。</li><li>在源节点执行: migrate {targetIP}{targetPort} key 0 {timeout}命令把指定key迁移。</li><li>重复执行3-4直到槽下所有数据节点均迁移到目标节点。</li><li>向集群内所有主节点发送cluster setslot{slot} node {targetNodeId}命令，通知槽分配给目标节点。</li></ol><h4 id="数据迁移伪python代码"><a href="#数据迁移伪python代码" class="headerlink" title="数据迁移伪python代码:"></a>数据迁移伪python代码:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">move_slot</span>(<span class="params">source,target,slot</span>):</span><br><span class="line">    <span class="comment">#目标节点准备导入槽slot</span></span><br><span class="line">    target.cluster(<span class="string">&quot;setslot&quot;</span>,slot,<span class="string">&quot;importing&quot;</span>,source.nodeID)</span><br><span class="line">    <span class="comment">#目标节点准备全出槽slot</span></span><br><span class="line">    target.cluster(<span class="string">&quot;setslot&quot;</span>,slot,<span class="string">&quot;migrating&quot;</span>,source.nodeID) </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment">#批量从源节点获取键</span></span><br><span class="line">        keys = source.cluster(<span class="string">&quot;getkeysinslot&quot;</span>,slot,pipeline_size)</span><br><span class="line">        <span class="keyword">if</span> keys.length ==<span class="number">0</span>:</span><br><span class="line">            <span class="comment">#键列表为空时，退出循环</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="comment">#批量迁移键到目标节点</span></span><br><span class="line">    source.call(<span class="string">&quot;migrate&quot;</span>,target.host,target.port,<span class="string">&quot;&quot;</span>,timeout,<span class="string">&quot;keys&quot;</span>)</span><br><span class="line">    <span class="comment">#向集群所有主节点通知槽slot被分配给目标节点</span></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">        <span class="keyword">if</span> node.flag ==<span class="string">&quot;slave&quot;</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        node.cluster(<span class="string">&quot;setslot&quot;</span>,slot,<span class="string">&quot;node&quot;</span>,target.nodeID)</span><br></pre></td></tr></table></figure><h4 id="pipline迁移"><a href="#pipline迁移" class="headerlink" title="pipline迁移"></a>pipline迁移</h4><p><img src="/img/in-post/2019-01-23/8.png"></p><blockquote><p>3.0.6 版本pipline数据迁移会有丢失数据bug，在3.2.8已解决</p></blockquote><h2 id="扩容演示"><a href="#扩容演示" class="headerlink" title="扩容演示"></a>扩容演示</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p><img src="/img/in-post/2019-01-23/9.png"><br>当前集群是三主三从结构，此时我们加入两个新节点7006,7007。7007是7006的从节点，我们需要从7001,7002节点把一部分数据迁移给7006。<br>配置准备:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/7000/7006/g&#x27;</span> redis-7000.conf &gt; redis-7006.conf</span><br><span class="line">sed <span class="string">&#x27;s/7000/7007/g&#x27;</span> redis-7000.conf &gt; redis-7007.conf</span><br></pre></td></tr></table></figure><h3 id="meet"><a href="#meet" class="headerlink" title="meet:"></a>meet:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 7000 cluster meet 127.0.0.1 7006</span><br><span class="line">redis-cli -p 7000 cluster meet 127.0.0.1 7007</span><br></pre></td></tr></table></figure><h3 id="replicate"><a href="#replicate" class="headerlink" title="replicate:"></a>replicate:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 7007 cluster replicate d57d27051ce9db7752f894394b621368f9e0a058</span><br></pre></td></tr></table></figure><p><img src="/img/in-post/2019-01-23/10.png"></p><blockquote><p>此时7007已经属于7006的从节点</p></blockquote><h3 id="迁移数据：-1"><a href="#迁移数据：-1" class="headerlink" title="迁移数据："></a>迁移数据：</h3><blockquote><p>由于槽数量比较多，所以这里使用redis-trib来迁移</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster reshard 127.0.0.1 7000</span><br></pre></td></tr></table></figure><p><img src="/img/in-post/2019-01-23/11.png"><br>此时给我们提示出了当前集群的信息，由于我们现在是4个主节点，所以需要分成四等份来支持向master写入数据<br><img src="/img/in-post/2019-01-23/12.png"><br><img src="/img/in-post/2019-01-23/13.png"></p><p>槽迁移后的信息：<br><img src="/img/in-post/2019-01-23/14.png"></p><h2 id="收缩集群"><a href="#收缩集群" class="headerlink" title="收缩集群"></a>收缩集群</h2><h3 id="下线迁移槽"><a href="#下线迁移槽" class="headerlink" title="下线迁移槽"></a>下线迁移槽</h3><p><img src="/img/in-post/2019-01-23/15.png"></p><h3 id="忘记节点"><a href="#忘记节点" class="headerlink" title="忘记节点"></a>忘记节点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli&gt;cluster forget &#123;downNodeId&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/in-post/2019-01-23/16.png"></p><h3 id="关闭节点"><a href="#关闭节点" class="headerlink" title="关闭节点"></a>关闭节点</h3><h2 id="收缩集群演示"><a href="#收缩集群演示" class="headerlink" title="收缩集群演示"></a>收缩集群演示</h2><p>例：下线7006，7007</p><h3 id="迁移槽："><a href="#迁移槽：" class="headerlink" title="迁移槽："></a>迁移槽：</h3><p>迁移过程命令：</p><p>redis-cli –cluster reshard –cluster-from {7006nodeid} –cluster-to 7000{7000nodeid} –cluster-slots {slot num} 127.0.0.1:7006</p><p>redis-cli –cluster reshard –cluster-from {7006nodeid} –cluster-to 7001{7001nodeid} –cluster-slots {slot num} 127.0.0.1:7006</p><p>redis-cli –cluster reshard –cluster-from {7006nodeid} –cluster-to 7002{7002nodeid} –cluster-slots {slot num} 127.0.0.1:7006</p><p>迁移到7000示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster reshard --cluster-from d57d27051ce9db7752f894394b621368f9e0a058 --cluster-to 092fd7c3cf19693eddec5c0fae9894d681023ce5 --cluster-slots 1365 127.0.0.1:7006</span><br></pre></td></tr></table></figure><p>之后选择yes即可</p><p><img src="/img/in-post/2019-01-23/17.png"><br>可观察出0-1364的槽节点以迁移完毕，重复上述步骤，迁移剩余的槽</p><p>迁移后：<br><img src="/img/in-post/2019-01-23/18.png"></p><h3 id="忘记节点："><a href="#忘记节点：" class="headerlink" title="忘记节点："></a>忘记节点：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster del-node 127.0.0.1:7000 d57d27051ce9db7752f894394b621368f9e0a058</span><br></pre></td></tr></table></figure><blockquote><p>需要先下线从节点在下线主节点，否则会发生故障转移</p></blockquote><h3 id="完成缩容"><a href="#完成缩容" class="headerlink" title="完成缩容"></a>完成缩容</h3><p><img src="/img/in-post/2019-01-23/19.png"></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2020/01/20/2020-01-20-redis-cluster/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2020/01/20/2020-01-20-redis-cluster/" class="post-title-link" itemprop="url">Redis cluster</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-01-20 22:30:00" itemprop="dateCreated datePublished" datetime="2020-01-20T22:30:00+08:00">2020-01-20</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-01-19 15:31:17" itemprop="dateModified" datetime="2023-01-19T15:31:17+08:00">2023-01-19</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="呼唤集群"><a href="#呼唤集群" class="headerlink" title="呼唤集群"></a>呼唤集群</h2><p>当系统应用需要有更大容量和QPS的支撑，此时就需要采用的集群的方式，也可以简单理解为加机器</p><p>数据分区:</p><p><img src="/img/in-post/2019-01-20/1.jpg"></p><h2 id="分布方式"><a href="#分布方式" class="headerlink" title="分布方式"></a>分布方式</h2><h3 id="顺序分布"><a href="#顺序分布" class="headerlink" title="顺序分布"></a>顺序分布</h3><p><img src="/img/in-post/2019-01-20/2.png"></p><h3 id="哈希分布"><a href="#哈希分布" class="headerlink" title="哈希分布"></a>哈希分布</h3><p><img src="/img/in-post/2019-01-20/3.png"></p><ul><li>节点取余</li><li>一致性hash</li><li>虚拟槽分区</li></ul><h4 id="节点取余"><a href="#节点取余" class="headerlink" title="节点取余"></a>节点取余</h4><p><img src="/img/in-post/2019-01-20/3.png"></p><ul><li>客户端分片: 哈希+取余</li><li>节点伸缩: 数据节点关系变化，导致数据迁移</li><li>迁移数量和添加节点数量相关：建议翻倍扩容</li></ul><h4 id="一致性hash"><a href="#一致性hash" class="headerlink" title="一致性hash"></a>一致性hash</h4><p><img src="/img/in-post/2019-01-20/5.png"></p><p>一致性hash扩容</p><p><img src="/img/in-post/2019-01-20/4.png"></p><ul><li>客户端分片：哈希+顺时针（优化取余）</li><li>节点伸缩：只影响临近节点，但是还是有数据迁移</li><li>翻倍伸缩：保证最小迁移数据和负载均衡</li></ul><h4 id="虚拟槽分布"><a href="#虚拟槽分布" class="headerlink" title="虚拟槽分布"></a>虚拟槽分布</h4><p><img src="/img/in-post/2019-01-20/2.jpg"></p><ul><li>预设虚拟槽：每个槽映射一个数据子集，一般比节点数大</li><li>良好的hash函数：如crc16</li><li>服务端管理节点，槽，数据：例如redis cluster</li></ul><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><table><tr><th>分布方式</th><th>特点</th><th>典型产品</th></tr><tr><td>哈希分布</td><td>数据分散度高<br>key,value分布业务无关<br>无法顺序访问<br>支持批量操作</td><td>一致性hash memcache<br>redis cluster<br>其它缓存产品</td></tr><tr><td>顺序分布</td><td>数据分散度易倾斜<br>key,value业务相关<br>可顺序访问<br>支持批量操作</td><td>BigTable<br>HBase<br></td></tr></table> ## Redis Cluster<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><ul><li>节点</li><li>meet</li><li>指派槽</li><li>复制</li></ul><h3 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h3><ul><li>复制</li><li>分片</li><li>高可用</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="原生安装"><a href="#原生安装" class="headerlink" title="原生安装"></a>原生安装</h4><p>1: 配置开启节点:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">port&#123;$port&#125;</span><br><span class="line">daemonize yes</span><br><span class="line">dir &quot;$&#123;redis-src&#125;/data/&quot;</span><br><span class="line">dbfilename &quot;dump-&#123;$port&#125;.rdb&quot;</span><br><span class="line">logfile &quot;&#123;$port&#125;.log&quot;</span><br><span class="line">cluster-enabled &quot;yes</span><br><span class="line">cluster-config-file nodes-&#123;$port&#125;.conf</span><br></pre></td></tr></table></figure><p><img src="/img/in-post/2019-01-20/6.png"></p><p>批量生成配置文件:</p><p><img src="/img/in-post/2019-01-20/7.png"></p><p>执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis-7000.conf</span><br><span class="line">redis-server redis-7001.conf</span><br><span class="line">redis-server redis-7002.conf</span><br><span class="line">redis-server redis-7003.conf</span><br><span class="line">redis-server redis-7004.conf</span><br><span class="line">redis-server redis-7005.conf</span><br></pre></td></tr></table></figure><p><img src="/img/in-post/2019-01-20/8.png"></p><p>2: meet</p><p><strong>cluster meet ip port</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 7000 cluster meet 127.0.0.1 7001</span><br><span class="line">redis-cli -h 127.0.0.1 -p 7000 cluster meet 127.0.0.1 7002</span><br><span class="line">redis-cli -h 127.0.0.1 -p 7000 cluster meet 127.0.0.1 7003</span><br><span class="line">redis-cli -h 127.0.0.1 -p 7000 cluster meet 127.0.0.1 7004</span><br><span class="line">redis-cli -h 127.0.0.1 -p 7000 cluster meet 127.0.0.1 7005</span><br></pre></td></tr></table></figure><p>先进行7000和7001的握手</p><p><img src="/img/in-post/2019-01-20/9.png"></p><p>发现7000和7001已经完成握手，继续meet其他的节点</p><p><img src="/img/in-post/2019-01-20/10.png"></p><p>此时执行<code>cluster nodes</code>和<code>cluster info</code>均发现6个节点相互关联，证明已经握手成功</p><p>3: 指派槽</p><p><strong>cluster addslots slot [slot…]</strong></p><p>由于一共要分配16384个槽，所以需要借助脚本去分配槽</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">start=<span class="variable">$1</span></span><br><span class="line">end=<span class="variable">$2</span></span><br><span class="line">port=<span class="variable">$3</span></span><br><span class="line"><span class="keyword">for</span> slot <span class="keyword">in</span> `<span class="built_in">seq</span> <span class="variable">$&#123;start&#125;</span> <span class="variable">$&#123;end&#125;</span>`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;slot:<span class="variable">$&#123;slot&#125;</span>&quot;</span></span><br><span class="line">    redis-cli -p <span class="variable">$&#123;port&#125;</span> cluster addslots <span class="variable">$&#123;slot&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>我们要配置的是三主三从，所以要把16384三等分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0-5461 7000 5462-10922 7001 10923-16383 7002</span><br></pre></td></tr></table></figure><p>执行以下命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sh addslots.sh 0 5461 7000</span><br><span class="line">sh addslots.sh 5462 10922 7001</span><br><span class="line">sh addslots.sh 10923 16383 7002</span><br></pre></td></tr></table></figure><p>查看槽分配状态</p><p><img src="/img/in-post/2019-01-20/11.png"><br><img src="/img/in-post/2019-01-20/12.png"></p><blockquote><p>此时发现16384个槽确实已经分配完毕，槽分配完毕</p></blockquote><p>4: 主从</p><p>cluster replicate node-id</p><p>给7003分配到master7000主节点上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 7003 cluster replicate 6d4942b15eb5e02bb6193453443ccb827c13c6df</span><br><span class="line">redis-cli -p 7004 cluster replicate 916f84dee5fbef724ddf2f90fddf51fd654113f1</span><br><span class="line">redis-cli -p 7005 cluster replicate fee14c1f872fc4c7d451f84a616cf735d220538b</span><br></pre></td></tr></table></figure><p>主从分配结果：<br><img src="/img/in-post/2019-01-20/13.png"><br><img src="/img/in-post/2019-01-20/14.png"></p><h4 id="官方工具"><a href="#官方工具" class="headerlink" title="官方工具"></a>官方工具</h4><p>由于原生安装过程比较麻烦，又容易出错，所以正常的生产环境使用官方工具安装，但是掌握原生安装的方式更容易让我们理解集群分配的原理</p><p><strong>ruby环境准备</strong></p><ol><li>下载编译安装ruby</li><li>安装rubygem redis</li><li>安装redis-trib.rb</li></ol><p><img src="/img/in-post/2019-01-20/15.png"></p><p>1: 配置开启节点:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">port&#123;$port&#125;</span><br><span class="line">daemonize yes</span><br><span class="line">dir &quot;$&#123;redis-src&#125;/data/&quot;</span><br><span class="line">dbfilename &quot;dump-&#123;$port&#125;.rdb&quot;</span><br><span class="line">logfile &quot;&#123;$port&#125;.log&quot;</span><br><span class="line">cluster-enabled &quot;yes</span><br><span class="line">cluster-config-file nodes-&#123;$port&#125;.conf</span><br></pre></td></tr></table></figure><p>执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis-7000.conf</span><br><span class="line">redis-server redis-7001.conf</span><br><span class="line">redis-server redis-7002.conf</span><br><span class="line">redis-server redis-7003.conf</span><br><span class="line">redis-server redis-7004.conf</span><br><span class="line">redis-server redis-7005.conf</span><br></pre></td></tr></table></figure><p>2: 集群创建</p><p><img src="/img/in-post/2019-01-20/16.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//1 表示1个主节点分配1个从节点</span><br><span class="line">redis-cli --cluster create --cluster-replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</span><br></pre></td></tr></table></figure><p><img src="/img/in-post/2019-01-20/17.png"></p><p>上图分别展示了槽分配，主从和节点信息，符合预期执行yes即可</p><p>分配成功信息：</p><p><img src="/img/in-post/2019-01-20/18.png"></p><p>集群验证：</p><p><img src="/img/in-post/2019-01-20/19.png"></p><blockquote><p>当然如果维护上百台集群显然也不是最好的方式，可以借助或构建云平台来管理集群</p></blockquote></div><footer class="post-footer"><div class="post-eof"></div></footer></article><nav class="pagination"><a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a> <a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a></nav></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">enpsl</p><div class="site-description" itemprop="description">my blog</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">32</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">7</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2023</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">enpsl</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动</div></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script></body></html>