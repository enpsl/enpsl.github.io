<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"enpsl.github.io",root:"/",scheme:"Muse",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="RESTful目前业界 Server 端 API 接口的设计方式一般是遵循 RESTful 风格的规范 1234GET    &#x2F;user&#x2F;&amp;#123;userID&amp;#125; HTTP&#x2F;1.1POST   &#x2F;user&#x2F;&amp;#123;userID&amp;#125; HTTP&#x2F;1.1PUT    &#x2F;user&#x2F;&amp;#123;userID&amp;#125; HTTP&#x2F;1.1DELETE &#x2F;user&#x2F;&amp;#123;userI"><meta property="og:type" content="article"><meta property="og:title" content="gin的路由管理"><meta property="og:url" content="https://enpsl.github.io/2023/02/22/2023-02-22-gin%E6%98%AF%E6%80%8E%E6%A0%B7%E7%AE%A1%E7%90%86%E8%B7%AF%E7%94%B1%E7%9A%84/index.html"><meta property="og:site_name" content="彭诗亮的博客"><meta property="og:description" content="RESTful目前业界 Server 端 API 接口的设计方式一般是遵循 RESTful 风格的规范 1234GET    &#x2F;user&#x2F;&amp;#123;userID&amp;#125; HTTP&#x2F;1.1POST   &#x2F;user&#x2F;&amp;#123;userID&amp;#125; HTTP&#x2F;1.1PUT    &#x2F;user&#x2F;&amp;#123;userID&amp;#125; HTTP&#x2F;1.1DELETE &#x2F;user&#x2F;&amp;#123;userI"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://enpsl.github.io/img/in-post/2023-02-22/img_3.png"><meta property="og:image" content="https://enpsl.github.io/img/in-post/2023-02-22/img_4.png"><meta property="article:published_time" content="2023-02-22T11:30:00.000Z"><meta property="article:modified_time" content="2023-02-23T13:39:34.911Z"><meta property="article:author" content="enpsl"><meta property="article:tag" content="golang"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://enpsl.github.io/img/in-post/2023-02-22/img_3.png"><link rel="canonical" href="https://enpsl.github.io/2023/02/22/2023-02-22-gin%E6%98%AF%E6%80%8E%E6%A0%B7%E7%AE%A1%E7%90%86%E8%B7%AF%E7%94%B1%E7%9A%84/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>gin的路由管理 | 彭诗亮的博客</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">彭诗亮的博客</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档</a></li></ul></nav></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2023/02/22/2023-02-22-gin%E6%98%AF%E6%80%8E%E6%A0%B7%E7%AE%A1%E7%90%86%E8%B7%AF%E7%94%B1%E7%9A%84/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> gin的路由管理</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-02-22 19:30:00" itemprop="dateCreated datePublished" datetime="2023-02-22T19:30:00+08:00">2023-02-22</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h2><p>目前业界 Server 端 API 接口的设计方式一般是遵循 RESTful 风格的规范</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET    /user/&#123;userID&#125; HTTP/1.1</span><br><span class="line">POST   /user/&#123;userID&#125; HTTP/1.1</span><br><span class="line">PUT    /user/&#123;userID&#125; HTTP/1.1</span><br><span class="line">DELETE /user/&#123;userID&#125; HTTP/1.1</span><br></pre></td></tr></table></figure><p>这是比较规范的 RESTful API设计，分别代表：</p><ul><li>获取 userID 的用户信息</li><li>更新 userID 的用户信息（当然还有其 json body，没有写出来）</li><li>创建 userID 的用户（当然还有其 json body，没有写出来）</li><li>删除 userID 的用户</li></ul><h2 id="gin-路由设计"><a href="#gin-路由设计" class="headerlink" title="gin 路由设计"></a>gin 路由设计</h2><h3 id="前缀树和基数树（radix-tree）"><a href="#前缀树和基数树（radix-tree）" class="headerlink" title="前缀树和基数树（radix tree）"></a>前缀树和基数树（radix tree）</h3><p>前缀树是一个多叉树，广泛应用于字符串搜索，每个树节点存储一个字符，从根节点到任意一个叶子结点串起来就是一个字符串。</p><p>radix tree是优化之后的前缀树，对空间进一步压缩，从上往下提取公共前缀，非公共部分存到子节点，这样既节省了空间,同时也提高了查询效率(左边字符串sleep查询需要5步, 右边只需要3步)，Gin的路由树就是用radix tree实现的。<br><img src="/../img/in-post/2023-02-22/img_3.png" alt="img.png"></p><p>Gin为每一种请求都维护了一个radix tree，不同的请求会被解析并送到对应的radix tree进行处理。</p><p><img src="/../img/in-post/2023-02-22/img_4.png" alt="img_1.png"></p><p><code>gin</code>的路由树的一些相关结构体介绍</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">	RouterGroup</span><br><span class="line">    ....</span><br><span class="line">    trees            methodTrees <span class="comment">//保存着每种请求的路有树</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//RouterGroup可以被看作的内部的配置路由</span></span><br><span class="line"><span class="keyword">type</span> RouterGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">	Handlers HandlersChain   <span class="comment">//处理函数链，用Default初始化时会加入Logger(), Recovery()</span></span><br><span class="line">	basePath <span class="type">string</span>          <span class="comment">//基础路径，用Default和New初始化时都被赋值为&quot;/&quot;</span></span><br><span class="line">	engine   *Engine         <span class="comment">// Gin引擎，在添加路由时会用到</span></span><br><span class="line">	root     <span class="type">bool</span>            </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树节点</span></span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">	path      <span class="type">string</span>         <span class="comment">//保存节点的路径，像上面radix tree图中节点里面的值</span></span><br><span class="line">	indices   <span class="type">string</span>         <span class="comment">//子节点的首字符根据priority排列组成的字符串，为了方便遍历</span></span><br><span class="line">	wildChild <span class="type">bool</span>           <span class="comment">//标识孩子节点是否有通配符</span></span><br><span class="line">	nType     nodeType       <span class="comment">//节点类型</span></span><br><span class="line">	priority  <span class="type">uint32</span>         <span class="comment">//优先级</span></span><br><span class="line">	children  []*node</span><br><span class="line">	handlers  HandlersChain  <span class="comment">//处理函数链</span></span><br><span class="line">	fullPath  <span class="type">string</span>         <span class="comment">//保存完整路径</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// node结构中nodeType节点类型</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	static nodeType = <span class="literal">iota</span> 	 <span class="comment">// default 普通节点，默认</span></span><br><span class="line">	root			 <span class="comment">// 根节点</span></span><br><span class="line">	param			 <span class="comment">// 参数路由，比如 /user/:id</span></span><br><span class="line">	catchAll		 <span class="comment">// 匹配所有内容的路由，比如 /article/*key</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>当 <code>gin</code> 注册路由的时候，会根据不同的 <code>Method</code> 分别注册不同的路由树。</p><p>如上面的restful请求会注册四颗路由树出来。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> addRoute(method, path <span class="type">string</span>, handlers HandlersChain) &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    root := engine.trees.get(method)</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        root = <span class="built_in">new</span>(node)</span><br><span class="line">        root.fullPath = <span class="string">&quot;/&quot;</span></span><br><span class="line">        engine.trees = <span class="built_in">append</span>(engine.trees, methodTree&#123;method: method, root: root&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    root.addRoute(path, handlers)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程</p><ul><li>拿到一个 <code>method</code> 方法时，去 <code>trees slice</code> 中遍历</li><li>如果 <code>trees slice</code> 存在这个 <code>method</code>, 则这个URL对应的 <code>handler</code> 直接添加到找到的路由树上</li><li>如果没有找到，则重新创建一颗新的方法树出来, 然后将 URL对应的 <code>handler</code> 添加到这个路由 树上</li></ul><p>这里的重点是根节点root调用的addRoute，添加节点的逻辑都在这个函数里面，包括找到插入的位置，一些通配节点的特殊处理等。在这个函数里面会用到一些工具函数，这里一并介绍一下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Increments priority of the given child and reorders if necessary</span></span><br><span class="line"><span class="comment">// 增加指定孩子节点的优先级，并更新节点的indices</span></span><br><span class="line"><span class="comment">// 这并不会影响路由功能，但是可以加快孩子节点的查找速度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> incrementChildPrio(pos <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	cs := n.children</span><br><span class="line">	cs[pos].priority++</span><br><span class="line">	prio := cs[pos].priority</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Adjust position (move to front)</span></span><br><span class="line">	<span class="comment">// 将更新后的priority向前移动，保持按优先级降序排列</span></span><br><span class="line">	newPos := pos</span><br><span class="line">	<span class="keyword">for</span> ; newPos &gt; <span class="number">0</span> &amp;&amp; cs[newPos<span class="number">-1</span>].priority &lt; prio; newPos-- &#123;</span><br><span class="line">		<span class="comment">// Swap node positions</span></span><br><span class="line">		cs[newPos<span class="number">-1</span>], cs[newPos] = cs[newPos], cs[newPos<span class="number">-1</span>]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Build new index char string</span></span><br><span class="line">	<span class="comment">// 根据优先级重新构建indices，indices保存着当前节点下的每个孩子节点的首字符</span></span><br><span class="line">	<span class="keyword">if</span> newPos != pos &#123;</span><br><span class="line">		n.indices = n.indices[:newPos] + <span class="comment">// Unchanged prefix, might be empty</span></span><br><span class="line">			n.indices[pos:pos+<span class="number">1</span>] + <span class="comment">// The index char we move</span></span><br><span class="line">			n.indices[newPos:pos] + n.indices[pos+<span class="number">1</span>:] <span class="comment">// Rest without char at &#x27;pos&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> newPos</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获两个字符串的最长公共前缀</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestCommonPrefix</span><span class="params">(a, b <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	max := min(<span class="built_in">len</span>(a), <span class="built_in">len</span>(b))</span><br><span class="line">	<span class="keyword">for</span> i &lt; max &amp;&amp; a[i] == b[i] &#123;</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// addRoute adds a node with the given handle to the path.</span></span><br><span class="line"><span class="comment">// Not concurrency-safe!</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> addRoute(path <span class="type">string</span>, handlers HandlersChain) &#123;</span><br><span class="line">	fullPath := path</span><br><span class="line">	n.priority++</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Empty tree</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(n.path) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(n.children) == <span class="number">0</span> &#123;</span><br><span class="line">		n.insertChild(path, fullPath, handlers)</span><br><span class="line">		n.nType = root</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	parentFullPathIndex := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">walk:</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// Find the longest common prefix.</span></span><br><span class="line">		<span class="comment">// This also implies that the common prefix contains no &#x27;:&#x27; or &#x27;*&#x27;</span></span><br><span class="line">		<span class="comment">// since the existing key can&#x27;t contain those chars.</span></span><br><span class="line">		<span class="comment">// 获取最长公共前缀 path代表新加路由节点的path,n.path代表当前node的path</span></span><br><span class="line">		i := longestCommonPrefix(path, n.path)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Split edge</span></span><br><span class="line">		<span class="comment">// 如果n.path=/abc path=/a这种的，最长公共前缀小于n.path 则进入if语句，提取公共部分为父节点</span></span><br><span class="line">        <span class="comment">// 非公共部分为子节点，即n.path=/a 子节点/bc</span></span><br><span class="line">        <span class="comment">// /bc保存原来节点n的信息，/a为新节点的信息</span></span><br><span class="line">		<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(n.path) &#123;</span><br><span class="line">			child := node&#123;</span><br><span class="line">				path:      n.path[i:],<span class="comment">//非公共的部分</span></span><br><span class="line">				wildChild: n.wildChild,</span><br><span class="line">				indices:   n.indices,</span><br><span class="line">				children:  n.children,</span><br><span class="line">				handlers:  n.handlers,</span><br><span class="line">				<span class="comment">// 由于是n的孩子节点,故优先级减去n节点,即n-1</span></span><br><span class="line">				priority:  n.priority - <span class="number">1</span>,</span><br><span class="line">				fullPath:  n.fullPath,</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			n.children = []*node&#123;&amp;child&#125;</span><br><span class="line">			<span class="comment">// []byte for proper unicode char conversion, see #65</span></span><br><span class="line">			n.indices = bytesconv.BytesToString([]<span class="type">byte</span>&#123;n.path[i]&#125;)</span><br><span class="line">			n.path = path[:i]</span><br><span class="line">			n.handlers = <span class="literal">nil</span>    <span class="comment">// 目前先置为空，后面会再加上handlers</span></span><br><span class="line">			n.wildChild = <span class="literal">false</span></span><br><span class="line">			n.fullPath = fullPath[:parentFullPathIndex+i]</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Make new node a child of this node</span></span><br><span class="line">		<span class="comment">// 例如n.path=/a path=/abc 新加进来的path比当前n.path长，则进入if语句</span></span><br><span class="line">		<span class="comment">// 在当前节点创建一个新的子节点</span></span><br><span class="line">		<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(path) &#123;</span><br><span class="line">			path = path[i:]</span><br><span class="line">			<span class="comment">// 如果n节点的孩子节点有通配符进入if，这里的逻辑会有点绕</span></span><br><span class="line">			<span class="keyword">if</span> n.wildChild &#123;</span><br><span class="line">				parentFullPathIndex += <span class="built_in">len</span>(n.path)</span><br><span class="line">				<span class="comment">//注意，此时n已经指向它的第一个孩子节点</span></span><br><span class="line">				n = n.children[<span class="number">0</span>]</span><br><span class="line">				n.priority++</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Check if the wildcard matches</span></span><br><span class="line">                <span class="comment">// 注意，此时的path已经取成了公共前缀后的部分</span></span><br><span class="line">                <span class="comment">// 例如原来的路径是/usr/:name，假设当前n节点的父节点为nfather</span></span><br><span class="line">                <span class="comment">// 而n在前面已经取成了nfather孩子节点</span></span><br><span class="line">                <span class="comment">// 目前情况是nfather.path=/usr，由于其子节点是通配符节点</span></span><br><span class="line">                <span class="comment">// 故nfather.wildChild=true，n.path=/:name</span></span><br><span class="line">                <span class="comment">// 假设新加进来的节点path=/:nameserver</span></span><br><span class="line">                <span class="comment">// 则符合这里的if条件，跳转到walk，以n为父节点继续匹配</span></span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(path) &gt;= <span class="built_in">len</span>(n.path) &amp;&amp; n.path == path[:<span class="built_in">len</span>(n.path)] &amp;&amp;</span><br><span class="line">					<span class="comment">// Adding a child to a catchAll is not possible</span></span><br><span class="line">					<span class="comment">// 不可能在全匹配节点（例如*name）后继续加子节点</span></span><br><span class="line">					n.nType != catchAll &amp;&amp;</span><br><span class="line">					<span class="comment">// Check for longer wildcard, e.g. :name and :names</span></span><br><span class="line">					(<span class="built_in">len</span>(n.path) &gt;= <span class="built_in">len</span>(path) || path[<span class="built_in">len</span>(n.path)] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">					<span class="keyword">continue</span> walk</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				pathSeg := path</span><br><span class="line">				<span class="keyword">if</span> n.nType != catchAll &#123;</span><br><span class="line">					pathSeg = strings.SplitN(path, <span class="string">&quot;/&quot;</span>, <span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">				&#125;</span><br><span class="line">				prefix := fullPath[:strings.Index(fullPath, pathSeg)] + n.path</span><br><span class="line">				<span class="built_in">panic</span>(<span class="string">&quot;&#x27;&quot;</span> + pathSeg +</span><br><span class="line">					<span class="string">&quot;&#x27; in new path &#x27;&quot;</span> + fullPath +</span><br><span class="line">					<span class="string">&quot;&#x27; conflicts with existing wildcard &#x27;&quot;</span> + n.path +</span><br><span class="line">					<span class="string">&quot;&#x27; in existing prefix &#x27;&quot;</span> + prefix +</span><br><span class="line">					<span class="string">&quot;&#x27;&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 注意，此时的path已经取成了公共前缀的后部分</span></span><br><span class="line">			c := path[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">			<span class="comment">// slash after param</span></span><br><span class="line">            <span class="comment">// 如果当前节点是参数节点类型，比如n.path= :name </span></span><br><span class="line">            <span class="comment">// 且c= / ,且n节点仅有一个孩子节点</span></span><br><span class="line">			<span class="keyword">if</span> n.nType == param &amp;&amp; c == <span class="string">&#x27;/&#x27;</span> &amp;&amp; <span class="built_in">len</span>(n.children) == <span class="number">1</span> &#123;</span><br><span class="line">				parentFullPathIndex += <span class="built_in">len</span>(n.path)</span><br><span class="line">				<span class="comment">//当前节点等于子节点</span></span><br><span class="line">				n = n.children[<span class="number">0</span>]</span><br><span class="line">				<span class="comment">//优先级加1</span></span><br><span class="line">				n.priority++</span><br><span class="line">				<span class="keyword">continue</span> walk</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Check if a child with the next path byte exists</span></span><br><span class="line">			<span class="comment">// 循环查找，n.indices记录着所有孩子节点的第一个字符</span></span><br><span class="line">                        <span class="keyword">for</span> i, max := <span class="number">0</span>, <span class="built_in">len</span>(n.indices); i &lt; max; i++ &#123;</span><br><span class="line">							<span class="comment">//如果找到和当前要插入节点的第一个字符相符，匹配成功</span></span><br><span class="line">				<span class="keyword">if</span> c == n.indices[i] &#123;</span><br><span class="line">					parentFullPathIndex += <span class="built_in">len</span>(n.path)</span><br><span class="line">                                        <span class="comment">// 对应子节点优先级加1，并对该子节点的indices重新排列</span></span><br><span class="line">					i = n.incrementChildPrio(i)</span><br><span class="line">					n = n.children[i]</span><br><span class="line">					<span class="keyword">continue</span> walk</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Otherwise insert it</span></span><br><span class="line">                        <span class="comment">// 如果添加的节点既不是 * 也不是: 这样的通配节点,就执行插入</span></span><br><span class="line">			<span class="keyword">if</span> c != <span class="string">&#x27;:&#x27;</span> &amp;&amp; c != <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line">				<span class="comment">// []byte for proper unicode char conversion, see #65</span></span><br><span class="line">				n.indices += bytesconv.BytesToString([]<span class="type">byte</span>&#123;c&#125;)</span><br><span class="line">				child := &amp;node&#123;</span><br><span class="line">					fullPath: fullPath,</span><br><span class="line">				&#125;</span><br><span class="line">				n.children = <span class="built_in">append</span>(n.children, child)</span><br><span class="line">				n.incrementChildPrio(<span class="built_in">len</span>(n.indices) - <span class="number">1</span>)</span><br><span class="line">				n = child</span><br><span class="line">			&#125;</span><br><span class="line">			n.insertChild(path, fullPath, handlers)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Otherwise and handle to current node</span></span><br><span class="line">		<span class="keyword">if</span> n.handlers != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;handlers are already registered for path &#x27;&quot;</span> + fullPath + <span class="string">&quot;&#x27;&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		n.handlers = handlers</span><br><span class="line">		n.fullPath = fullPath</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Priority-优先级"><a href="#Priority-优先级" class="headerlink" title="Priority 优先级"></a>Priority 优先级</h3><p>为了能快速找到并组合完整的路由，GIN 在添加路由的同时，会在每个节点中添加 Priority 这个属性。在查找时根据 Priority 进行排序，常用节点(通过次数理论最多的节点) 在最前，并且同一层级里面 Priority 值越大，越优先进行匹配。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Search for a wildcard segment and check the name for invalid characters.</span></span><br><span class="line"><span class="comment">// Returns -1 as index, if no wildcard was found.</span></span><br><span class="line"><span class="comment">// wildcard-通配符字符串（例如:name,wildcard就为name） i-通配符在path的索引 valid-是否有合法的通配符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findWildcard</span><span class="params">(path <span class="type">string</span>)</span></span> (wildcard <span class="type">string</span>, i <span class="type">int</span>, valid <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="comment">// Find start</span></span><br><span class="line">	<span class="keyword">for</span> start, c := <span class="keyword">range</span> []<span class="type">byte</span>(path) &#123;</span><br><span class="line">		<span class="comment">// A wildcard starts with &#x27;:&#x27; (param) or &#x27;*&#x27; (catch-all)</span></span><br><span class="line">		<span class="keyword">if</span> c != <span class="string">&#x27;:&#x27;</span> &amp;&amp; c != <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Find end and check for invalid characters</span></span><br><span class="line">		valid = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">for</span> end, c := <span class="keyword">range</span> []<span class="type">byte</span>(path[start+<span class="number">1</span>:]) &#123;</span><br><span class="line">			<span class="keyword">switch</span> c &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">				<span class="keyword">return</span> path[start : start+<span class="number">1</span>+end], start, valid</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>, <span class="string">&#x27;*&#x27;</span>:   <span class="comment">//一个通配符后还有一个通配符，valid置为false</span></span><br><span class="line">				valid = <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> path[start:], start, valid</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, <span class="number">-1</span>, <span class="literal">false</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//插入子节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> insertChild(path <span class="type">string</span>, fullPath <span class="type">string</span>, handlers HandlersChain) &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// Find prefix until first wildcard</span></span><br><span class="line">		wildcard, i, valid := findWildcard(path)</span><br><span class="line">		<span class="keyword">if</span> i &lt; <span class="number">0</span> &#123; <span class="comment">// No wildcard found</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// The wildcard name must not contain &#x27;:&#x27; and &#x27;*&#x27;</span></span><br><span class="line">		<span class="keyword">if</span> !valid &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;only one wildcard per path segment is allowed, has: &#x27;&quot;</span> +</span><br><span class="line">				wildcard + <span class="string">&quot;&#x27; in path &#x27;&quot;</span> + fullPath + <span class="string">&quot;&#x27;&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// check if the wildcard has a name</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(wildcard) &lt; <span class="number">2</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;wildcards must be named with a non-empty name in path &#x27;&quot;</span> + fullPath + <span class="string">&quot;&#x27;&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Check if this node has existing children which would be</span></span><br><span class="line">		<span class="comment">// unreachable if we insert the wildcard here</span></span><br><span class="line">		<span class="comment">// 检查此节点是否有现有子节点，如果有子节点，我们在插入通配符，将没办法再访问这些子节点</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(n.children) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;wildcard segment &#x27;&quot;</span> + wildcard +</span><br><span class="line">				<span class="string">&quot;&#x27; conflicts with existing children in path &#x27;&quot;</span> + fullPath + <span class="string">&quot;&#x27;&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> wildcard[<span class="number">0</span>] == <span class="string">&#x27;:&#x27;</span> &#123; <span class="comment">// param</span></span><br><span class="line">			<span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// Insert prefix before the current wildcard</span></span><br><span class="line">				<span class="comment">// 当前节点n保存通配符的前面部分</span></span><br><span class="line">				n.path = path[:i]</span><br><span class="line">				path = path[i:]</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//wildChild设为true表示子节点有通配符</span></span><br><span class="line">			n.wildChild = <span class="literal">true</span></span><br><span class="line">			child := &amp;node&#123;</span><br><span class="line">				nType:    param,</span><br><span class="line">				path:     wildcard,</span><br><span class="line">				fullPath: fullPath,</span><br><span class="line">			&#125;</span><br><span class="line">			n.children = []*node&#123;child&#125;</span><br><span class="line">			n = child</span><br><span class="line">			n.priority++</span><br><span class="line"></span><br><span class="line">			<span class="comment">// if the path doesn&#x27;t end with the wildcard, then there</span></span><br><span class="line">			<span class="comment">// will be another non-wildcard subpath starting with &#x27;/&#x27;</span></span><br><span class="line">			<span class="comment">// 如果通配符后面还有字符，则一定以/为开头</span></span><br><span class="line">			<span class="comment">// 例如/:name/age 通配符后还有/age</span></span><br><span class="line">			<span class="comment">// 这里的英文注释说“将会有另一个以&#x27;/&#x27;开头的非通配符子路径”</span></span><br><span class="line">			<span class="comment">// 这不代表不能处理/:name/*hobby这种，上面已经展示了会将通配符的前面部分</span></span><br><span class="line">			<span class="comment">// 设为父节点，也就是说通配符节点的父节点一定是一个非通配符节点，英文的注释应该这么理解的</span></span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(wildcard) &lt; <span class="built_in">len</span>(path) &#123;</span><br><span class="line">				path = path[<span class="built_in">len</span>(wildcard):]</span><br><span class="line"></span><br><span class="line">				child := &amp;node&#123;</span><br><span class="line">					priority: <span class="number">1</span>,</span><br><span class="line">					fullPath: fullPath,</span><br><span class="line">				&#125;</span><br><span class="line">				n.children = []*node&#123;child&#125;</span><br><span class="line">				n = child</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Otherwise we&#x27;re done. Insert the handle in the new leaf</span></span><br><span class="line">			n.handlers = handlers</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// catchAll</span></span><br><span class="line">		<span class="comment">// 通配符不是:那么就是*，因为*是全匹配的通配符，那么这种情况是不允许的/*name/pwd</span></span><br><span class="line">		<span class="keyword">if</span> i+<span class="built_in">len</span>(wildcard) != <span class="built_in">len</span>(path) &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;catch-all routes are only allowed at the end of the path in path &#x27;&quot;</span> + fullPath + <span class="string">&quot;&#x27;&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果当前节点的最后一个字符是/，则与全匹配通配符*冲突</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(n.path) &gt; <span class="number">0</span> &amp;&amp; n.path[<span class="built_in">len</span>(n.path)<span class="number">-1</span>] == <span class="string">&#x27;/&#x27;</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;catch-all conflicts with existing handle for the path segment root in path &#x27;&quot;</span> + fullPath + <span class="string">&quot;&#x27;&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// currently fixed width 1 for &#x27;/&#x27;</span></span><br><span class="line">		i--</span><br><span class="line">		<span class="keyword">if</span> path[i] != <span class="string">&#x27;/&#x27;</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;no / before catch-all in path &#x27;&quot;</span> + fullPath + <span class="string">&quot;&#x27;&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		n.path = path[:i]</span><br><span class="line"></span><br><span class="line">		<span class="comment">// First node: catchAll node with empty path</span></span><br><span class="line">		<span class="comment">// *可以匹配0个或多个字符，第一个节点保存为空，也就是*匹配0个字符的情况</span></span><br><span class="line">		child := &amp;node&#123;</span><br><span class="line">			wildChild: <span class="literal">true</span>,</span><br><span class="line">			nType:     catchAll,</span><br><span class="line">			fullPath:  fullPath,</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		n.children = []*node&#123;child&#125;</span><br><span class="line">		n.indices = <span class="type">string</span>(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">		n = child</span><br><span class="line">		n.priority++</span><br><span class="line"></span><br><span class="line">		<span class="comment">// second node: node holding the variable</span></span><br><span class="line">		<span class="comment">// 匹配多个字符的情况</span></span><br><span class="line">		child = &amp;node&#123;</span><br><span class="line">			path:     path[i:],</span><br><span class="line">			nType:    catchAll,</span><br><span class="line">			handlers: handlers,</span><br><span class="line">			priority: <span class="number">1</span>,</span><br><span class="line">			fullPath: fullPath,</span><br><span class="line">		&#125;</span><br><span class="line">		n.children = []*node&#123;child&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If no wildcard was found, simply insert the path and handle</span></span><br><span class="line">	n.path = path</span><br><span class="line">	n.handlers = handlers</span><br><span class="line">	n.fullPath = fullPath</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>摘自<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/358704308">Gin源码解析（一）</a></p></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/golang/" rel="tag"># golang</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2023/02/22/2023-02-20-golangroadmap/" rel="prev" title="golang 问题整理"><i class="fa fa-chevron-left"></i> golang 问题整理</a></div><div class="post-nav-item"> <a href="/2023/02/22/2023-02-22-gin%E6%98%AF%E6%80%8E%E6%A0%B7%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E7%9A%84/" rel="next" title="gin路由请求数据解析">gin路由请求数据解析<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#RESTful"><span class="nav-number">1.</span> <span class="nav-text">RESTful</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gin-%E8%B7%AF%E7%94%B1%E8%AE%BE%E8%AE%A1"><span class="nav-number">2.</span> <span class="nav-text">gin 路由设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E7%BC%80%E6%A0%91%E5%92%8C%E5%9F%BA%E6%95%B0%E6%A0%91%EF%BC%88radix-tree%EF%BC%89"><span class="nav-number">2.1.</span> <span class="nav-text">前缀树和基数树（radix tree）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Priority-%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">2.2.</span> <span class="nav-text">Priority 优先级</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">enpsl</p><div class="site-description" itemprop="description">my blog</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">50</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">9</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2023</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">enpsl</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动</div></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script></body></html>