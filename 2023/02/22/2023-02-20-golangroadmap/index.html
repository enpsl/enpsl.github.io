<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"enpsl.github.io",root:"/",scheme:"Muse",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="Go语言Slice是否线程安全Go语言实现线程安全常用的几种方式:1.互斥锁；2.读写锁；3.原子操作；4.sync.once；5. sync.atomic；6.channelslice底层结构并没有使用加锁等方式，不支持并发读写，所以并不是线程安全的，使用多个goroutine对类型为slice的变量进行操作，每次输出的值大概率都不会一样，与预期值不一致; slice在并发执行中不会报错，但是数"><meta property="og:type" content="article"><meta property="og:title" content="golang 问题整理"><meta property="og:url" content="https://enpsl.github.io/2023/02/22/2023-02-20-golangroadmap/index.html"><meta property="og:site_name" content="彭诗亮的博客"><meta property="og:description" content="Go语言Slice是否线程安全Go语言实现线程安全常用的几种方式:1.互斥锁；2.读写锁；3.原子操作；4.sync.once；5. sync.atomic；6.channelslice底层结构并没有使用加锁等方式，不支持并发读写，所以并不是线程安全的，使用多个goroutine对类型为slice的变量进行操作，每次输出的值大概率都不会一样，与预期值不一致; slice在并发执行中不会报错，但是数"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-02-22T11:30:00.000Z"><meta property="article:modified_time" content="2023-02-23T13:42:55.172Z"><meta property="article:author" content="enpsl"><meta property="article:tag" content="golang"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://enpsl.github.io/2023/02/22/2023-02-20-golangroadmap/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>golang 问题整理 | 彭诗亮的博客</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">彭诗亮的博客</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档</a></li></ul></nav></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2023/02/22/2023-02-20-golangroadmap/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> golang 问题整理</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-02-22 19:30:00" itemprop="dateCreated datePublished" datetime="2023-02-22T19:30:00+08:00">2023-02-22</time></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="Go语言Slice是否线程安全"><a href="#Go语言Slice是否线程安全" class="headerlink" title="Go语言Slice是否线程安全"></a>Go语言Slice是否线程安全</h1><p>Go语言实现线程安全常用的几种方式:1.互斥锁；2.读写锁；3.原子操作；4.sync.once；5. sync.atomic；6.channel<br>slice底层结构并没有使用加锁等方式，不支持并发读写，所以并不是线程安全的，使用多个goroutine对类型为slice的变量进行操作，每次输出的值大概率都不会一样，与预期值不一致; slice在并发执行中不会报错，但是数据会丢失。</p><h1 id="slice内存泄漏分析"><a href="#slice内存泄漏分析" class="headerlink" title="slice内存泄漏分析"></a>slice内存泄漏分析</h1><blockquote><p>（1）发生场景：截取长slice中的一段导致长slice未释放</p></blockquote><p>由于底层都是数组，如果截长slice的一段，其实相当于引用了底层数组中的一小段。只要还有引用，golang的gc就不能回收数组。这种情况导致未使用的数组空间，未及时回收。</p><p>解决方案：新建一个长度为0的slice，将需要的一小段slice使用append方法添加到新的slice。再将原来的slice置为nil。</p><blockquote><p>2）发生场景：没有重置丢失的子切片元素中的指针</p></blockquote><p>没有及时将不再使用的slice置为nil</p><p>解决方案：如果slice中包含很多元素，再只有一小部分元素需要使用的情况下。建议重新分配一个slice将需要保留的元素加入其中，将原来的长slice整个置为nil。</p><h1 id="Golang-Slice-的底层实现"><a href="#Golang-Slice-的底层实现" class="headerlink" title="Golang Slice 的底层实现"></a>Golang Slice 的底层实现</h1><p>切片是基于数组实现的，它的底层是数组，它自己本身非常小，可以理解为对 底层数组的抽象。因为基于数组实现，所以它的底层的内存是连续分配的，效 率非常高，还可以通过索引获得数据。</p><p>切片本身并不是动态数组或者数组指针。它内部实现的数据结构通过指针引用 底层数组，设定相关属性将数据读写操作限定在指定的区域内。切片本身是一 个只读对象，其工作机制类似数组指针的一种封装。</p><p>切片对象非常小，是因为它是只有 3 个字段的数据结构：</p><ul><li><p>指向底层数组的指针</p></li><li><p>切片的长度</p></li><li><p>切片的容量</p></li></ul><h1 id="golang里的数组和切片"><a href="#golang里的数组和切片" class="headerlink" title="golang里的数组和切片"></a>golang里的数组和切片</h1><p>数组长度是固定的，而切片是可变长的。可以把切片看作是对底层数组的封装，每个切片的底层数据结构中，一定会包含一个数组。数组可以被称为切片的底层数组，切片也可以被看作对数组某一连续片段的引用。因此，Go中切片属于引用类型，而数组属于值类型，通过内建函数len，可以取得数组和切片的长度。通过内建函数cap，可以得到数组和切片的容量。但是数组的长度和容量是相等的，并且都不可变，而且切片容量是有变化规律的。</p><h1 id="对已经关闭的channel进行读写操作会发生什么"><a href="#对已经关闭的channel进行读写操作会发生什么" class="headerlink" title="对已经关闭的channel进行读写操作会发生什么?"></a>对已经关闭的channel进行读写操作会发生什么?</h1><ol><li><p>读已关闭的channel<br>读已经关闭的channel无影响。<br>如果在关闭前，通道内部有元素，会正确读到元素的值；<br>如果关闭前通道无元素，则会读取到通道内元素类型对应的零值。<br>若遍历通道，如果通道未关闭，读完元素后，会报死锁的错误。<br>fatal error: all goroutines are asleep - deadlock!</p></li><li><p>写已关闭的通道<br>会引发panic: send on closed channel</p></li><li><p>关闭已关闭的通道<br>会引发panic: close of closed channel</p></li></ol><p><strong>总结</strong>：对于一个已初始化，但并未关闭的通道来说，收发操作一定不会引发 panic。但是通道一旦关闭，再对它进行发送操作，就会引发 panic。如果我们试图关闭一个已经关闭了的通道，也会引发 panic。</p><h1 id="go-struct-能不能比较"><a href="#go-struct-能不能比较" class="headerlink" title="go struct 能不能比较"></a>go struct 能不能比较</h1><p>需要具体情况具体分析，如果struct中含有不能被比较的字段类型，就不能被比较，如果struct中所有的字段类型都支持比较，那么就可以被比较。</p><p>不可被比较的类型:<br>① slice，因为slice是引用类型，除非是和nil比较<br>② map，和slice同理，如果要比较两个map只能通过循环遍历实现<br>③ 函数类型</p><p>其他的类型都可以比较。</p><p>还有两点值得注意：</p><p>结构体之间只能比较它们是否相等，而不能比较它们的大小。<br>只有所有属性都相等而属性顺序都一致的结构体才能进行比较。</p><h1 id="数组是如何实现根据下标随机访问数组元素的吗？"><a href="#数组是如何实现根据下标随机访问数组元素的吗？" class="headerlink" title="数组是如何实现根据下标随机访问数组元素的吗？"></a>数组是如何实现根据下标随机访问数组元素的吗？</h1><p>例如： <code>a := [10]int&#123;0&#125;</code></p><ul><li>计算机给数组a，分配了一组连续的内存空间。</li><li>比如内存块的首地址为 base_address&#x3D;1000。</li><li>当计算给每个内存单元分配一个地址，计算机通过地址来访问数据。当计算机需要访问数组的某个元素的时候，会通过一个寻址公式来计算存储的内存地址。</li></ul><h1 id="GMP模型"><a href="#GMP模型" class="headerlink" title="GMP模型"></a>GMP模型</h1><ul><li><code>G（Goroutine）</code>：G 就是我们所说的 Go 语言中的协程 Goroutine 的缩写，相当于操作系统中的进程控制块。其中存着 goroutine 的运行时栈信息，CPU 的一些寄存器的值以及执行的函数指令等。</li><li><code>M（Machine）</code>：代表一个操作系统的主线程，对内核级线程的封装，数量对应真实的 CPU 数。一个 M 直接关联一个 os 内核线程，用于执行 G。M 会优先从关联的 P 的本地队列中直接获取待执行的 G。M 保存了 M 自身使用的栈信息、当前正在 M上执行的 G 信息、与之绑定的 P 信息。</li><li><code>P（Processor）</code>：Processor 代表了 M 所需的上下文环境，代表 M 运行 G 所需要的资源。是处理用户级代码逻辑的处理器，可以将其看作一个局部调度器使 go 代码在一个线程上跑。当 P 有任务时，就需要创建或者唤醒一个系统线程来执行它队列里的任务，所以 P 和 M 是相互绑定的。总的来说，P 可以根据实际情况开启协程去工作，它包含了运行 goroutine 的资源，如果线程想运行 goroutine，必须先获取 P，P 中还包含了可运行的 G 队列。</li></ul><h1 id="go垃圾回收，什么时候触发"><a href="#go垃圾回收，什么时候触发" class="headerlink" title="go垃圾回收，什么时候触发"></a>go垃圾回收，什么时候触发</h1><p>主动触发(手动触发)，通过调用 runtime.GC 来触发GC，此调用阻塞式地等待当前GC运行完毕。<br>被动触发，分为两种方式：<br>1）使用步调（Pacing）算法，其核心思想是控制内存增长的比例,每次内存分配时检查当前内存分配量是否已达到阈值（环境变量GOGC）：默认100%，即当内存扩大一倍时启用GC。<br>2）使用系统监控，当超过两分钟没有产生任何GC时，强制触发 GC。</p><h1 id="gc算法有哪些？"><a href="#gc算法有哪些？" class="headerlink" title="gc算法有哪些？"></a>gc算法有哪些？</h1><p>常见的垃圾回收算法有以下几种：</p><p><strong>引用计数</strong> ：对每个对象维护一个引用计数，当引用该对象的对象被销毁时，引用计数减1，当引用计数器为0时回收该对象。<br>优点：对象可以很快的被回收，不会出现内存耗尽或达到某个阀值时才回收。<br>缺点：不能很好的处理循环引用，而且实时维护引用计数，有也一定的代价。<br>代表语言：Python、PHP<br><strong>标记-清除</strong>：从根变量开始遍历所有引用的对象，引用的对象标记为”被引用”，没有被标记的进行回收。<br>优点：解决了引用计数的缺点。<br>缺点：需要STW，即要暂时停掉程序运行。<br>代表语言：Golang(其采用三色标记法)<br><strong>分代收集</strong>：按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，而短的放入新生代，不同代有不能的回收算法和回收频率。<br>优点：回收性能好<br>缺点：算法复杂<br>代表语言： JAVA<br>三色标记法<br>1)初始状态下所有对象都是白色的。<br>2)从根节点开始遍历所有对象，把遍历到的对象变成灰色对象<br>3)遍历灰色对象，将灰色对象引用的对象也变成灰色，然后将遍历过的灰色对象变成黑色对象。<br>4)循环步骤3，直到灰色对象全部变黑色。<br>5)回收所有白色对象（垃圾）。</p><h1 id="make-与-new-的区别"><a href="#make-与-new-的区别" class="headerlink" title="make 与 new 的区别"></a>make 与 new 的区别</h1><p>引用类型与值类型</p><ul><li><p><code>引用类型</code> 变量存储的是一个地址，这个地址存储最终的值。内存通常在堆上分配。通过 GC 回收。包括 指针、slice 切片、管道 channel、接口 interface、map、函数等。</p></li><li><p><code>值类型</code>是 基本数据类型，int,float,bool,string, 以及数组和 struct 特点：变量直接存储值，内存通常在栈中分配，栈在函数调用后会被释放</p></li><li><p>对于<code>引用类型</code>的变量，我们不光要声明它，还要为它分配内容空间</p></li><li><p>对于<code>值类型</code>的则不需要显示分配内存空间，是因为go会默认帮我们分配好</p></li></ul><p><strong>new()</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">new</span><span class="params">(Type)</span></span> *Type</span><br></pre></td></tr></table></figure><p><code>new()</code>对类型进行内存分配,入参为类型,返回为类型的指针，指向分配类型的内存地址</p><p><strong>make()</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(t Type, size ...IntegerType)</span></span> Type</span><br></pre></td></tr></table></figure><p>make()也是用于内存分配的，但是和new不同，它只用于channel、map以及切片的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。</p><p>注意，因为这三种类型是引用类型，所以必须得初始化，但是不是置为零值，这个和new是不一样的。</p><p>简而言之make()用于初始化slice, map, channel等内置数据结构</p><h1 id="如何判断channel是否关闭？"><a href="#如何判断channel是否关闭？" class="headerlink" title="如何判断channel是否关闭？"></a>如何判断channel是否关闭？</h1><ul><li><p>读channel的时候判断其是否已经关闭</p><p> <code>_,ok := &lt;- jobs</code></p><p> 此时如果 channel 关闭，ok 值为 false</p></li><li><p>写入channel的时候判断其是否已经关闭</p></li></ul><ol><li><p>_,ok :&#x3D; &lt;- jobs</p><p> 此时如果 channel 关闭，ok 值为 false，如果 channel 没有关闭，则会漏掉一个 jobs中的一个数据</p></li><li><p>使用 select 方式</p><p> 再创建一个 channel，叫做 timeout，如果超时往这个 channel 发送 true，在生产者发送数据给 jobs 的 channel，用 select 监听 timeout，如果超时则关闭 jobs 的 channel。</p></li></ol><h1 id="go-的锁是可重入的吗？"><a href="#go-的锁是可重入的吗？" class="headerlink" title="go 的锁是可重入的吗？"></a>go 的锁是可重入的吗？</h1><p>不是可重入锁。</p><p>讨论这个问题前，先解释一下“重入”这个概念。当一个线程获取到锁时，如果没有其他线程拥有这个锁，那么这个线程<br>就会成功获取到这个锁。线程持有这个锁后，其他线程再请求这个锁，其他线程就会进入阻塞等待的状态。但是如果游泳这个锁的<br>线程再请求这把锁的话，就不会阻塞，而是成功返回，这就是可重入锁。可重入锁也叫做递归锁。<br>为什么 go 的锁不是可重入锁，因为 Mutex 的实现中，没有记录哪个 goroutine 拥有这把锁。换句话说，我们可以通过<br>扩展来将 go 的锁变为可重入锁，这里就不展开了。下面是一个误用 Mutex 的重入例子：<a target="_blank" rel="noopener" href="https://github.com/guowei-gong/go-demo/commit/a6fc236853f5cd0efd4e62269cfe60a19de7a96e">https://github.com/guowei-gong/go-demo/commit/a6fc236853f5cd0efd4e62269cfe60a19de7a96e</a></p><h1 id="go-中用-for-遍历多次执行-goroutine会存在什么问题"><a href="#go-中用-for-遍历多次执行-goroutine会存在什么问题" class="headerlink" title="go 中用 for 遍历多次执行 goroutine会存在什么问题"></a>go 中用 for 遍历多次执行 goroutine会存在什么问题</h1><ol><li><p>假如在协程中打印for的下标i或当前下标的元素,会随机打印载体中的元素.</p><p> 原因有二:</p><ul><li><p>golang是值拷贝传递 for循环很快就执行完了，但是创建的10个协程需要做初始化。上下文准备，堆栈，和内核态的线程映射关系的工作，是需要时间的，比for慢，等都准备好了的时候，会同时访问i。这个时候的i肯定是for执行完成后的下标。（也可能有个别的协程已经准备好了，取i的时候，正好是5，或者7，就输出了这些数字）。</p><p> 解决的方法就是闭包，给匿名函数增加入参，因为是值传递，所以每次for创建一个协程的时候，会拷贝一份i传到这个协程里面去。 或者在开启协程之前声明一个新的变量 &#x3D; i。</p></li></ul></li><li><p>假如当前for是并发读取文件</p></li></ol><p>程序会panic:too many open files</p><p>解决的方法:通过带缓冲的channel和sync.waitgroup控制协程并发量。</p><h1 id="空结构体占不占内存空间？-为什么使用空结构体？"><a href="#空结构体占不占内存空间？-为什么使用空结构体？" class="headerlink" title="空结构体占不占内存空间？ 为什么使用空结构体？"></a>空结构体占不占内存空间？ 为什么使用空结构体？</h1><p>准确的来说，空结构体有一个特殊起点： zerobase 变量。zerobase是一个占用 8 个字节的uintptr全局变量。每次定义 struct {} 类型的变量，编译器只是把zerobase变量的地址给出去。也就是说空结构体的变量的内存地址都是一样的。</p><h1 id="进程、线程、协程的区别？"><a href="#进程、线程、协程的区别？" class="headerlink" title="进程、线程、协程的区别？"></a>进程、线程、协程的区别？</h1><p>概念定义</p><p>进程： 进程是一个具有一定独立功能的程序关于某个数据集合上的一次运行活动，是系统资源分配和独立运行的最小单位。<br>线程： 线程是进程的一个执行单元，是任务调度和系统执行的最小单位。<br>协程： 协程是一种用户态的轻量级线程，协程的调度完全由用户控制。</p><p>进程与线程的区别</p><ol><li>根本区别：进程是操作系统资源分配和独立运行的最小单位；线程是任务调度和系统执行的最小单位。</li><li>地址空间区别： 每个进程都有独立的地址空间，一个进程崩溃不影响其它进程；一个进程中的多个线程共享该进程的地址空间，一个线程的非法操作会使整个进程崩溃。</li><li>上下文切换开销区别： 每个进程有独立的代码和数据空间，进程之间上下文切换开销较大；线程组共享代码和数据空间，线程之间切换的开销较小。</li></ol><p>线程和协程的区别</p><ol><li>内存开销：创建一个协程需要2kb, 栈空间不够会自动扩容， 创建一个线程需要1M空间。</li><li>创建和销毁：创建线程是和操作系统打交道，内核态 开销更大， 协程是由runtime管理，属于用户态 开销小。</li><li>切换成本：线程切换 需要保存各种寄存器，切换时间大概在1500-2000us, 协程保存的寄存器比较少， 切换时间大概在200us, 它能执行更多的指令。</li></ol><h1 id="defer-recover-panic-执行顺序"><a href="#defer-recover-panic-执行顺序" class="headerlink" title="defer recover panic 执行顺序"></a>defer recover panic 执行顺序</h1><p>执行顺序应该为panic、defer、recover</p><ul><li>发生panic的函数并不会立刻返回，而是先层层函数执行defer，再返回。如果有办法将panic捕获到panic，就正常处理（若是外部函数捕获到，则外部函数只执行defer），如果没有没有捕获，程序直接异常终止。</li><li>Go语言提供了recover内置函数。前面提到，一旦panic逻辑就会走到defer（<strong>defer必须在panic的前面！</strong>)。调用recover函数将会捕获到当前的panic，被捕获到的panic就不会向上传递了</li><li>在panic发生时，<strong>在前面的defer中通过recover捕获这个panic，转化为错误通过返回值告诉方法调用者。</strong></li></ul><h1 id="如何解决孤儿进程的出现"><a href="#如何解决孤儿进程的出现" class="headerlink" title="如何解决孤儿进程的出现"></a>如何解决孤儿进程的出现</h1><p><strong>孤儿进程</strong>：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</p><p>解决方案</p><p>孤儿进程结束后会被 init 进程善后，并没有危害，而僵尸进程则会一直占着进程号，操作系统的进程数量有限则会受影响。</p><p><strong>僵尸进程</strong>：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</p><p>僵尸进程解决方案</p><p>进程等待—wait函数和waitpid函数<br>wait函数<br>创建一个子进程，子进程正常逻辑，父进程调用wait函数来进行等待，当子进程退出的时候，由于父进程在等待，所以子进程就不会变成僵尸进程<br>父进程一开始调用wait函数，就会阻塞在wait函数中，等待子进程<br>直到子进程退出，wait函数调用才返回，父进程接着执行wait函数之后的代码</p><h1 id="说一下reflect"><a href="#说一下reflect" class="headerlink" title="说一下reflect"></a>说一下reflect</h1><p>recflect是golang用来检测存储在接口变量内部(值value；类型concrete type) pair对的一种机制。它提供了两种类型（或者说两个方法）让我们可以很容易的访问接口变量内容，分别是reflect.ValueOf() 和 reflect.TypeOf()。</p><p>ValueOf用来获取输入参数接口中的数据的值，如果接口为空则返回0<br>TypeOf用来动态获取输入参数接口中的值的类型，如果接口为空则返回nil</p><h1 id="Golang-里怎么避免内存逃逸？"><a href="#Golang-里怎么避免内存逃逸？" class="headerlink" title="Golang 里怎么避免内存逃逸？"></a>Golang 里怎么避免内存逃逸？</h1><ol><li>不要盲目使用变量指针作为参数，虽然减少了复制，但变量逃逸的开销更大。</li><li>预先设定好slice长度，避免频繁超出容量，重新分配。</li><li>一个经验是，指针指向的数据大部分在堆上分配的，请注意。</li></ol><p>出现内存逃逸的情况有：</p><ol><li><p>发送指针或带有指针的值到channel，因为编译时候无法知道那个goroutine会在channel接受数据，编译器无法知道什么时候释放。</p></li><li><p>在一个切片上存储指针或带指针的值。比如[]*string，导致切片内容逃逸，其引用值一直在堆上。</p></li><li><p>切片的append导致超出容量，切片重新分配地址，切片背后的存储基于运行时的数据进行扩充，就会在堆上分配。</p></li><li><p>调用接口类型时，接口类型的方法调用是动态调度，实际使用的具体实现只能在运行时确定，如一个接口类型为io.Reader的变量r，对r.Read(b)的调用将导致r的值和字节片b的后续转义并因此分配到堆上。</p></li><li><p>在方法内把局部变量指针返回，被外部引用，其生命周期大于栈，导致内存溢出。</p></li></ol><h1 id="defer的执行顺序"><a href="#defer的执行顺序" class="headerlink" title="defer的执行顺序"></a>defer的执行顺序</h1><ol><li>一个函数中多个defer的执行顺序</li></ol><p>defer的作用就是把defer关键字之后的函数压入一个栈中延迟执行，多个defer的执行顺序是后进先出</p><ol start="2"><li>defer、return、返回值的执行返回顺序</li></ol><p>return最先执行，先将结果写入返回值中（即赋值）；接着defer开始执行一些收尾工作；最后函数携带当前返回值退出（即返回值）</p><h1 id="go-init-的执行顺序，注意是不按导入规则的（这里是编译时按文件名的顺序执行的）"><a href="#go-init-的执行顺序，注意是不按导入规则的（这里是编译时按文件名的顺序执行的）" class="headerlink" title="go init 的执行顺序，注意是不按导入规则的（这里是编译时按文件名的顺序执行的）"></a>go init 的执行顺序，注意是不按导入规则的（这里是编译时按文件名的顺序执行的）</h1><ol><li>init函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等</li><li>每个包可以拥有多个init函数</li><li>包的每个源文件也可以拥有多个init函数</li><li>同一个包中多个init函数的执行顺序go语言没有明确的定义(说明)</li><li>不同包的init函数按照包导入的依赖关系决定该初始化函数的执行顺序</li><li>init函数不能被其他函数调用，而是在main函数执行之前，自动被调用</li></ol></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/golang/" rel="tag"># golang</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2023/01/31/2023-01-31-%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" rel="prev" title="golang内存模型"><i class="fa fa-chevron-left"></i> golang内存模型</a></div><div class="post-nav-item"> <a href="/2023/02/22/2023-02-22-gin%E6%98%AF%E6%80%8E%E6%A0%B7%E7%AE%A1%E7%90%86%E8%B7%AF%E7%94%B1%E7%9A%84/" rel="next" title="gin的路由管理">gin的路由管理<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Go%E8%AF%AD%E8%A8%80Slice%E6%98%AF%E5%90%A6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">1.</span> <span class="nav-text">Go语言Slice是否线程安全</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#slice%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E6%9E%90"><span class="nav-number">2.</span> <span class="nav-text">slice内存泄漏分析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Golang-Slice-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.</span> <span class="nav-text">Golang Slice 的底层实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#golang%E9%87%8C%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87"><span class="nav-number">4.</span> <span class="nav-text">golang里的数组和切片</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%B9%E5%B7%B2%E7%BB%8F%E5%85%B3%E9%97%AD%E7%9A%84channel%E8%BF%9B%E8%A1%8C%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="nav-number">5.</span> <span class="nav-text">对已经关闭的channel进行读写操作会发生什么?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#go-struct-%E8%83%BD%E4%B8%8D%E8%83%BD%E6%AF%94%E8%BE%83"><span class="nav-number">6.</span> <span class="nav-text">go struct 能不能比较</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%A0%B9%E6%8D%AE%E4%B8%8B%E6%A0%87%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E5%90%97%EF%BC%9F"><span class="nav-number">7.</span> <span class="nav-text">数组是如何实现根据下标随机访问数组元素的吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GMP%E6%A8%A1%E5%9E%8B"><span class="nav-number">8.</span> <span class="nav-text">GMP模型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#go%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%A7%A6%E5%8F%91"><span class="nav-number">9.</span> <span class="nav-text">go垃圾回收，什么时候触发</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#gc%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">10.</span> <span class="nav-text">gc算法有哪些？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#make-%E4%B8%8E-new-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">11.</span> <span class="nav-text">make 与 new 的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%ADchannel%E6%98%AF%E5%90%A6%E5%85%B3%E9%97%AD%EF%BC%9F"><span class="nav-number">12.</span> <span class="nav-text">如何判断channel是否关闭？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#go-%E7%9A%84%E9%94%81%E6%98%AF%E5%8F%AF%E9%87%8D%E5%85%A5%E7%9A%84%E5%90%97%EF%BC%9F"><span class="nav-number">13.</span> <span class="nav-text">go 的锁是可重入的吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#go-%E4%B8%AD%E7%94%A8-for-%E9%81%8D%E5%8E%86%E5%A4%9A%E6%AC%A1%E6%89%A7%E8%A1%8C-goroutine%E4%BC%9A%E5%AD%98%E5%9C%A8%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="nav-number">14.</span> <span class="nav-text">go 中用 for 遍历多次执行 goroutine会存在什么问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93%E5%8D%A0%E4%B8%8D%E5%8D%A0%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%EF%BC%9F-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%9F"><span class="nav-number">15.</span> <span class="nav-text">空结构体占不占内存空间？ 为什么使用空结构体？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">16.</span> <span class="nav-text">进程、线程、协程的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#defer-recover-panic-%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">17.</span> <span class="nav-text">defer recover panic 执行顺序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%87%BA%E7%8E%B0"><span class="nav-number">18.</span> <span class="nav-text">如何解决孤儿进程的出现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8Breflect"><span class="nav-number">19.</span> <span class="nav-text">说一下reflect</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Golang-%E9%87%8C%E6%80%8E%E4%B9%88%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%EF%BC%9F"><span class="nav-number">20.</span> <span class="nav-text">Golang 里怎么避免内存逃逸？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#defer%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">21.</span> <span class="nav-text">defer的执行顺序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#go-init-%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%8C%E6%B3%A8%E6%84%8F%E6%98%AF%E4%B8%8D%E6%8C%89%E5%AF%BC%E5%85%A5%E8%A7%84%E5%88%99%E7%9A%84%EF%BC%88%E8%BF%99%E9%87%8C%E6%98%AF%E7%BC%96%E8%AF%91%E6%97%B6%E6%8C%89%E6%96%87%E4%BB%B6%E5%90%8D%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%89"><span class="nav-number">22.</span> <span class="nav-text">go init 的执行顺序，注意是不按导入规则的（这里是编译时按文件名的顺序执行的）</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">enpsl</p><div class="site-description" itemprop="description">my blog</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">50</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">9</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2023</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">enpsl</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动</div></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script></body></html>