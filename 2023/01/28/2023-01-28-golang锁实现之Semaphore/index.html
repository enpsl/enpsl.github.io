<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"enpsl.github.io",root:"/",scheme:"Muse",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="Semaphore信号量是在并发编程中常见的一种同步机制，在需要控制访问资源的进程数量时就会用到信号量，它会保证持有的计数器在 0 到初始化的权重之间波动。  每次获取资源时都会将信号量中的计数器减去对应的数值，在释放时重新加回来； 当遇到计数器大于信号量大小时，会进入休眠等待其他线程释放信号；  在go的锁中的底层结构体实现过程中可以看到sema这个关键词，如go的互斥锁或读写锁 1234567"><meta property="og:type" content="article"><meta property="og:title" content="golang锁实现之Semaphore"><meta property="og:url" content="https://enpsl.github.io/2023/01/28/2023-01-28-golang%E9%94%81%E5%AE%9E%E7%8E%B0%E4%B9%8BSemaphore/index.html"><meta property="og:site_name" content="彭诗亮的博客"><meta property="og:description" content="Semaphore信号量是在并发编程中常见的一种同步机制，在需要控制访问资源的进程数量时就会用到信号量，它会保证持有的计数器在 0 到初始化的权重之间波动。  每次获取资源时都会将信号量中的计数器减去对应的数值，在释放时重新加回来； 当遇到计数器大于信号量大小时，会进入休眠等待其他线程释放信号；  在go的锁中的底层结构体实现过程中可以看到sema这个关键词，如go的互斥锁或读写锁 1234567"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-01-28T11:30:00.000Z"><meta property="article:modified_time" content="2023-01-28T09:59:02.526Z"><meta property="article:author" content="enpsl"><meta property="article:tag" content="操作系统"><meta property="article:tag" content="golang"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://enpsl.github.io/2023/01/28/2023-01-28-golang%E9%94%81%E5%AE%9E%E7%8E%B0%E4%B9%8BSemaphore/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>golang锁实现之Semaphore | 彭诗亮的博客</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">彭诗亮的博客</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档</a></li></ul></nav></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2023/01/28/2023-01-28-golang%E9%94%81%E5%AE%9E%E7%8E%B0%E4%B9%8BSemaphore/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> golang锁实现之Semaphore</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-01-28 19:30:00" itemprop="dateCreated datePublished" datetime="2023-01-28T19:30:00+08:00">2023-01-28</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>信号量是在并发编程中常见的一种同步机制，在需要控制访问资源的进程数量时就会用到信号量，它会保证持有的计数器在 0 到初始化的权重之间波动。</p><ul><li>每次获取资源时都会将信号量中的计数器减去对应的数值，在释放时重新加回来；</li><li>当遇到计数器大于信号量大小时，会进入休眠等待其他线程释放信号；</li></ul><p>在go的锁中的底层结构体实现过程中可以看到<code>sema</code>这个关键词，如go的互斥锁或读写锁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	state <span class="type">int32</span></span><br><span class="line">	sema  <span class="type">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    w           Mutex  <span class="comment">// held if there are pending writers</span></span><br><span class="line">    writerSem   <span class="type">uint32</span> <span class="comment">// semaphore for writers to wait for completing readers</span></span><br><span class="line">    readerSem   <span class="type">uint32</span> <span class="comment">// semaphore for readers to wait for completing writers</span></span><br><span class="line">    readerCount <span class="type">int32</span>  <span class="comment">// number of pending readers</span></span><br><span class="line">    readerWait  <span class="type">int32</span>  <span class="comment">// number of departing readers</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h2><p>回顾下操作系统中信号量编程的机制</p><p>用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现了进程互斥、进程同步</p><p>信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量），可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为1的信号量 。</p><p><strong>原语</strong>是一种特殊的程序段，其执行只能一气呵成，不可被中断。 原语是由关中断&#x2F;开中断指令实现 的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”<br>因此如果能把进入区、退出区的操作都用， “原语”实现，使这些操作能 一气呵成”就能避免问题。</p><p><strong>一对原语</strong>：<code>wait(s)</code> 原语 和 <code>signall(S)</code>原语， 可以把原语理解为我们自己写的函数，函数名分别为 <code>wait</code> 和 <code>signal</code>，括号里的信号量<code>S</code> 其实就是两数调用时传入的一个参数。</p><p><code>wait</code>、<code>signal</code> 原语常简称为<code>P</code>、<code>V</code>操作（来自荷兰语 proberen 和 verhogen）</p><p>我们可以把信号量机制互斥用如下代码实现表述出来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span></span></span><br><span class="line"><span class="class">&#125; <span class="title">semaphore</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">wait</span> (<span class="title">semaphore</span> <span class="title">S</span>) &#123;</span> </span><br><span class="line">    S.value--;</span><br><span class="line">    <span class="keyword">if</span> (S.value &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        block(S.L)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span> <span class="params">(semaphore S)</span> &#123; </span><br><span class="line">    S.value++;</span><br><span class="line">    <span class="keyword">if</span> (S.value &lt;= <span class="number">0</span> ) &#123;</span><br><span class="line">        wakeup(S.L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>信号量机制通过休眠队列和wakeup(唤醒)block(挂起)机制实现</p></blockquote><h2 id="go的Semaphore的实现"><a href="#go的Semaphore的实现" class="headerlink" title="go的Semaphore的实现"></a>go的Semaphore的实现</h2><p>go里面sema的实现主要在<code>runtime/sema.go</code>文件中</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>go的<code>runtime</code>有一个全局变量<code>semtable</code>，它放置了所有的信号量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> semtable semTable</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prime to not correlate with any user patterns.</span></span><br><span class="line"><span class="keyword">const</span> semTabSize = <span class="number">251</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> semTable [semTabSize]<span class="keyword">struct</span> &#123;</span><br><span class="line">	root semaRoot</span><br><span class="line">	pad  [cpu.CacheLinePadSize - unsafe.Sizeof(semaRoot&#123;&#125;)]<span class="type">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个信号量使用semaRoot结构体来表示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> semaRoot <span class="keyword">struct</span> &#123;</span><br><span class="line">	lock  mutex</span><br><span class="line">	treap *sudog <span class="comment">// 平衡树的根节点</span></span><br><span class="line">	nwait <span class="type">uint32</span> <span class="comment">// Number of waiters. Read w/o the lock.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原语P"><a href="#原语P" class="headerlink" title="原语P"></a>原语P</h3><p><code>原语P</code>即是<code>wait</code>,在并发编程信号同步过程中用来进行阻塞等待，go的<code>sema</code>主要通过<code>semacquire1</code>来实现<code>wait</code>,通过<code>sync.runtime_Semacquire</code>来调用</p><p><code>semacquire1</code>流程:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">semacquire1</span><span class="params">(addr *<span class="type">uint32</span>, lifo <span class="type">bool</span>, profile semaProfileFlags, skipframes <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	gp := getg()</span><br><span class="line">	<span class="keyword">if</span> gp != gp.m.curg &#123;</span><br><span class="line">		throw(<span class="string">&quot;semacquire not on the G stack&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Easy case.</span></span><br><span class="line">	<span class="keyword">if</span> cansemacquire(addr) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Harder case:</span></span><br><span class="line">	<span class="comment">//	increment waiter count</span></span><br><span class="line">	<span class="comment">//	try cansemacquire one more time, return if succeeded</span></span><br><span class="line">	<span class="comment">//	enqueue itself as a waiter</span></span><br><span class="line">	<span class="comment">//	sleep</span></span><br><span class="line">	<span class="comment">//	(waiter descriptor is dequeued by signaler)</span></span><br><span class="line">	s := acquireSudog()</span><br><span class="line">	root := semtable.rootFor(addr)</span><br><span class="line">	t0 := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">	s.releasetime = <span class="number">0</span></span><br><span class="line">	s.acquiretime = <span class="number">0</span></span><br><span class="line">	s.ticket = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> profile&amp;semaBlockProfile != <span class="number">0</span> &amp;&amp; blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">		t0 = cputicks()</span><br><span class="line">		s.releasetime = <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> profile&amp;semaMutexProfile != <span class="number">0</span> &amp;&amp; mutexprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> t0 == <span class="number">0</span> &#123;</span><br><span class="line">			t0 = cputicks()</span><br><span class="line">		&#125;</span><br><span class="line">		s.acquiretime = t0</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		lockWithRank(&amp;root.lock, lockRankRoot)</span><br><span class="line">		<span class="comment">// Add ourselves to nwait to disable &quot;easy case&quot; in semrelease.</span></span><br><span class="line">		atomic.Xadd(&amp;root.nwait, <span class="number">1</span>)</span><br><span class="line">		<span class="comment">// Check cansemacquire to avoid missed wakeup.</span></span><br><span class="line">		<span class="keyword">if</span> cansemacquire(addr) &#123;</span><br><span class="line">			atomic.Xadd(&amp;root.nwait, <span class="number">-1</span>)</span><br><span class="line">			unlock(&amp;root.lock)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Any semrelease after the cansemacquire knows we&#x27;re waiting</span></span><br><span class="line">		<span class="comment">// (we set nwait above), so go to sleep.</span></span><br><span class="line">		root.queue(addr, s, lifo)</span><br><span class="line">		goparkunlock(&amp;root.lock, waitReasonSemacquire, traceEvGoBlockSync, <span class="number">4</span>+skipframes)</span><br><span class="line">		<span class="keyword">if</span> s.ticket != <span class="number">0</span> || cansemacquire(addr) &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> s.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">		blockevent(s.releasetime-t0, <span class="number">3</span>+skipframes)</span><br><span class="line">	&#125;</span><br><span class="line">	releaseSudog(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分步骤分析</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   gp := getg()</span><br><span class="line"><span class="keyword">if</span> gp != gp.m.curg &#123;</span><br><span class="line">	throw(<span class="string">&quot;semacquire not on the G stack&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一段主要是用来获取sema的当前协程栈，如果拿不到的话会抛出异常</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> cansemacquire(addr) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cansemacquire</span><span class="params">(addr *<span class="type">uint32</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        v := atomic.Load(addr)</span><br><span class="line">        <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> atomic.Cas(addr, v, v<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>atomic.Load</code>和<code>atomic.Cas</code>是原语操作：这段代码可以理解为，判断<code>addr==0</code>,如果为<code>0</code>说明<code>addr</code>被获取过了，要去走下面的流程判断是否需要阻塞，不为<code>0</code>说明<code>addr</code>拿到成功，对<code>addr</code>进行<code>-1</code>操作,此时函数直接<code>return</code>，不会发生阻塞</p><p><code>atomic.Cas</code>的汇编实现</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TEXT ·Cas(SB),NOSPLIT,$0-17</span><br><span class="line">	MOVQ	ptr+0(FP), BX</span><br><span class="line">	MOVL	old+8(FP), AX</span><br><span class="line">	MOVL	new+12(FP), CX</span><br><span class="line">	LOCK</span><br><span class="line">	CMPXCHGL	CX, 0(BX)</span><br><span class="line">	SETEQ	ret+16(FP)</span><br><span class="line">	RET</span><br></pre></td></tr></table></figure><blockquote><p>基于汇编对cpu硬件加锁实现的原子操作</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s := acquireSudog()</span><br><span class="line">root := semtable.rootFor(addr)</span><br><span class="line">t0 := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">s.releasetime = <span class="number">0</span></span><br><span class="line">s.acquiretime = <span class="number">0</span></span><br><span class="line">s.ticket = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>这一部分就是拿到<code>sudog</code>和<code>root</code>队列</p><p><code>root</code>和<code>s</code>的作用:</p><ul><li><p><code>semacquire1</code>会在<code>semtable</code>数组中找一个元素和它对应上。每个元素都有一个<code>root</code>，这个<code>root</code>是<code>Treap</code>树</p></li><li><p>最后<code>addr</code>变成一个树节点，这个树节点，有自己的一个队列，专门放被阻塞的<code>goroutine</code>。叫它阻塞队列吧。 这个阻塞队列是个双端队列，头尾都可以进。</p></li><li><p><code>semacquire1</code>把当前<code>goroutine</code>相关元数据放进阻塞队列之后，就挂起了。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    lockWithRank(&amp;root.lock, lockRankRoot)</span><br><span class="line">    <span class="comment">// 记录root等待队列数量+1</span></span><br><span class="line">    atomic.Xadd(&amp;root.nwait, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 检测addr如果不为0了，就进行唤醒</span></span><br><span class="line">    <span class="keyword">if</span> cansemacquire(addr) &#123;</span><br><span class="line">        atomic.Xadd(&amp;root.nwait, <span class="number">-1</span>)</span><br><span class="line">        unlock(&amp;root.lock)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将sudog协程放入到root队列</span></span><br><span class="line">    root.queue(addr, s, lifo)</span><br><span class="line">	<span class="comment">// 执行挂起</span></span><br><span class="line">    goparkunlock(&amp;root.lock, waitReasonSemacquire, traceEvGoBlockSync, <span class="number">4</span>+skipframes)</span><br><span class="line">    <span class="keyword">if</span> s.ticket != <span class="number">0</span> || cansemacquire(addr) &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这部分的死循环可以理解为阻塞的过程，在<code>addr</code>未唤醒之前，会将当前<code>sudog</code>假如阻塞队列，并挂起等待</p><h3 id="原语V"><a href="#原语V" class="headerlink" title="原语V"></a>原语V</h3><p><code>原语V</code>即是<code>signal</code>,在并发编程信号同步过程中用来进行唤醒，go的<code>sema</code>主要通过<code>semrelease1</code>来实现<code>signal</code>,通过<code>sync.runtime_Semacquire</code>来调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:linkname sync_runtime_Semrelease sync.runtime_Semrelease</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_Semrelease</span><span class="params">(addr *<span class="type">uint32</span>, handoff <span class="type">bool</span>, skipframes <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	semrelease1(addr, handoff, skipframes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>semrelease1</code>流程</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">semrelease1</span><span class="params">(addr *<span class="type">uint32</span>, handoff <span class="type">bool</span>, skipframes <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	root := semtable.rootFor(addr)</span><br><span class="line">	atomic.Xadd(addr, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Easy case: no waiters?</span></span><br><span class="line">	<span class="comment">// This check must happen after the xadd, to avoid a missed wakeup</span></span><br><span class="line">	<span class="comment">// (see loop in semacquire).</span></span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;root.nwait) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Harder case: search for a waiter and wake it.</span></span><br><span class="line">	lockWithRank(&amp;root.lock, lockRankRoot)</span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;root.nwait) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// The count is already consumed by another goroutine,</span></span><br><span class="line">		<span class="comment">// so no need to wake up another goroutine.</span></span><br><span class="line">		unlock(&amp;root.lock)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	s, t0 := root.dequeue(addr)</span><br><span class="line">	<span class="keyword">if</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">		atomic.Xadd(&amp;root.nwait, <span class="number">-1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	unlock(&amp;root.lock)</span><br><span class="line">	<span class="keyword">if</span> s != <span class="literal">nil</span> &#123; <span class="comment">// May be slow or even yield, so unlock first</span></span><br><span class="line">		acquiretime := s.acquiretime</span><br><span class="line">		<span class="keyword">if</span> acquiretime != <span class="number">0</span> &#123;</span><br><span class="line">			mutexevent(t0-acquiretime, <span class="number">3</span>+skipframes)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> s.ticket != <span class="number">0</span> &#123;</span><br><span class="line">			throw(<span class="string">&quot;corrupted semaphore ticket&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> handoff &amp;&amp; cansemacquire(addr) &#123;</span><br><span class="line">			s.ticket = <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		readyWithTime(s, <span class="number">5</span>+skipframes)</span><br><span class="line">		<span class="keyword">if</span> s.ticket == <span class="number">1</span> &amp;&amp; getg().m.locks == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// Direct G handoff</span></span><br><span class="line">			<span class="comment">// readyWithTime has added the waiter G as runnext in the</span></span><br><span class="line">			<span class="comment">// current P; we now call the scheduler so that we start running</span></span><br><span class="line">			<span class="comment">// the waiter G immediately.</span></span><br><span class="line">			<span class="comment">// Note that waiter inherits our time slice: this is desirable</span></span><br><span class="line">			<span class="comment">// to avoid having a highly contended semaphore hog the P</span></span><br><span class="line">			<span class="comment">// indefinitely. goyield is like Gosched, but it emits a</span></span><br><span class="line">			<span class="comment">// &quot;preempted&quot; trace event instead and, more importantly, puts</span></span><br><span class="line">			<span class="comment">// the current G on the local runq instead of the global one.</span></span><br><span class="line">			<span class="comment">// We only do this in the starving regime (handoff=true), as in</span></span><br><span class="line">			<span class="comment">// the non-starving case it is possible for a different waiter</span></span><br><span class="line">			<span class="comment">// to acquire the semaphore while we are yielding/scheduling,</span></span><br><span class="line">			<span class="comment">// and this would be wasteful. We wait instead to enter starving</span></span><br><span class="line">			<span class="comment">// regime, and then we start to do direct handoffs of ticket and</span></span><br><span class="line">			<span class="comment">// P.</span></span><br><span class="line">			<span class="comment">// See issue 33747 for discussion.</span></span><br><span class="line">			goyield()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分步骤分析</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root := semtable.rootFor(addr)</span><br><span class="line">atomic.Xadd(addr, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>到阻塞队列中拿到根结点，并对当前<code>addr</code>进行<code>加1</code>释放</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> atomic.Load(&amp;root.nwait) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对当前代码区加锁</span></span><br><span class="line">lockWithRank(&amp;root.lock, lockRankRoot)</span><br><span class="line"><span class="keyword">if</span> atomic.Load(&amp;root.nwait) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// 计数已经被其他goroutine消费，所以不需要唤醒其他goroutine</span></span><br><span class="line">    unlock(&amp;root.lock)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从阻塞队列中找到一个addr</span></span><br><span class="line">s, t0 := root.dequeue(addr)</span><br><span class="line"><span class="keyword">if</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="comment">// 等待队列计数-1</span></span><br><span class="line">    atomic.Xadd(&amp;root.nwait, <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当前代码区释放锁</span></span><br><span class="line">unlock(&amp;root.lock)</span><br></pre></td></tr></table></figure><p>这段代码的含义可以理解为，对当前区域加临时锁，主要目的从阻塞队列获取一个addr，然后检测下当前根结点的队列等待数量如果为0，说明都释放过了，直接 <code>return</code> 即可，最后对当前代码执行区域释放锁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">readyWithTime(s, <span class="number">5</span>+skipframes)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readyWithTime</span><span class="params">(s *sudog, traceskip <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">        s.releasetime = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line">    goready(s.g, traceskip)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到这里会将<code>sudog</code>的协程唤醒执行,基本释放操作到这里就结束了，后面的代码主要是针对饥饿状态下<code>g</code>的处理</p><h2 id="go的Semaphore的应用"><a href="#go的Semaphore的应用" class="headerlink" title="go的Semaphore的应用"></a>go的Semaphore的应用</h2><p>go中在互斥锁和读写锁中都用到了<code>Semaphore</code>,在<code>sync.mutex</code>和<code>sync.rwmutex</code>都有调用，当然，在其他结构体中比如waitgroup也有用到，这里只列出使用场景比较高的结构体，通过<code>runtime_SemacquireMutex</code>和<code>runtime_Semrelease</code>实现调用<br>那么为什么会采用<code>Semaphore</code>呢,主要目的还是提高高并发场景下锁的性能，正常情况下可以通过<code>CAS</code>中的自旋也可以实现协程中的通信，但是自旋操作在高并发场景下对cpu资源消耗大，并且会阻塞其它协程，影响性能，通过<code>Semaphore</code>中维护休眠队列,对单一协程进行调度，防止全局阻塞<br>提高了协程间的调度效率,并且在信号同步的<code>P</code>中，go的阻塞是通过<code>gopark</code>实现的，<code>gopark</code>类似与<code>time.sleep</code>,是一种挂起机制，不会大量消耗cpu资源，所以说，go的锁中利用了<code>Semaphore</code>实现调度，也是它在高并发场景中一种优势的体现</p></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a> <a href="/tags/golang/" rel="tag"># golang</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2023/01/21/2023-01-21-Goroutine/" rel="prev" title="神奇的Goroutine"><i class="fa fa-chevron-left"></i> 神奇的Goroutine</a></div><div class="post-nav-item"></div></div></footer></article></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Semaphore"><span class="nav-number">1.</span> <span class="nav-text">Semaphore</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6"><span class="nav-number">2.</span> <span class="nav-text">信号量机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#go%E7%9A%84Semaphore%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.</span> <span class="nav-text">go的Semaphore的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E8%AF%ADP"><span class="nav-number">3.2.</span> <span class="nav-text">原语P</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E8%AF%ADV"><span class="nav-number">3.3.</span> <span class="nav-text">原语V</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#go%E7%9A%84Semaphore%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">4.</span> <span class="nav-text">go的Semaphore的应用</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">enpsl</p><div class="site-description" itemprop="description">my blog</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">39</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">7</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2023</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">enpsl</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动</div></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script></body></html>