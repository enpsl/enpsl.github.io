<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"enpsl.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.14.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="GO MAP原理hmap结构 1234567891011type hmap struct &amp;#123;	count     int    &#x2F;&#x2F; map的元素数量	flags     uint8  &#x2F;&#x2F;状态标识，用于控制goroutine写入和扩容的状态	B         uint8  &#x2F;&#x2F; 用于计算buckets数量，计算公式2^B	noverflow uint16 &#x2F;&#x2F; 溢出桶数量	hash0"><meta property="og:type" content="article"><meta property="og:title" content="GO MAP原理"><meta property="og:url" content="https://enpsl.github.io/2023/01/17/2023-01-15-go-map%E5%8E%9F%E7%90%86/index.html"><meta property="og:site_name" content="彭诗亮的博客"><meta property="og:description" content="GO MAP原理hmap结构 1234567891011type hmap struct &amp;#123;	count     int    &#x2F;&#x2F; map的元素数量	flags     uint8  &#x2F;&#x2F;状态标识，用于控制goroutine写入和扩容的状态	B         uint8  &#x2F;&#x2F; 用于计算buckets数量，计算公式2^B	noverflow uint16 &#x2F;&#x2F; 溢出桶数量	hash0"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-01-17T11:30:00.000Z"><meta property="article:modified_time" content="2023-01-19T07:31:17.883Z"><meta property="article:author" content="enpsl"><meta property="article:tag" content="golang"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://enpsl.github.io/2023/01/17/2023-01-15-go-map%E5%8E%9F%E7%90%86/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://enpsl.github.io/2023/01/17/2023-01-15-go-map%E5%8E%9F%E7%90%86/","path":"2023/01/17/2023-01-15-go-map原理/","title":"GO MAP原理"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>GO MAP原理 | 彭诗亮的博客</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">彭诗亮的博客</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#GO-MAP%E5%8E%9F%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">GO MAP原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.1.</span> <span class="nav-text">初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#make"><span class="nav-number">1.1.1.</span> <span class="nav-text">make</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="nav-number">1.1.2.</span> <span class="nav-text">字面量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#makemap"><span class="nav-number">1.1.3.</span> <span class="nav-text">makemap</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A9%E5%AE%B9"><span class="nav-number">1.2.</span> <span class="nav-text">扩容</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%89%E9%87%8F%E6%89%A9%E5%AE%B9"><span class="nav-number">1.2.1.</span> <span class="nav-text">等量扩容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E7%AD%89%E9%87%8F%E6%89%A9%E5%AE%B9"><span class="nav-number">1.2.2.</span> <span class="nav-text">非等量扩容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE"><span class="nav-number">1.2.3.</span> <span class="nav-text">查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E5%85%A5"><span class="nav-number">1.2.4.</span> <span class="nav-text">写入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4"><span class="nav-number">1.2.5.</span> <span class="nav-text">删除</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">enpsl</p><div class="site-description" itemprop="description">my blog</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">31</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">7</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2023/01/17/2023-01-15-go-map%E5%8E%9F%E7%90%86/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"><meta itemprop="description" content="my blog"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="GO MAP原理 | 彭诗亮的博客"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> GO MAP原理</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-01-17 19:30:00" itemprop="dateCreated datePublished" datetime="2023-01-17T19:30:00+08:00">2023-01-17</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-01-19 15:31:17" itemprop="dateModified" datetime="2023-01-19T15:31:17+08:00">2023-01-19</time></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="GO-MAP原理"><a href="#GO-MAP原理" class="headerlink" title="GO MAP原理"></a>GO MAP原理</h1><p>hmap结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	count     <span class="type">int</span>    <span class="comment">// map的元素数量</span></span><br><span class="line">	flags     <span class="type">uint8</span>  <span class="comment">//状态标识，用于控制goroutine写入和扩容的状态</span></span><br><span class="line">	B         <span class="type">uint8</span>  <span class="comment">// 用于计算buckets数量，计算公式2^B</span></span><br><span class="line">	noverflow <span class="type">uint16</span> <span class="comment">// 溢出桶数量</span></span><br><span class="line">	hash0     <span class="type">uint32</span> <span class="comment">// hash 种子</span></span><br><span class="line">	buckets    unsafe.Pointer <span class="comment">// 2^B Buckets count ==0时可能为nil(此处是万能指针类型，实际是对应下面的bmap)</span></span><br><span class="line">	oldbuckets unsafe.Pointer <span class="comment">// 扩容后的旧bucket数组</span></span><br><span class="line">	nevacuate  <span class="type">uintptr</span>        <span class="comment">// 迁移计数器，此指针之前的所有桶已被迁移，即nevacuate指向桶数组已迁移桶的最高下标</span></span><br><span class="line">	extra *mapextra <span class="comment">//溢出桶结构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	tophash [bucketCnt]<span class="type">uint8</span> <span class="comment">// bucketCnt == 8每个桶固定8个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><p>通过make函数和hint指定元素数量来初始化map</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, hint)</span><br></pre></td></tr></table></figure><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>目前的现代编程语言基本都支持使用字面量的方式初始化哈希，一般都会使用 key: value 的语法来表示键值对，Go 语言中也不例外：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hash := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">	<span class="string">&quot;1&quot;</span>: <span class="number">2</span>,</span><br><span class="line">	<span class="string">&quot;3&quot;</span>: <span class="number">4</span>,</span><br><span class="line">	<span class="string">&quot;5&quot;</span>: <span class="number">6</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当哈希表中的元素数量少于或者等于 25 个时，编译器会将字面量初始化的结构体转换成以下的代码，将所有的键值对一次加入到哈希表中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">hash[<span class="string">&quot;1&quot;</span>] = <span class="number">2</span></span><br><span class="line">hash[<span class="string">&quot;3&quot;</span>] = <span class="number">4</span></span><br><span class="line">hash[<span class="string">&quot;5&quot;</span>] = <span class="number">6</span></span><br></pre></td></tr></table></figure><p>一旦哈希表中元素的数量超过了 25 个，编译器会创建两个数组分别存储键和值，这些键值对会通过如下所示的 for 循环加入哈希：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">26</span>)</span><br><span class="line">vstatk := []<span class="type">string</span>&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, ... ， <span class="string">&quot;26&quot;</span>&#125;</span><br><span class="line">vstatv := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ... , <span class="number">26</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(vstak); i++ &#123;</span><br><span class="line">    hash[vstatk[i]] = vstatv[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论是<code>字面量</code>或是<code>make</code>方式map底层都是通过<code>makemap</code>函数来创建</p><h3 id="makemap"><a href="#makemap" class="headerlink" title="makemap"></a>makemap</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *maptype, hint <span class="type">int</span>, h *hmap)</span></span> *hmap &#123;</span><br><span class="line">	mem, overflow := math.MulUintptr(<span class="type">uintptr</span>(hint), t.bucket.size)</span><br><span class="line">	<span class="keyword">if</span> overflow || mem &gt; maxAlloc &#123;</span><br><span class="line">		hint = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// initialize Hmap</span></span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">		h = <span class="built_in">new</span>(hmap)</span><br><span class="line">	&#125;</span><br><span class="line">	h.hash0 = fastrand()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find the size parameter B which will hold the requested # of elements.</span></span><br><span class="line">	<span class="comment">// For hint &lt; 0 overLoadFactor returns false since hint &lt; bucketCnt.</span></span><br><span class="line">	B := <span class="type">uint8</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> overLoadFactor(hint, B) &#123;</span><br><span class="line">		B++</span><br><span class="line">	&#125;</span><br><span class="line">	h.B = B</span><br><span class="line"></span><br><span class="line">	<span class="comment">// allocate initial hash table</span></span><br><span class="line">	<span class="comment">// if B == 0, the buckets field is allocated lazily later (in mapassign)</span></span><br><span class="line">	<span class="comment">// If hint is large zeroing this memory could take a while.</span></span><br><span class="line">	<span class="keyword">if</span> h.B != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> nextOverflow *bmap</span><br><span class="line">		h.buckets, nextOverflow = makeBucketArray(t, h.B, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">			h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">			h.extra.nextOverflow = nextOverflow</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>makemap</code> 函数通过指定<code>hint</code>来通过<code>B</code>计算bucket数量<br>计算公式</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hint ≤ 2^B * 6.5</span><br></pre></td></tr></table></figure><p>通过B数量指定hmap会创建2^B个桶和一些溢出桶</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> b &gt;= <span class="number">4</span> &#123;</span><br><span class="line">	<span class="comment">// Add on the estimated number of overflow buckets</span></span><br><span class="line">	<span class="comment">// required to insert the median number of elements</span></span><br><span class="line">	<span class="comment">// used with this value of b.</span></span><br><span class="line">	nbuckets += bucketShift(b - <span class="number">4</span>)</span><br><span class="line">	sz := t.bucket.size * nbuckets</span><br><span class="line">	up := roundupsize(sz)</span><br><span class="line">	<span class="keyword">if</span> up != sz &#123;</span><br><span class="line">		nbuckets = up / t.bucket.size</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当桶的数量小于 2^4 时，由于数据较少、使用溢出桶的可能性较低，会省略创建的过程以减少额外开销；</li><li>当桶的数量多于 2^4 时，会额外创建 2^𝐵−4 个溢出桶；</li></ul><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>为什么需要扩容，当<code>溢出桶</code>承装元素超过8个时，溢出桶的<code>mapextra</code>指向新的溢出桶，直到能够满足承装元素数目,此时，hash查找会退化成链表查找，时间复杂度为O(n)<br>扩容判断条件:</p><ul><li>当前未在扩容状态并且负载因子&gt;&#x3D;6.5</li><li>有太多的<code>溢出桶</code><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">    hashGrow(t, h)</span><br><span class="line">    <span class="keyword">goto</span> again <span class="comment">// Growing the table invalidates everything, so try again</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> map扩容为渐进式扩容，只在map操作当前桶时才对当前桶进行扩容<br>扩容步骤分为<code>hashGrow</code>和<code>growWork</code></li><li><code>hashGrow</code>不做桶元素迁移，只是将当前桶指向oldbuckets，然后创建等量的buckets和溢出桶作为newbuckets指向hmap.buckets<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">h.B += bigger #更新B</span><br><span class="line">h.flags = flags #更新扩容状态</span><br><span class="line">h.oldbuckets = oldbuckets</span><br><span class="line">h.buckets = newbuckets</span><br><span class="line">h.nevacuate = <span class="number">0</span> #扩容计数器</span><br><span class="line">h.noverflow = <span class="number">0</span> #溢出桶数量</span><br></pre></td></tr></table></figure></li><li>growWork会在元素赋值是触发当前桶操作，然后对当前桶进行扩容,将将旧桶数据驱逐到新桶,操作步骤在growWork.evacuate</li></ul><p>evacuate里的扩容方式分为等量扩容和非等量扩容</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">    <span class="comment">// Only calculate y pointers if we&#x27;re growing bigger.</span></span><br><span class="line">    <span class="comment">// Otherwise GC can see bad pointers.</span></span><br><span class="line">    y := &amp;xy[<span class="number">1</span>]</span><br><span class="line">    y.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">    y.k = add(unsafe.Pointer(y.b), dataOffset)</span><br><span class="line">    y.e = add(y.k, bucketCnt*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="等量扩容"><a href="#等量扩容" class="headerlink" title="等量扩容"></a>等量扩容</h3><p>对hash后的key后B位计算桶号，然后将元素等量分配</p><p>例如：hash(a)的二进制为0101110001010110，扩容前B&#x3D;2，桶号为10&#x3D;2，扩容后桶号为110，桶号为110&#x3D;6，将元素平均分配到这两个桶</p><h3 id="非等量扩容"><a href="#非等量扩容" class="headerlink" title="非等量扩容"></a>非等量扩容</h3><p>非等量扩容不扩容桶的数量，由于之前产生过很多溢出桶，但是溢出桶的元素很稀疏，所以只是将桶序号重新整理，清到多余的溢出桶，然后整理到新的buckets，</p><p>##查找和写入</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><ul><li>查找主要分为<code>mapaccess1</code>和<code>mapaccess2</code>两个函数，区别就是<code>mapaccess2</code>在找到目标值时会多返回一个true，在未找到时会返回false</li><li>查找流程hmap里通过tophash找到对应buckets桶号,再到bmap里区寻找tophash高8位对应的key,如果不在当前桶就去溢出桶里找，如果溢出桶找不到说明元素不在map,返回false</li><li>如果查找时正在扩容，会判断oldbucktes是否为nil，不为nil找旧桶，缩减m找到旧桶编号去找旧桶元素位置<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//hash&amp;m找到桶编号作为偏移值找到对应的bmap结构体</span></span><br><span class="line">b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line"><span class="keyword">if</span> c := h.oldbuckets; c != <span class="literal">nil</span> &#123; 	<span class="comment">//存在旧桶，说明正在扩容状态中</span></span><br><span class="line">	<span class="keyword">if</span> !h.sameSizeGrow() &#123; 			<span class="comment">//判断是否翻倍扩容</span></span><br><span class="line">		m &gt;&gt;= <span class="number">1</span> <span class="comment">//翻倍扩容时，新的桶数是旧的2倍，m需要减半才能找到旧桶编号</span></span><br><span class="line">	&#125;</span><br><span class="line">	oldb := (*bmap)(add(c, (hash&amp;m)*<span class="type">uintptr</span>(t.bucketsize))) <span class="comment">//找到对应的旧桶位置</span></span><br><span class="line">	<span class="keyword">if</span> !evacuated(oldb) &#123;</span><br><span class="line">		b = oldb <span class="comment">//如果旧桶没有完成数据迁移，那么更新b指向旧桶bmap</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">top := tophash(hash) <span class="comment">//取hash值高八位，因为bmp.tophash中0-4是标志位，所以hash值小于5的自动加5</span></span><br><span class="line"> bucketloop:</span><br><span class="line"> <span class="comment">//遍历当前bmp和溢出桶</span></span><br><span class="line"> ...</span><br></pre></td></tr></table></figure></li></ul><h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><ul><li>函数首先会检查 <code>map</code> 的标志位 <code>flags</code>。如果 <code>flags</code> 的写标志位此时被置 1 了，说明有其他协程在执行“写”操作，进而导致程序 <code>panic</code>。这也说明了 <code>map</code> 对协程是不安全的。</li><li>扩容是渐进式的，如果 <code>map</code> 处在扩容的过程中，那么当 <code>key</code> 定位到了某个 <code>bucket</code> 后，需要确保这个 <code>bucket</code> 对应的老 <code>bucket</code> 完成了迁移过程。即老 <code>bucket</code> 里的 <code>key</code> 都要迁移到新的 <code>bucket</code> 中来（分裂到 2 个新 <code>bucket</code>），才能在新的 <code>bucket</code> 中进行插入或者更新的操作。<br>上面说的操作是在函数靠前的位置进行的，只有进行完了这个搬迁操作后，我们才能放心地在新 <code>bucket</code> 里定位 <code>key</code> 要安置的地址，再进行之后的操作。</li><li>如果这个 <code>bucket</code> 的 <code>8</code> 个 <code>key</code> 都已经放置满了，那在跳出循环后，发现 <code>inserti</code> 和 <code>insertk</code> 都是空，这时候需要在 <code>bucket</code> 后面挂上 <code>overflow bucket</code>。当然，也有可能是在 <code>overflow bucket</code> 后面再挂上一个 <code>overflow bucket</code>。这就说明，太多 <code>key hash</code> 到了此 <code>bucket</code>。<br>在正式安置 <code>key</code> 之前，还要检查 <code>map</code> 的状态，看它是否需要进行扩容。如果满足扩容的条件，就主动触发一次扩容操作。</li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul><li>首先会检查 <code>h.flags</code> 标志，如果发现写标位是 1，直接 <code>panic</code>，因为这表明有其他协程同时在进行写操作。</li><li>计算 key 的哈希，找到落入的 <code>bucket</code>。检查此 <code>map</code> 如果正在扩容的过程中，直接触发一次搬迁操作。</li><li>删除操作同样是两层循环，核心还是找到 <code>key</code> 的具体位置。寻找过程都是类似的，在 <code>bucket</code> 中挨个 <code>cell</code> 寻找。</li><li>找到对应位置后，对 <code>key</code> 或者 <code>value</code> 进行“清零”操作： 最后，将 <code>count</code> 值减 <code>1</code>，将对应位置的 <code>tophash</code> 值置成 <code>Empty</code>。</li></ul></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/golang/" rel="tag"># golang</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2023/01/15/2023-01-17-sync-map%E5%8E%9F%E7%90%86/" rel="prev" title="GO SYNC MAP原理"><i class="fa fa-chevron-left"></i> GO SYNC MAP原理</a></div><div class="post-nav-item"></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2023</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">enpsl</span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动</div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script></body></html>