<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"enpsl.github.io",root:"/",scheme:"Muse",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="GO MAP原理hmap结构 1234567891011type hmap struct &amp;#123;	count     int    &#x2F;&#x2F; map的元素数量	flags     uint8  &#x2F;&#x2F;状态标识，用于控制goroutine写入和扩容的状态	B         uint8  &#x2F;&#x2F; 用于计算buckets数量，计算公式2^B	noverflow uint16 &#x2F;&#x2F; 溢出桶数量	hash0"><meta property="og:type" content="article"><meta property="og:title" content="GO MAP原理"><meta property="og:url" content="https://enpsl.github.io/2023/01/17/2023-01-15-go-map%E5%8E%9F%E7%90%86/index.html"><meta property="og:site_name" content="彭诗亮的博客"><meta property="og:description" content="GO MAP原理hmap结构 1234567891011type hmap struct &amp;#123;	count     int    &#x2F;&#x2F; map的元素数量	flags     uint8  &#x2F;&#x2F;状态标识，用于控制goroutine写入和扩容的状态	B         uint8  &#x2F;&#x2F; 用于计算buckets数量，计算公式2^B	noverflow uint16 &#x2F;&#x2F; 溢出桶数量	hash0"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-01-17T11:30:00.000Z"><meta property="article:modified_time" content="2023-01-19T07:31:17.883Z"><meta property="article:author" content="enpsl"><meta property="article:tag" content="golang"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://enpsl.github.io/2023/01/17/2023-01-15-go-map%E5%8E%9F%E7%90%86/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>GO MAP原理 | 彭诗亮的博客</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">彭诗亮的博客</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档</a></li></ul></nav></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2023/01/17/2023-01-15-go-map%E5%8E%9F%E7%90%86/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> GO MAP原理</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-01-17 19:30:00" itemprop="dateCreated datePublished" datetime="2023-01-17T19:30:00+08:00">2023-01-17</time></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="GO-MAP原理"><a href="#GO-MAP原理" class="headerlink" title="GO MAP原理"></a>GO MAP原理</h1><p>hmap结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	count     <span class="type">int</span>    <span class="comment">// map的元素数量</span></span><br><span class="line">	flags     <span class="type">uint8</span>  <span class="comment">//状态标识，用于控制goroutine写入和扩容的状态</span></span><br><span class="line">	B         <span class="type">uint8</span>  <span class="comment">// 用于计算buckets数量，计算公式2^B</span></span><br><span class="line">	noverflow <span class="type">uint16</span> <span class="comment">// 溢出桶数量</span></span><br><span class="line">	hash0     <span class="type">uint32</span> <span class="comment">// hash 种子</span></span><br><span class="line">	buckets    unsafe.Pointer <span class="comment">// 2^B Buckets count ==0时可能为nil(此处是万能指针类型，实际是对应下面的bmap)</span></span><br><span class="line">	oldbuckets unsafe.Pointer <span class="comment">// 扩容后的旧bucket数组</span></span><br><span class="line">	nevacuate  <span class="type">uintptr</span>        <span class="comment">// 迁移计数器，此指针之前的所有桶已被迁移，即nevacuate指向桶数组已迁移桶的最高下标</span></span><br><span class="line">	extra *mapextra <span class="comment">//溢出桶结构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	tophash [bucketCnt]<span class="type">uint8</span> <span class="comment">// bucketCnt == 8每个桶固定8个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><p>通过make函数和hint指定元素数量来初始化map</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, hint)</span><br></pre></td></tr></table></figure><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>目前的现代编程语言基本都支持使用字面量的方式初始化哈希，一般都会使用 key: value 的语法来表示键值对，Go 语言中也不例外：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hash := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">	<span class="string">&quot;1&quot;</span>: <span class="number">2</span>,</span><br><span class="line">	<span class="string">&quot;3&quot;</span>: <span class="number">4</span>,</span><br><span class="line">	<span class="string">&quot;5&quot;</span>: <span class="number">6</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当哈希表中的元素数量少于或者等于 25 个时，编译器会将字面量初始化的结构体转换成以下的代码，将所有的键值对一次加入到哈希表中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">hash[<span class="string">&quot;1&quot;</span>] = <span class="number">2</span></span><br><span class="line">hash[<span class="string">&quot;3&quot;</span>] = <span class="number">4</span></span><br><span class="line">hash[<span class="string">&quot;5&quot;</span>] = <span class="number">6</span></span><br></pre></td></tr></table></figure><p>一旦哈希表中元素的数量超过了 25 个，编译器会创建两个数组分别存储键和值，这些键值对会通过如下所示的 for 循环加入哈希：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">26</span>)</span><br><span class="line">vstatk := []<span class="type">string</span>&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, ... ， <span class="string">&quot;26&quot;</span>&#125;</span><br><span class="line">vstatv := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ... , <span class="number">26</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(vstak); i++ &#123;</span><br><span class="line">    hash[vstatk[i]] = vstatv[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论是<code>字面量</code>或是<code>make</code>方式map底层都是通过<code>makemap</code>函数来创建</p><h3 id="makemap"><a href="#makemap" class="headerlink" title="makemap"></a>makemap</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *maptype, hint <span class="type">int</span>, h *hmap)</span></span> *hmap &#123;</span><br><span class="line">	mem, overflow := math.MulUintptr(<span class="type">uintptr</span>(hint), t.bucket.size)</span><br><span class="line">	<span class="keyword">if</span> overflow || mem &gt; maxAlloc &#123;</span><br><span class="line">		hint = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// initialize Hmap</span></span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">		h = <span class="built_in">new</span>(hmap)</span><br><span class="line">	&#125;</span><br><span class="line">	h.hash0 = fastrand()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find the size parameter B which will hold the requested # of elements.</span></span><br><span class="line">	<span class="comment">// For hint &lt; 0 overLoadFactor returns false since hint &lt; bucketCnt.</span></span><br><span class="line">	B := <span class="type">uint8</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> overLoadFactor(hint, B) &#123;</span><br><span class="line">		B++</span><br><span class="line">	&#125;</span><br><span class="line">	h.B = B</span><br><span class="line"></span><br><span class="line">	<span class="comment">// allocate initial hash table</span></span><br><span class="line">	<span class="comment">// if B == 0, the buckets field is allocated lazily later (in mapassign)</span></span><br><span class="line">	<span class="comment">// If hint is large zeroing this memory could take a while.</span></span><br><span class="line">	<span class="keyword">if</span> h.B != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> nextOverflow *bmap</span><br><span class="line">		h.buckets, nextOverflow = makeBucketArray(t, h.B, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">			h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">			h.extra.nextOverflow = nextOverflow</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>makemap</code> 函数通过指定<code>hint</code>来通过<code>B</code>计算bucket数量<br>计算公式</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hint ≤ 2^B * 6.5</span><br></pre></td></tr></table></figure><p>通过B数量指定hmap会创建2^B个桶和一些溢出桶</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> b &gt;= <span class="number">4</span> &#123;</span><br><span class="line">	<span class="comment">// Add on the estimated number of overflow buckets</span></span><br><span class="line">	<span class="comment">// required to insert the median number of elements</span></span><br><span class="line">	<span class="comment">// used with this value of b.</span></span><br><span class="line">	nbuckets += bucketShift(b - <span class="number">4</span>)</span><br><span class="line">	sz := t.bucket.size * nbuckets</span><br><span class="line">	up := roundupsize(sz)</span><br><span class="line">	<span class="keyword">if</span> up != sz &#123;</span><br><span class="line">		nbuckets = up / t.bucket.size</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当桶的数量小于 2^4 时，由于数据较少、使用溢出桶的可能性较低，会省略创建的过程以减少额外开销；</li><li>当桶的数量多于 2^4 时，会额外创建 2^𝐵−4 个溢出桶；</li></ul><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>为什么需要扩容，当<code>溢出桶</code>承装元素超过8个时，溢出桶的<code>mapextra</code>指向新的溢出桶，直到能够满足承装元素数目,此时，hash查找会退化成链表查找，时间复杂度为O(n)<br>扩容判断条件:</p><ul><li>当前未在扩容状态并且负载因子&gt;&#x3D;6.5</li><li>有太多的<code>溢出桶</code><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">    hashGrow(t, h)</span><br><span class="line">    <span class="keyword">goto</span> again <span class="comment">// Growing the table invalidates everything, so try again</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> map扩容为渐进式扩容，只在map操作当前桶时才对当前桶进行扩容<br>扩容步骤分为<code>hashGrow</code>和<code>growWork</code></li><li><code>hashGrow</code>不做桶元素迁移，只是将当前桶指向oldbuckets，然后创建等量的buckets和溢出桶作为newbuckets指向hmap.buckets<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">h.B += bigger #更新B</span><br><span class="line">h.flags = flags #更新扩容状态</span><br><span class="line">h.oldbuckets = oldbuckets</span><br><span class="line">h.buckets = newbuckets</span><br><span class="line">h.nevacuate = <span class="number">0</span> #扩容计数器</span><br><span class="line">h.noverflow = <span class="number">0</span> #溢出桶数量</span><br></pre></td></tr></table></figure></li><li>growWork会在元素赋值是触发当前桶操作，然后对当前桶进行扩容,将将旧桶数据驱逐到新桶,操作步骤在growWork.evacuate</li></ul><p>evacuate里的扩容方式分为等量扩容和非等量扩容</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">    <span class="comment">// Only calculate y pointers if we&#x27;re growing bigger.</span></span><br><span class="line">    <span class="comment">// Otherwise GC can see bad pointers.</span></span><br><span class="line">    y := &amp;xy[<span class="number">1</span>]</span><br><span class="line">    y.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">    y.k = add(unsafe.Pointer(y.b), dataOffset)</span><br><span class="line">    y.e = add(y.k, bucketCnt*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="等量扩容"><a href="#等量扩容" class="headerlink" title="等量扩容"></a>等量扩容</h3><p>对hash后的key后B位计算桶号，然后将元素等量分配</p><p>例如：hash(a)的二进制为0101110001010110，扩容前B&#x3D;2，桶号为10&#x3D;2，扩容后桶号为110，桶号为110&#x3D;6，将元素平均分配到这两个桶</p><h3 id="非等量扩容"><a href="#非等量扩容" class="headerlink" title="非等量扩容"></a>非等量扩容</h3><p>非等量扩容不扩容桶的数量，由于之前产生过很多溢出桶，但是溢出桶的元素很稀疏，所以只是将桶序号重新整理，清到多余的溢出桶，然后整理到新的buckets，</p><p>##查找和写入</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><ul><li>查找主要分为<code>mapaccess1</code>和<code>mapaccess2</code>两个函数，区别就是<code>mapaccess2</code>在找到目标值时会多返回一个true，在未找到时会返回false</li><li>查找流程hmap里通过tophash找到对应buckets桶号,再到bmap里区寻找tophash高8位对应的key,如果不在当前桶就去溢出桶里找，如果溢出桶找不到说明元素不在map,返回false</li><li>如果查找时正在扩容，会判断oldbucktes是否为nil，不为nil找旧桶，缩减m找到旧桶编号去找旧桶元素位置<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//hash&amp;m找到桶编号作为偏移值找到对应的bmap结构体</span></span><br><span class="line">b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line"><span class="keyword">if</span> c := h.oldbuckets; c != <span class="literal">nil</span> &#123; 	<span class="comment">//存在旧桶，说明正在扩容状态中</span></span><br><span class="line">	<span class="keyword">if</span> !h.sameSizeGrow() &#123; 			<span class="comment">//判断是否翻倍扩容</span></span><br><span class="line">		m &gt;&gt;= <span class="number">1</span> <span class="comment">//翻倍扩容时，新的桶数是旧的2倍，m需要减半才能找到旧桶编号</span></span><br><span class="line">	&#125;</span><br><span class="line">	oldb := (*bmap)(add(c, (hash&amp;m)*<span class="type">uintptr</span>(t.bucketsize))) <span class="comment">//找到对应的旧桶位置</span></span><br><span class="line">	<span class="keyword">if</span> !evacuated(oldb) &#123;</span><br><span class="line">		b = oldb <span class="comment">//如果旧桶没有完成数据迁移，那么更新b指向旧桶bmap</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">top := tophash(hash) <span class="comment">//取hash值高八位，因为bmp.tophash中0-4是标志位，所以hash值小于5的自动加5</span></span><br><span class="line"> bucketloop:</span><br><span class="line"> <span class="comment">//遍历当前bmp和溢出桶</span></span><br><span class="line"> ...</span><br></pre></td></tr></table></figure></li></ul><h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><ul><li>函数首先会检查 <code>map</code> 的标志位 <code>flags</code>。如果 <code>flags</code> 的写标志位此时被置 1 了，说明有其他协程在执行“写”操作，进而导致程序 <code>panic</code>。这也说明了 <code>map</code> 对协程是不安全的。</li><li>扩容是渐进式的，如果 <code>map</code> 处在扩容的过程中，那么当 <code>key</code> 定位到了某个 <code>bucket</code> 后，需要确保这个 <code>bucket</code> 对应的老 <code>bucket</code> 完成了迁移过程。即老 <code>bucket</code> 里的 <code>key</code> 都要迁移到新的 <code>bucket</code> 中来（分裂到 2 个新 <code>bucket</code>），才能在新的 <code>bucket</code> 中进行插入或者更新的操作。<br>上面说的操作是在函数靠前的位置进行的，只有进行完了这个搬迁操作后，我们才能放心地在新 <code>bucket</code> 里定位 <code>key</code> 要安置的地址，再进行之后的操作。</li><li>如果这个 <code>bucket</code> 的 <code>8</code> 个 <code>key</code> 都已经放置满了，那在跳出循环后，发现 <code>inserti</code> 和 <code>insertk</code> 都是空，这时候需要在 <code>bucket</code> 后面挂上 <code>overflow bucket</code>。当然，也有可能是在 <code>overflow bucket</code> 后面再挂上一个 <code>overflow bucket</code>。这就说明，太多 <code>key hash</code> 到了此 <code>bucket</code>。<br>在正式安置 <code>key</code> 之前，还要检查 <code>map</code> 的状态，看它是否需要进行扩容。如果满足扩容的条件，就主动触发一次扩容操作。</li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul><li>首先会检查 <code>h.flags</code> 标志，如果发现写标位是 1，直接 <code>panic</code>，因为这表明有其他协程同时在进行写操作。</li><li>计算 key 的哈希，找到落入的 <code>bucket</code>。检查此 <code>map</code> 如果正在扩容的过程中，直接触发一次搬迁操作。</li><li>删除操作同样是两层循环，核心还是找到 <code>key</code> 的具体位置。寻找过程都是类似的，在 <code>bucket</code> 中挨个 <code>cell</code> 寻找。</li><li>找到对应位置后，对 <code>key</code> 或者 <code>value</code> 进行“清零”操作： 最后，将 <code>count</code> 值减 <code>1</code>，将对应位置的 <code>tophash</code> 值置成 <code>Empty</code>。</li></ul></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/golang/" rel="tag"># golang</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2023/01/15/2023-01-17-sync-map%E5%8E%9F%E7%90%86/" rel="prev" title="GO SYNC MAP原理"><i class="fa fa-chevron-left"></i> GO SYNC MAP原理</a></div><div class="post-nav-item"> <a href="/2023/01/21/2023-01-21-Goroutine/" rel="next" title="神奇的Goroutine">神奇的Goroutine<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#GO-MAP%E5%8E%9F%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">GO MAP原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.1.</span> <span class="nav-text">初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#make"><span class="nav-number">1.1.1.</span> <span class="nav-text">make</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="nav-number">1.1.2.</span> <span class="nav-text">字面量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#makemap"><span class="nav-number">1.1.3.</span> <span class="nav-text">makemap</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A9%E5%AE%B9"><span class="nav-number">1.2.</span> <span class="nav-text">扩容</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%89%E9%87%8F%E6%89%A9%E5%AE%B9"><span class="nav-number">1.2.1.</span> <span class="nav-text">等量扩容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E7%AD%89%E9%87%8F%E6%89%A9%E5%AE%B9"><span class="nav-number">1.2.2.</span> <span class="nav-text">非等量扩容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE"><span class="nav-number">1.2.3.</span> <span class="nav-text">查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E5%85%A5"><span class="nav-number">1.2.4.</span> <span class="nav-text">写入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4"><span class="nav-number">1.2.5.</span> <span class="nav-text">删除</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">enpsl</p><div class="site-description" itemprop="description">my blog</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">39</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">7</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2023</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">enpsl</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动</div></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script></body></html>