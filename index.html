<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"enpsl.github.io",root:"/",scheme:"Muse",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="my blog"><meta property="og:type" content="website"><meta property="og:title" content="彭诗亮的博客"><meta property="og:url" content="https://enpsl.github.io/index.html"><meta property="og:site_name" content="彭诗亮的博客"><meta property="og:description" content="my blog"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="enpsl"><meta property="article:tag" content="彭诗亮 psl pengshiliang blog"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://enpsl.github.io/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!0,isPost:!1,lang:"zh-CN"}</script><title>彭诗亮的博客</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">彭诗亮的博客</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档</a></li></ul></nav></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content index posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2023/02/22/2023-02-22-gin%E6%98%AF%E6%80%8E%E6%A0%B7%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E7%9A%84/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2023/02/22/2023-02-22-gin%E6%98%AF%E6%80%8E%E6%A0%B7%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E7%9A%84/" class="post-title-link" itemprop="url">gin路由请求数据解析</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-02-22 19:30:00" itemprop="dateCreated datePublished" datetime="2023-02-22T19:30:00+08:00">2023-02-22</time></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="net-x2F-http-路由解析"><a href="#net-x2F-http-路由解析" class="headerlink" title="net&#x2F;http 路由解析"></a>net&#x2F;http 路由解析</h1><p>在了解gin的路由解析过程之前，我们有必要先了解下go的<code>net/http</code>的工作流程</p><p>首先，http是如何建立起来的?<br><img src="/../img/in-post/2023-02-22/img.png" alt="img.png"></p><p>在<code>http.ListenAndServe</code>的代码执行流程中，我们可以获取到上面的代码执行流程:</p><h2 id="创建-socket"><a href="#创建-socket" class="headerlink" title="创建 socket"></a>创建 socket</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span></span> ListenAndServe() <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// ... 省略代码</span></span><br><span class="line">    ln, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, addr) <span class="comment">// &lt;-----看这里listen</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> srv.Serve(tcpKeepAliveListener&#123;ln.(*net.TCPListener)&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Accept-等待客户端链接"><a href="#Accept-等待客户端链接" class="headerlink" title="Accept 等待客户端链接"></a>Accept 等待客户端链接</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/http/server.go:L2805-2853</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span></span> Serve(l net.Listener) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// ... 省略代码</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      rw, e := l.Accept() <span class="comment">// &lt;----- 看这里accept</span></span><br><span class="line">      <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-srv.getDoneChan():</span><br><span class="line">          <span class="keyword">return</span> ErrServerClosed</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line">          <span class="keyword">if</span> tempDelay == <span class="number">0</span> &#123;</span><br><span class="line">            tempDelay = <span class="number">5</span> * time.Millisecond</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tempDelay *= <span class="number">2</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> max := <span class="number">1</span> * time.Second; tempDelay &gt; max &#123;</span><br><span class="line">            tempDelay = max</span><br><span class="line">          &#125;</span><br><span class="line">          srv.logf(<span class="string">&quot;http: Accept error: %v; retrying in %v&quot;</span>, e, tempDelay)</span><br><span class="line">          time.Sleep(tempDelay)</span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e</span><br><span class="line">      &#125;</span><br><span class="line">      tempDelay = <span class="number">0</span></span><br><span class="line">      c := srv.newConn(rw)</span><br><span class="line">      c.setState(c.rwc, StateNew) <span class="comment">// before Serve can return</span></span><br><span class="line">      <span class="keyword">go</span> c.serve(ctx) <span class="comment">// &lt;--- 看这里</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3.</span> 提供回调</span><br></pre></td></tr></table></figure><h2 id="read-or-write"><a href="#read-or-write" class="headerlink" title="read or write"></a>read or write</h2><p>在<code>c.serve</code>中执行<code>c.readRequest</code>会调用<code>read</code>读取请求数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span></span> serve(ctx context.Context) &#123;</span><br><span class="line">	<span class="comment">// ...省略代码</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">        w, err := c.readRequest(ctx)</span><br><span class="line">        <span class="keyword">if</span> c.r.remain != c.server.initialReadLimitSize() &#123;</span><br><span class="line">            <span class="comment">// If we read any bytes off the wire, we&#x27;re active.</span></span><br><span class="line">            c.setState(c.rwc, StateActive, runHooks)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...省略代码</span></span><br><span class="line">        serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>ServeHTTP</code>中的<code>ResponseWriter</code>会调用<code>write</code>返回响应数据给客户端</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span></span> ServeHTTP(w ResponseWriter, r *Request) &#123;</span><br><span class="line">    handler := sh.srv.Handler</span><br><span class="line">    <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">        handler = DefaultServeMux</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> r.RequestURI == <span class="string">&quot;*&quot;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> r.ProtoAtLeast(<span class="number">1</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        w.Header().Set(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;close&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      w.WriteHeader(StatusBadRequest)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    h, _ := mux.Handler(r) <span class="comment">// &lt;--- 看这里</span></span><br><span class="line">    h.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这基本是整个过程的代码了</p><ol><li><code>ln, err := net.Listen(&quot;tcp&quot;, addr)</code>做了初试化了socket, bind, listen的操作.</li><li><code>rw, e := l.Accept()</code>进行accept, 等待客户端进行连接</li><li><code>go c.serve(ctx)</code> 启动新的goroutine来处理本次请求. 同时主goroutine继续等待客户端连接, 进行高并发操作</li><li><code>h, _ := mux.Handler(r)</code> 获取注册的路由, 然后拿到这个路由的handler, 然后将处理结果返回给客户端</li></ol><h2 id="路由注册"><a href="#路由注册" class="headerlink" title="路由注册"></a>路由注册</h2><p><code>net/http</code>是通过<code>server mux</code>来管理路由解析的</p><p>先从最基本的路由注册实例开始</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">&quot;/api/hello/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    w.Write([]<span class="type">byte</span>(<span class="string">&quot;Hello World&quot;</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="type">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span></span>) &#123;</span><br><span class="line">    DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span></span> Handle(pattern <span class="type">string</span>, handler Handler) &#123;</span><br><span class="line">	mux.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mux.mu.Unlock()</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// ...省略代码</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> mux.m == <span class="literal">nil</span> &#123;</span><br><span class="line">		mux.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]muxEntry)</span><br><span class="line">	&#125;</span><br><span class="line">	e := muxEntry&#123;h: handler, pattern: pattern&#125;</span><br><span class="line">	mux.m[pattern] = e</span><br><span class="line">	<span class="keyword">if</span> pattern[<span class="built_in">len</span>(pattern)<span class="number">-1</span>] == <span class="string">&#x27;/&#x27;</span> &#123;</span><br><span class="line">		mux.es = appendSorted(mux.es, e)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> pattern[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span> &#123;</span><br><span class="line">		mux.hosts = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述追踪可以看到mux将<code>api/hello</code>注册到<code>mux.m</code>中，<code>mux.m</code>是一个加锁的map,也就是通过map的key存储具体的路由前缀(parttern)来匹配对应的路由</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu    sync.RWMutex</span><br><span class="line">	m     <span class="keyword">map</span>[<span class="type">string</span>]muxEntry</span><br><span class="line">	es    []muxEntry <span class="comment">// slice of entries sorted from longest to shortest.</span></span><br><span class="line">	hosts <span class="type">bool</span>       <span class="comment">// whether any patterns contain hostnames</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在下面这段代码中可以看到，mux会分析注册进来的新路由是否以’&#x2F;‘结尾,如果是会加该<code>parttern</code>入到es中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mux.m[pattern] = e</span><br><span class="line"><span class="keyword">if</span> pattern[<span class="built_in">len</span>(pattern)<span class="number">-1</span>] == <span class="string">&#x27;/&#x27;</span> &#123;</span><br><span class="line">    mux.es = appendSorted(mux.es, e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>appendSorted</code>详细逻辑</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendSorted</span><span class="params">(es []muxEntry, e muxEntry)</span></span> []muxEntry &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(es)</span><br><span class="line">	i := sort.Search(n, <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">len</span>(es[i].pattern) &lt; <span class="built_in">len</span>(e.pattern)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> i == n &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">append</span>(es, e)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// we now know that i points at where we want to insert</span></span><br><span class="line">	es = <span class="built_in">append</span>(es, muxEntry&#123;&#125;) <span class="comment">// try to grow the slice in place, any entry works.</span></span><br><span class="line">	<span class="built_in">copy</span>(es[i+<span class="number">1</span>:], es[i:])      <span class="comment">// Move shorter entries down</span></span><br><span class="line">	es[i] = e</span><br><span class="line">	<span class="keyword">return</span> es</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在es中，api前缀的加入是根据<code>parttern</code>的len递减顺序来进行存储的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">&quot;/api/hello/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    w.Write([]<span class="type">byte</span>(<span class="string">&quot;Hello World&quot;</span>))</span><br><span class="line">&#125;)</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/api/hello1/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    w.Write([]<span class="type">byte</span>(<span class="string">&quot;Hello World&quot;</span>))</span><br><span class="line">&#125;)</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/api/hello12/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    w.Write([]<span class="type">byte</span>(<span class="string">&quot;Hello World&quot;</span>))</span><br><span class="line">&#125;)</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/api/hello3/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    w.Write([]<span class="type">byte</span>(<span class="string">&quot;Hello World&quot;</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>es append</code>的输出过程是这样的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[&#123;<span class="number">0x1315f00</span> /api/hello/&#125;]</span><br><span class="line">[&#123;<span class="number">0x1315fa0</span> /api/hello1/&#125; &#123;<span class="number">0x1315f00</span> /api/hello/&#125;]</span><br><span class="line">[&#123;<span class="number">0x1316040</span> /api/hello12/&#125; &#123;<span class="number">0x1315fa0</span> /api/hello1/&#125; &#123;<span class="number">0x1315f00</span> /api/hello/&#125;]</span><br><span class="line">[&#123;<span class="number">0x1316040</span> /api/hello12/&#125; &#123;<span class="number">0x1315fa0</span> /api/hello1/&#125; &#123;<span class="number">0x13160e0</span> /api/hello3/&#125; &#123;<span class="number">0x1315f00</span> /api/hello/&#125;]</span><br></pre></td></tr></table></figure><p>为什么要按照这种顺序呢，当注册一个以<code>/</code>为结尾的路由，mux会尽可能去按照最大长度来匹配路由规则，如果匹配到了，即使后面的部分还有其他字符，也会按照当前匹配的<code>handler</code>去处理逻辑<br>所以，对于<code>/api/hello/</code>和<code>/api/hello/1111</code>拿到的handler是一样的，而不是以<code>/</code>为结尾注册后的路由，会按照全部<code>parttern</code>去匹配</p><h2 id="自定义路由注册"><a href="#自定义路由注册" class="headerlink" title="自定义路由注册"></a>自定义路由注册</h2><p>通过<code>net/http</code>包的路由管理模式我们可以知道，<code>net/http</code>的路由匹配根本就不符合 <code>RESTful</code> 的规则，遇到稍微复杂一点的需求时，这个简单的路由匹配规则简直就是噩梦。<br>所以<code>net/http</code>提供了自定义路由管理模式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(<span class="string">&quot;:8000&quot;</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;start http server fail:&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>ListenAndServe</code>的第二个参数会传递用户自定义的<code>handler</code>，如果为<code>nil</code>，那么会使用<code>DefaultServeMux</code>也就是<code>net/http</code>的路由管理模式来进行管理</p><p>在下面的这段代码有具体逻辑展示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span></span> ServeHTTP(w ResponseWriter, r *Request) &#123;</span><br><span class="line">    handler := sh.srv.Handler</span><br><span class="line">    <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">        handler = DefaultServeMux</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以总结下<code>net/http</code>的请求处理流程<br><img src="/../img/in-post/2023-02-22/img_2.png" alt="img_2.png"></p><p>而<code>gin</code>正是通过注册了自己的路由<code>handler</code>，即<code>engine.Handler()</code>来实现自定义管理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> Run(addr ...<span class="type">string</span>) (err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; debugPrintError(err) &#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> engine.isUnsafeTrustedProxies() &#123;</span><br><span class="line">		debugPrint(<span class="string">&quot;[WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.\n&quot;</span> +</span><br><span class="line">			<span class="string">&quot;Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies for details.&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	address := resolveAddress(addr)</span><br><span class="line">	debugPrint(<span class="string">&quot;Listening and serving HTTP on %s\n&quot;</span>, address)</span><br><span class="line">	err = http.ListenAndServe(address, engine.Handler())</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gin</code>的请求处理流程<br><img src="/../img/in-post/2023-02-22/img_1.png" alt="img_1.png"></p><p>所以我们只需要关心<code>engine</code>的实现和<code>engine</code>的<code>ServerHttp</code>实现，数据请求流程还是跟<code>net/http</code>是一样的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeHTTP conforms to the http.Handler interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">	c := engine.pool.Get().(*Context)</span><br><span class="line">	c.writermem.reset(w)</span><br><span class="line">	c.Request = req</span><br><span class="line">	c.reset()</span><br><span class="line"></span><br><span class="line">	engine.handleHTTPRequest(c)</span><br><span class="line"></span><br><span class="line">	engine.pool.Put(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServeHTTP的实现流程可以总结为:</p><ol><li>从 sync.pool 里面拿去一块内存</li><li>对这块内存做初始化工作，防止数据污染</li><li>处理请求 handleHTTPRequest</li><li>请求处理完成后，把这块内存归还到 sync.pool 中</li></ol></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2023/02/22/2023-02-22-gin%E6%98%AF%E6%80%8E%E6%A0%B7%E7%AE%A1%E7%90%86%E8%B7%AF%E7%94%B1%E7%9A%84/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2023/02/22/2023-02-22-gin%E6%98%AF%E6%80%8E%E6%A0%B7%E7%AE%A1%E7%90%86%E8%B7%AF%E7%94%B1%E7%9A%84/" class="post-title-link" itemprop="url">gin的路由管理</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-02-22 19:30:00" itemprop="dateCreated datePublished" datetime="2023-02-22T19:30:00+08:00">2023-02-22</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h2><p>目前业界 Server 端 API 接口的设计方式一般是遵循 RESTful 风格的规范</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET    /user/&#123;userID&#125; HTTP/1.1</span><br><span class="line">POST   /user/&#123;userID&#125; HTTP/1.1</span><br><span class="line">PUT    /user/&#123;userID&#125; HTTP/1.1</span><br><span class="line">DELETE /user/&#123;userID&#125; HTTP/1.1</span><br></pre></td></tr></table></figure><p>这是比较规范的 RESTful API设计，分别代表：</p><ul><li>获取 userID 的用户信息</li><li>更新 userID 的用户信息（当然还有其 json body，没有写出来）</li><li>创建 userID 的用户（当然还有其 json body，没有写出来）</li><li>删除 userID 的用户</li></ul><h2 id="gin-路由设计"><a href="#gin-路由设计" class="headerlink" title="gin 路由设计"></a>gin 路由设计</h2><h3 id="前缀树和基数树（radix-tree）"><a href="#前缀树和基数树（radix-tree）" class="headerlink" title="前缀树和基数树（radix tree）"></a>前缀树和基数树（radix tree）</h3><p>前缀树是一个多叉树，广泛应用于字符串搜索，每个树节点存储一个字符，从根节点到任意一个叶子结点串起来就是一个字符串。</p><p>radix tree是优化之后的前缀树，对空间进一步压缩，从上往下提取公共前缀，非公共部分存到子节点，这样既节省了空间,同时也提高了查询效率(左边字符串sleep查询需要5步, 右边只需要3步)，Gin的路由树就是用radix tree实现的。<br><img src="/../img/in-post/2023-02-22/img_3.png" alt="img.png"></p><p>Gin为每一种请求都维护了一个radix tree，不同的请求会被解析并送到对应的radix tree进行处理。</p><p><img src="/../img/in-post/2023-02-22/img_4.png" alt="img_1.png"></p><p><code>gin</code>的路由树的一些相关结构体介绍</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">	RouterGroup</span><br><span class="line">    ....</span><br><span class="line">    trees            methodTrees <span class="comment">//保存着每种请求的路有树</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//RouterGroup可以被看作的内部的配置路由</span></span><br><span class="line"><span class="keyword">type</span> RouterGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">	Handlers HandlersChain   <span class="comment">//处理函数链，用Default初始化时会加入Logger(), Recovery()</span></span><br><span class="line">	basePath <span class="type">string</span>          <span class="comment">//基础路径，用Default和New初始化时都被赋值为&quot;/&quot;</span></span><br><span class="line">	engine   *Engine         <span class="comment">// Gin引擎，在添加路由时会用到</span></span><br><span class="line">	root     <span class="type">bool</span>            </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树节点</span></span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">	path      <span class="type">string</span>         <span class="comment">//保存节点的路径，像上面radix tree图中节点里面的值</span></span><br><span class="line">	indices   <span class="type">string</span>         <span class="comment">//子节点的首字符根据priority排列组成的字符串，为了方便遍历</span></span><br><span class="line">	wildChild <span class="type">bool</span>           <span class="comment">//标识孩子节点是否有通配符</span></span><br><span class="line">	nType     nodeType       <span class="comment">//节点类型</span></span><br><span class="line">	priority  <span class="type">uint32</span>         <span class="comment">//优先级</span></span><br><span class="line">	children  []*node</span><br><span class="line">	handlers  HandlersChain  <span class="comment">//处理函数链</span></span><br><span class="line">	fullPath  <span class="type">string</span>         <span class="comment">//保存完整路径</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// node结构中nodeType节点类型</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	static nodeType = <span class="literal">iota</span> 	 <span class="comment">// default 普通节点，默认</span></span><br><span class="line">	root			 <span class="comment">// 根节点</span></span><br><span class="line">	param			 <span class="comment">// 参数路由，比如 /user/:id</span></span><br><span class="line">	catchAll		 <span class="comment">// 匹配所有内容的路由，比如 /article/*key</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>当 <code>gin</code> 注册路由的时候，会根据不同的 <code>Method</code> 分别注册不同的路由树。</p><p>如上面的restful请求会注册四颗路由树出来。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> addRoute(method, path <span class="type">string</span>, handlers HandlersChain) &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    root := engine.trees.get(method)</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        root = <span class="built_in">new</span>(node)</span><br><span class="line">        root.fullPath = <span class="string">&quot;/&quot;</span></span><br><span class="line">        engine.trees = <span class="built_in">append</span>(engine.trees, methodTree&#123;method: method, root: root&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    root.addRoute(path, handlers)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程</p><ul><li>拿到一个 <code>method</code> 方法时，去 <code>trees slice</code> 中遍历</li><li>如果 <code>trees slice</code> 存在这个 <code>method</code>, 则这个URL对应的 <code>handler</code> 直接添加到找到的路由树上</li><li>如果没有找到，则重新创建一颗新的方法树出来, 然后将 URL对应的 <code>handler</code> 添加到这个路由 树上</li></ul><p>这里的重点是根节点root调用的addRoute，添加节点的逻辑都在这个函数里面，包括找到插入的位置，一些通配节点的特殊处理等。在这个函数里面会用到一些工具函数，这里一并介绍一下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Increments priority of the given child and reorders if necessary</span></span><br><span class="line"><span class="comment">// 增加指定孩子节点的优先级，并更新节点的indices</span></span><br><span class="line"><span class="comment">// 这并不会影响路由功能，但是可以加快孩子节点的查找速度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> incrementChildPrio(pos <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	cs := n.children</span><br><span class="line">	cs[pos].priority++</span><br><span class="line">	prio := cs[pos].priority</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Adjust position (move to front)</span></span><br><span class="line">	<span class="comment">// 将更新后的priority向前移动，保持按优先级降序排列</span></span><br><span class="line">	newPos := pos</span><br><span class="line">	<span class="keyword">for</span> ; newPos &gt; <span class="number">0</span> &amp;&amp; cs[newPos<span class="number">-1</span>].priority &lt; prio; newPos-- &#123;</span><br><span class="line">		<span class="comment">// Swap node positions</span></span><br><span class="line">		cs[newPos<span class="number">-1</span>], cs[newPos] = cs[newPos], cs[newPos<span class="number">-1</span>]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Build new index char string</span></span><br><span class="line">	<span class="comment">// 根据优先级重新构建indices，indices保存着当前节点下的每个孩子节点的首字符</span></span><br><span class="line">	<span class="keyword">if</span> newPos != pos &#123;</span><br><span class="line">		n.indices = n.indices[:newPos] + <span class="comment">// Unchanged prefix, might be empty</span></span><br><span class="line">			n.indices[pos:pos+<span class="number">1</span>] + <span class="comment">// The index char we move</span></span><br><span class="line">			n.indices[newPos:pos] + n.indices[pos+<span class="number">1</span>:] <span class="comment">// Rest without char at &#x27;pos&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> newPos</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获两个字符串的最长公共前缀</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestCommonPrefix</span><span class="params">(a, b <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	max := min(<span class="built_in">len</span>(a), <span class="built_in">len</span>(b))</span><br><span class="line">	<span class="keyword">for</span> i &lt; max &amp;&amp; a[i] == b[i] &#123;</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// addRoute adds a node with the given handle to the path.</span></span><br><span class="line"><span class="comment">// Not concurrency-safe!</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> addRoute(path <span class="type">string</span>, handlers HandlersChain) &#123;</span><br><span class="line">	fullPath := path</span><br><span class="line">	n.priority++</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Empty tree</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(n.path) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(n.children) == <span class="number">0</span> &#123;</span><br><span class="line">		n.insertChild(path, fullPath, handlers)</span><br><span class="line">		n.nType = root</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	parentFullPathIndex := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">walk:</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// Find the longest common prefix.</span></span><br><span class="line">		<span class="comment">// This also implies that the common prefix contains no &#x27;:&#x27; or &#x27;*&#x27;</span></span><br><span class="line">		<span class="comment">// since the existing key can&#x27;t contain those chars.</span></span><br><span class="line">		<span class="comment">// 获取最长公共前缀 path代表新加路由节点的path,n.path代表当前node的path</span></span><br><span class="line">		i := longestCommonPrefix(path, n.path)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Split edge</span></span><br><span class="line">		<span class="comment">// 如果n.path=/abc path=/a这种的，最长公共前缀小于n.path 则进入if语句，提取公共部分为父节点</span></span><br><span class="line">        <span class="comment">// 非公共部分为子节点，即n.path=/a 子节点/bc</span></span><br><span class="line">        <span class="comment">// /bc保存原来节点n的信息，/a为新节点的信息</span></span><br><span class="line">		<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(n.path) &#123;</span><br><span class="line">			child := node&#123;</span><br><span class="line">				path:      n.path[i:],<span class="comment">//非公共的部分</span></span><br><span class="line">				wildChild: n.wildChild,</span><br><span class="line">				indices:   n.indices,</span><br><span class="line">				children:  n.children,</span><br><span class="line">				handlers:  n.handlers,</span><br><span class="line">				<span class="comment">// 由于是n的孩子节点,故优先级减去n节点,即n-1</span></span><br><span class="line">				priority:  n.priority - <span class="number">1</span>,</span><br><span class="line">				fullPath:  n.fullPath,</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			n.children = []*node&#123;&amp;child&#125;</span><br><span class="line">			<span class="comment">// []byte for proper unicode char conversion, see #65</span></span><br><span class="line">			n.indices = bytesconv.BytesToString([]<span class="type">byte</span>&#123;n.path[i]&#125;)</span><br><span class="line">			n.path = path[:i]</span><br><span class="line">			n.handlers = <span class="literal">nil</span>    <span class="comment">// 目前先置为空，后面会再加上handlers</span></span><br><span class="line">			n.wildChild = <span class="literal">false</span></span><br><span class="line">			n.fullPath = fullPath[:parentFullPathIndex+i]</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Make new node a child of this node</span></span><br><span class="line">		<span class="comment">// 例如n.path=/a path=/abc 新加进来的path比当前n.path长，则进入if语句</span></span><br><span class="line">		<span class="comment">// 在当前节点创建一个新的子节点</span></span><br><span class="line">		<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(path) &#123;</span><br><span class="line">			path = path[i:]</span><br><span class="line">			<span class="comment">// 如果n节点的孩子节点有通配符进入if，这里的逻辑会有点绕</span></span><br><span class="line">			<span class="keyword">if</span> n.wildChild &#123;</span><br><span class="line">				parentFullPathIndex += <span class="built_in">len</span>(n.path)</span><br><span class="line">				<span class="comment">//注意，此时n已经指向它的第一个孩子节点</span></span><br><span class="line">				n = n.children[<span class="number">0</span>]</span><br><span class="line">				n.priority++</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Check if the wildcard matches</span></span><br><span class="line">                <span class="comment">// 注意，此时的path已经取成了公共前缀后的部分</span></span><br><span class="line">                <span class="comment">// 例如原来的路径是/usr/:name，假设当前n节点的父节点为nfather</span></span><br><span class="line">                <span class="comment">// 而n在前面已经取成了nfather孩子节点</span></span><br><span class="line">                <span class="comment">// 目前情况是nfather.path=/usr，由于其子节点是通配符节点</span></span><br><span class="line">                <span class="comment">// 故nfather.wildChild=true，n.path=/:name</span></span><br><span class="line">                <span class="comment">// 假设新加进来的节点path=/:nameserver</span></span><br><span class="line">                <span class="comment">// 则符合这里的if条件，跳转到walk，以n为父节点继续匹配</span></span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(path) &gt;= <span class="built_in">len</span>(n.path) &amp;&amp; n.path == path[:<span class="built_in">len</span>(n.path)] &amp;&amp;</span><br><span class="line">					<span class="comment">// Adding a child to a catchAll is not possible</span></span><br><span class="line">					<span class="comment">// 不可能在全匹配节点（例如*name）后继续加子节点</span></span><br><span class="line">					n.nType != catchAll &amp;&amp;</span><br><span class="line">					<span class="comment">// Check for longer wildcard, e.g. :name and :names</span></span><br><span class="line">					(<span class="built_in">len</span>(n.path) &gt;= <span class="built_in">len</span>(path) || path[<span class="built_in">len</span>(n.path)] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">					<span class="keyword">continue</span> walk</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				pathSeg := path</span><br><span class="line">				<span class="keyword">if</span> n.nType != catchAll &#123;</span><br><span class="line">					pathSeg = strings.SplitN(path, <span class="string">&quot;/&quot;</span>, <span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">				&#125;</span><br><span class="line">				prefix := fullPath[:strings.Index(fullPath, pathSeg)] + n.path</span><br><span class="line">				<span class="built_in">panic</span>(<span class="string">&quot;&#x27;&quot;</span> + pathSeg +</span><br><span class="line">					<span class="string">&quot;&#x27; in new path &#x27;&quot;</span> + fullPath +</span><br><span class="line">					<span class="string">&quot;&#x27; conflicts with existing wildcard &#x27;&quot;</span> + n.path +</span><br><span class="line">					<span class="string">&quot;&#x27; in existing prefix &#x27;&quot;</span> + prefix +</span><br><span class="line">					<span class="string">&quot;&#x27;&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 注意，此时的path已经取成了公共前缀的后部分</span></span><br><span class="line">			c := path[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">			<span class="comment">// slash after param</span></span><br><span class="line">            <span class="comment">// 如果当前节点是参数节点类型，比如n.path= :name </span></span><br><span class="line">            <span class="comment">// 且c= / ,且n节点仅有一个孩子节点</span></span><br><span class="line">			<span class="keyword">if</span> n.nType == param &amp;&amp; c == <span class="string">&#x27;/&#x27;</span> &amp;&amp; <span class="built_in">len</span>(n.children) == <span class="number">1</span> &#123;</span><br><span class="line">				parentFullPathIndex += <span class="built_in">len</span>(n.path)</span><br><span class="line">				<span class="comment">//当前节点等于子节点</span></span><br><span class="line">				n = n.children[<span class="number">0</span>]</span><br><span class="line">				<span class="comment">//优先级加1</span></span><br><span class="line">				n.priority++</span><br><span class="line">				<span class="keyword">continue</span> walk</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Check if a child with the next path byte exists</span></span><br><span class="line">			<span class="comment">// 循环查找，n.indices记录着所有孩子节点的第一个字符</span></span><br><span class="line">                        <span class="keyword">for</span> i, max := <span class="number">0</span>, <span class="built_in">len</span>(n.indices); i &lt; max; i++ &#123;</span><br><span class="line">							<span class="comment">//如果找到和当前要插入节点的第一个字符相符，匹配成功</span></span><br><span class="line">				<span class="keyword">if</span> c == n.indices[i] &#123;</span><br><span class="line">					parentFullPathIndex += <span class="built_in">len</span>(n.path)</span><br><span class="line">                                        <span class="comment">// 对应子节点优先级加1，并对该子节点的indices重新排列</span></span><br><span class="line">					i = n.incrementChildPrio(i)</span><br><span class="line">					n = n.children[i]</span><br><span class="line">					<span class="keyword">continue</span> walk</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Otherwise insert it</span></span><br><span class="line">                        <span class="comment">// 如果添加的节点既不是 * 也不是: 这样的通配节点,就执行插入</span></span><br><span class="line">			<span class="keyword">if</span> c != <span class="string">&#x27;:&#x27;</span> &amp;&amp; c != <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line">				<span class="comment">// []byte for proper unicode char conversion, see #65</span></span><br><span class="line">				n.indices += bytesconv.BytesToString([]<span class="type">byte</span>&#123;c&#125;)</span><br><span class="line">				child := &amp;node&#123;</span><br><span class="line">					fullPath: fullPath,</span><br><span class="line">				&#125;</span><br><span class="line">				n.children = <span class="built_in">append</span>(n.children, child)</span><br><span class="line">				n.incrementChildPrio(<span class="built_in">len</span>(n.indices) - <span class="number">1</span>)</span><br><span class="line">				n = child</span><br><span class="line">			&#125;</span><br><span class="line">			n.insertChild(path, fullPath, handlers)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Otherwise and handle to current node</span></span><br><span class="line">		<span class="keyword">if</span> n.handlers != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;handlers are already registered for path &#x27;&quot;</span> + fullPath + <span class="string">&quot;&#x27;&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		n.handlers = handlers</span><br><span class="line">		n.fullPath = fullPath</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Priority-优先级"><a href="#Priority-优先级" class="headerlink" title="Priority 优先级"></a>Priority 优先级</h3><p>为了能快速找到并组合完整的路由，GIN 在添加路由的同时，会在每个节点中添加 Priority 这个属性。在查找时根据 Priority 进行排序，常用节点(通过次数理论最多的节点) 在最前，并且同一层级里面 Priority 值越大，越优先进行匹配。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Search for a wildcard segment and check the name for invalid characters.</span></span><br><span class="line"><span class="comment">// Returns -1 as index, if no wildcard was found.</span></span><br><span class="line"><span class="comment">// wildcard-通配符字符串（例如:name,wildcard就为name） i-通配符在path的索引 valid-是否有合法的通配符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findWildcard</span><span class="params">(path <span class="type">string</span>)</span></span> (wildcard <span class="type">string</span>, i <span class="type">int</span>, valid <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="comment">// Find start</span></span><br><span class="line">	<span class="keyword">for</span> start, c := <span class="keyword">range</span> []<span class="type">byte</span>(path) &#123;</span><br><span class="line">		<span class="comment">// A wildcard starts with &#x27;:&#x27; (param) or &#x27;*&#x27; (catch-all)</span></span><br><span class="line">		<span class="keyword">if</span> c != <span class="string">&#x27;:&#x27;</span> &amp;&amp; c != <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Find end and check for invalid characters</span></span><br><span class="line">		valid = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">for</span> end, c := <span class="keyword">range</span> []<span class="type">byte</span>(path[start+<span class="number">1</span>:]) &#123;</span><br><span class="line">			<span class="keyword">switch</span> c &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">				<span class="keyword">return</span> path[start : start+<span class="number">1</span>+end], start, valid</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>, <span class="string">&#x27;*&#x27;</span>:   <span class="comment">//一个通配符后还有一个通配符，valid置为false</span></span><br><span class="line">				valid = <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> path[start:], start, valid</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, <span class="number">-1</span>, <span class="literal">false</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//插入子节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> insertChild(path <span class="type">string</span>, fullPath <span class="type">string</span>, handlers HandlersChain) &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// Find prefix until first wildcard</span></span><br><span class="line">		wildcard, i, valid := findWildcard(path)</span><br><span class="line">		<span class="keyword">if</span> i &lt; <span class="number">0</span> &#123; <span class="comment">// No wildcard found</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// The wildcard name must not contain &#x27;:&#x27; and &#x27;*&#x27;</span></span><br><span class="line">		<span class="keyword">if</span> !valid &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;only one wildcard per path segment is allowed, has: &#x27;&quot;</span> +</span><br><span class="line">				wildcard + <span class="string">&quot;&#x27; in path &#x27;&quot;</span> + fullPath + <span class="string">&quot;&#x27;&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// check if the wildcard has a name</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(wildcard) &lt; <span class="number">2</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;wildcards must be named with a non-empty name in path &#x27;&quot;</span> + fullPath + <span class="string">&quot;&#x27;&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Check if this node has existing children which would be</span></span><br><span class="line">		<span class="comment">// unreachable if we insert the wildcard here</span></span><br><span class="line">		<span class="comment">// 检查此节点是否有现有子节点，如果有子节点，我们在插入通配符，将没办法再访问这些子节点</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(n.children) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;wildcard segment &#x27;&quot;</span> + wildcard +</span><br><span class="line">				<span class="string">&quot;&#x27; conflicts with existing children in path &#x27;&quot;</span> + fullPath + <span class="string">&quot;&#x27;&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> wildcard[<span class="number">0</span>] == <span class="string">&#x27;:&#x27;</span> &#123; <span class="comment">// param</span></span><br><span class="line">			<span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// Insert prefix before the current wildcard</span></span><br><span class="line">				<span class="comment">// 当前节点n保存通配符的前面部分</span></span><br><span class="line">				n.path = path[:i]</span><br><span class="line">				path = path[i:]</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//wildChild设为true表示子节点有通配符</span></span><br><span class="line">			n.wildChild = <span class="literal">true</span></span><br><span class="line">			child := &amp;node&#123;</span><br><span class="line">				nType:    param,</span><br><span class="line">				path:     wildcard,</span><br><span class="line">				fullPath: fullPath,</span><br><span class="line">			&#125;</span><br><span class="line">			n.children = []*node&#123;child&#125;</span><br><span class="line">			n = child</span><br><span class="line">			n.priority++</span><br><span class="line"></span><br><span class="line">			<span class="comment">// if the path doesn&#x27;t end with the wildcard, then there</span></span><br><span class="line">			<span class="comment">// will be another non-wildcard subpath starting with &#x27;/&#x27;</span></span><br><span class="line">			<span class="comment">// 如果通配符后面还有字符，则一定以/为开头</span></span><br><span class="line">			<span class="comment">// 例如/:name/age 通配符后还有/age</span></span><br><span class="line">			<span class="comment">// 这里的英文注释说“将会有另一个以&#x27;/&#x27;开头的非通配符子路径”</span></span><br><span class="line">			<span class="comment">// 这不代表不能处理/:name/*hobby这种，上面已经展示了会将通配符的前面部分</span></span><br><span class="line">			<span class="comment">// 设为父节点，也就是说通配符节点的父节点一定是一个非通配符节点，英文的注释应该这么理解的</span></span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(wildcard) &lt; <span class="built_in">len</span>(path) &#123;</span><br><span class="line">				path = path[<span class="built_in">len</span>(wildcard):]</span><br><span class="line"></span><br><span class="line">				child := &amp;node&#123;</span><br><span class="line">					priority: <span class="number">1</span>,</span><br><span class="line">					fullPath: fullPath,</span><br><span class="line">				&#125;</span><br><span class="line">				n.children = []*node&#123;child&#125;</span><br><span class="line">				n = child</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Otherwise we&#x27;re done. Insert the handle in the new leaf</span></span><br><span class="line">			n.handlers = handlers</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// catchAll</span></span><br><span class="line">		<span class="comment">// 通配符不是:那么就是*，因为*是全匹配的通配符，那么这种情况是不允许的/*name/pwd</span></span><br><span class="line">		<span class="keyword">if</span> i+<span class="built_in">len</span>(wildcard) != <span class="built_in">len</span>(path) &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;catch-all routes are only allowed at the end of the path in path &#x27;&quot;</span> + fullPath + <span class="string">&quot;&#x27;&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果当前节点的最后一个字符是/，则与全匹配通配符*冲突</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(n.path) &gt; <span class="number">0</span> &amp;&amp; n.path[<span class="built_in">len</span>(n.path)<span class="number">-1</span>] == <span class="string">&#x27;/&#x27;</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;catch-all conflicts with existing handle for the path segment root in path &#x27;&quot;</span> + fullPath + <span class="string">&quot;&#x27;&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// currently fixed width 1 for &#x27;/&#x27;</span></span><br><span class="line">		i--</span><br><span class="line">		<span class="keyword">if</span> path[i] != <span class="string">&#x27;/&#x27;</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;no / before catch-all in path &#x27;&quot;</span> + fullPath + <span class="string">&quot;&#x27;&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		n.path = path[:i]</span><br><span class="line"></span><br><span class="line">		<span class="comment">// First node: catchAll node with empty path</span></span><br><span class="line">		<span class="comment">// *可以匹配0个或多个字符，第一个节点保存为空，也就是*匹配0个字符的情况</span></span><br><span class="line">		child := &amp;node&#123;</span><br><span class="line">			wildChild: <span class="literal">true</span>,</span><br><span class="line">			nType:     catchAll,</span><br><span class="line">			fullPath:  fullPath,</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		n.children = []*node&#123;child&#125;</span><br><span class="line">		n.indices = <span class="type">string</span>(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">		n = child</span><br><span class="line">		n.priority++</span><br><span class="line"></span><br><span class="line">		<span class="comment">// second node: node holding the variable</span></span><br><span class="line">		<span class="comment">// 匹配多个字符的情况</span></span><br><span class="line">		child = &amp;node&#123;</span><br><span class="line">			path:     path[i:],</span><br><span class="line">			nType:    catchAll,</span><br><span class="line">			handlers: handlers,</span><br><span class="line">			priority: <span class="number">1</span>,</span><br><span class="line">			fullPath: fullPath,</span><br><span class="line">		&#125;</span><br><span class="line">		n.children = []*node&#123;child&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If no wildcard was found, simply insert the path and handle</span></span><br><span class="line">	n.path = path</span><br><span class="line">	n.handlers = handlers</span><br><span class="line">	n.fullPath = fullPath</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>摘自<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/358704308">Gin源码解析（一）</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2023/02/22/2023-02-20-golangroadmap/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2023/02/22/2023-02-20-golangroadmap/" class="post-title-link" itemprop="url">golang 问题整理</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-02-22 19:30:00" itemprop="dateCreated datePublished" datetime="2023-02-22T19:30:00+08:00">2023-02-22</time></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="Go语言Slice是否线程安全"><a href="#Go语言Slice是否线程安全" class="headerlink" title="Go语言Slice是否线程安全"></a>Go语言Slice是否线程安全</h1><p>Go语言实现线程安全常用的几种方式:1.互斥锁；2.读写锁；3.原子操作；4.sync.once；5. sync.atomic；6.channel<br>slice底层结构并没有使用加锁等方式，不支持并发读写，所以并不是线程安全的，使用多个goroutine对类型为slice的变量进行操作，每次输出的值大概率都不会一样，与预期值不一致; slice在并发执行中不会报错，但是数据会丢失。</p><h1 id="slice内存泄漏分析"><a href="#slice内存泄漏分析" class="headerlink" title="slice内存泄漏分析"></a>slice内存泄漏分析</h1><blockquote><p>（1）发生场景：截取长slice中的一段导致长slice未释放</p></blockquote><p>由于底层都是数组，如果截长slice的一段，其实相当于引用了底层数组中的一小段。只要还有引用，golang的gc就不能回收数组。这种情况导致未使用的数组空间，未及时回收。</p><p>解决方案：新建一个长度为0的slice，将需要的一小段slice使用append方法添加到新的slice。再将原来的slice置为nil。</p><blockquote><p>2）发生场景：没有重置丢失的子切片元素中的指针</p></blockquote><p>没有及时将不再使用的slice置为nil</p><p>解决方案：如果slice中包含很多元素，再只有一小部分元素需要使用的情况下。建议重新分配一个slice将需要保留的元素加入其中，将原来的长slice整个置为nil。</p><h1 id="Golang-Slice-的底层实现"><a href="#Golang-Slice-的底层实现" class="headerlink" title="Golang Slice 的底层实现"></a>Golang Slice 的底层实现</h1><p>切片是基于数组实现的，它的底层是数组，它自己本身非常小，可以理解为对 底层数组的抽象。因为基于数组实现，所以它的底层的内存是连续分配的，效 率非常高，还可以通过索引获得数据。</p><p>切片本身并不是动态数组或者数组指针。它内部实现的数据结构通过指针引用 底层数组，设定相关属性将数据读写操作限定在指定的区域内。切片本身是一 个只读对象，其工作机制类似数组指针的一种封装。</p><p>切片对象非常小，是因为它是只有 3 个字段的数据结构：</p><ul><li><p>指向底层数组的指针</p></li><li><p>切片的长度</p></li><li><p>切片的容量</p></li></ul><h1 id="golang里的数组和切片"><a href="#golang里的数组和切片" class="headerlink" title="golang里的数组和切片"></a>golang里的数组和切片</h1><p>数组长度是固定的，而切片是可变长的。可以把切片看作是对底层数组的封装，每个切片的底层数据结构中，一定会包含一个数组。数组可以被称为切片的底层数组，切片也可以被看作对数组某一连续片段的引用。因此，Go中切片属于引用类型，而数组属于值类型，通过内建函数len，可以取得数组和切片的长度。通过内建函数cap，可以得到数组和切片的容量。但是数组的长度和容量是相等的，并且都不可变，而且切片容量是有变化规律的。</p><h1 id="对已经关闭的channel进行读写操作会发生什么"><a href="#对已经关闭的channel进行读写操作会发生什么" class="headerlink" title="对已经关闭的channel进行读写操作会发生什么?"></a>对已经关闭的channel进行读写操作会发生什么?</h1><ol><li><p>读已关闭的channel<br>读已经关闭的channel无影响。<br>如果在关闭前，通道内部有元素，会正确读到元素的值；<br>如果关闭前通道无元素，则会读取到通道内元素类型对应的零值。<br>若遍历通道，如果通道未关闭，读完元素后，会报死锁的错误。<br>fatal error: all goroutines are asleep - deadlock!</p></li><li><p>写已关闭的通道<br>会引发panic: send on closed channel</p></li><li><p>关闭已关闭的通道<br>会引发panic: close of closed channel</p></li></ol><p><strong>总结</strong>：对于一个已初始化，但并未关闭的通道来说，收发操作一定不会引发 panic。但是通道一旦关闭，再对它进行发送操作，就会引发 panic。如果我们试图关闭一个已经关闭了的通道，也会引发 panic。</p><h1 id="go-struct-能不能比较"><a href="#go-struct-能不能比较" class="headerlink" title="go struct 能不能比较"></a>go struct 能不能比较</h1><p>需要具体情况具体分析，如果struct中含有不能被比较的字段类型，就不能被比较，如果struct中所有的字段类型都支持比较，那么就可以被比较。</p><p>不可被比较的类型:<br>① slice，因为slice是引用类型，除非是和nil比较<br>② map，和slice同理，如果要比较两个map只能通过循环遍历实现<br>③ 函数类型</p><p>其他的类型都可以比较。</p><p>还有两点值得注意：</p><p>结构体之间只能比较它们是否相等，而不能比较它们的大小。<br>只有所有属性都相等而属性顺序都一致的结构体才能进行比较。</p><h1 id="数组是如何实现根据下标随机访问数组元素的吗？"><a href="#数组是如何实现根据下标随机访问数组元素的吗？" class="headerlink" title="数组是如何实现根据下标随机访问数组元素的吗？"></a>数组是如何实现根据下标随机访问数组元素的吗？</h1><p>例如： <code>a := [10]int&#123;0&#125;</code></p><ul><li>计算机给数组a，分配了一组连续的内存空间。</li><li>比如内存块的首地址为 base_address&#x3D;1000。</li><li>当计算给每个内存单元分配一个地址，计算机通过地址来访问数据。当计算机需要访问数组的某个元素的时候，会通过一个寻址公式来计算存储的内存地址。</li></ul><h1 id="GMP模型"><a href="#GMP模型" class="headerlink" title="GMP模型"></a>GMP模型</h1><ul><li><code>G（Goroutine）</code>：G 就是我们所说的 Go 语言中的协程 Goroutine 的缩写，相当于操作系统中的进程控制块。其中存着 goroutine 的运行时栈信息，CPU 的一些寄存器的值以及执行的函数指令等。</li><li><code>M（Machine）</code>：代表一个操作系统的主线程，对内核级线程的封装，数量对应真实的 CPU 数。一个 M 直接关联一个 os 内核线程，用于执行 G。M 会优先从关联的 P 的本地队列中直接获取待执行的 G。M 保存了 M 自身使用的栈信息、当前正在 M上执行的 G 信息、与之绑定的 P 信息。</li><li><code>P（Processor）</code>：Processor 代表了 M 所需的上下文环境，代表 M 运行 G 所需要的资源。是处理用户级代码逻辑的处理器，可以将其看作一个局部调度器使 go 代码在一个线程上跑。当 P 有任务时，就需要创建或者唤醒一个系统线程来执行它队列里的任务，所以 P 和 M 是相互绑定的。总的来说，P 可以根据实际情况开启协程去工作，它包含了运行 goroutine 的资源，如果线程想运行 goroutine，必须先获取 P，P 中还包含了可运行的 G 队列。</li></ul><h1 id="go垃圾回收，什么时候触发"><a href="#go垃圾回收，什么时候触发" class="headerlink" title="go垃圾回收，什么时候触发"></a>go垃圾回收，什么时候触发</h1><p>主动触发(手动触发)，通过调用 runtime.GC 来触发GC，此调用阻塞式地等待当前GC运行完毕。<br>被动触发，分为两种方式：<br>1）使用步调（Pacing）算法，其核心思想是控制内存增长的比例,每次内存分配时检查当前内存分配量是否已达到阈值（环境变量GOGC）：默认100%，即当内存扩大一倍时启用GC。<br>2）使用系统监控，当超过两分钟没有产生任何GC时，强制触发 GC。</p><h1 id="gc算法有哪些？"><a href="#gc算法有哪些？" class="headerlink" title="gc算法有哪些？"></a>gc算法有哪些？</h1><p>常见的垃圾回收算法有以下几种：</p><p><strong>引用计数</strong> ：对每个对象维护一个引用计数，当引用该对象的对象被销毁时，引用计数减1，当引用计数器为0时回收该对象。<br>优点：对象可以很快的被回收，不会出现内存耗尽或达到某个阀值时才回收。<br>缺点：不能很好的处理循环引用，而且实时维护引用计数，有也一定的代价。<br>代表语言：Python、PHP<br><strong>标记-清除</strong>：从根变量开始遍历所有引用的对象，引用的对象标记为”被引用”，没有被标记的进行回收。<br>优点：解决了引用计数的缺点。<br>缺点：需要STW，即要暂时停掉程序运行。<br>代表语言：Golang(其采用三色标记法)<br><strong>分代收集</strong>：按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，而短的放入新生代，不同代有不能的回收算法和回收频率。<br>优点：回收性能好<br>缺点：算法复杂<br>代表语言： JAVA<br>三色标记法<br>1)初始状态下所有对象都是白色的。<br>2)从根节点开始遍历所有对象，把遍历到的对象变成灰色对象<br>3)遍历灰色对象，将灰色对象引用的对象也变成灰色，然后将遍历过的灰色对象变成黑色对象。<br>4)循环步骤3，直到灰色对象全部变黑色。<br>5)回收所有白色对象（垃圾）。</p><h1 id="make-与-new-的区别"><a href="#make-与-new-的区别" class="headerlink" title="make 与 new 的区别"></a>make 与 new 的区别</h1><p>引用类型与值类型</p><ul><li><p><code>引用类型</code> 变量存储的是一个地址，这个地址存储最终的值。内存通常在堆上分配。通过 GC 回收。包括 指针、slice 切片、管道 channel、接口 interface、map、函数等。</p></li><li><p><code>值类型</code>是 基本数据类型，int,float,bool,string, 以及数组和 struct 特点：变量直接存储值，内存通常在栈中分配，栈在函数调用后会被释放</p></li><li><p>对于<code>引用类型</code>的变量，我们不光要声明它，还要为它分配内容空间</p></li><li><p>对于<code>值类型</code>的则不需要显示分配内存空间，是因为go会默认帮我们分配好</p></li></ul><p><strong>new()</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">new</span><span class="params">(Type)</span></span> *Type</span><br></pre></td></tr></table></figure><p><code>new()</code>对类型进行内存分配,入参为类型,返回为类型的指针，指向分配类型的内存地址</p><p><strong>make()</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(t Type, size ...IntegerType)</span></span> Type</span><br></pre></td></tr></table></figure><p>make()也是用于内存分配的，但是和new不同，它只用于channel、map以及切片的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。</p><p>注意，因为这三种类型是引用类型，所以必须得初始化，但是不是置为零值，这个和new是不一样的。</p><p>简而言之make()用于初始化slice, map, channel等内置数据结构</p><h1 id="如何判断channel是否关闭？"><a href="#如何判断channel是否关闭？" class="headerlink" title="如何判断channel是否关闭？"></a>如何判断channel是否关闭？</h1><ul><li><p>读channel的时候判断其是否已经关闭</p><p> <code>_,ok := &lt;- jobs</code></p><p> 此时如果 channel 关闭，ok 值为 false</p></li><li><p>写入channel的时候判断其是否已经关闭</p></li></ul><ol><li><p>_,ok :&#x3D; &lt;- jobs</p><p> 此时如果 channel 关闭，ok 值为 false，如果 channel 没有关闭，则会漏掉一个 jobs中的一个数据</p></li><li><p>使用 select 方式</p><p> 再创建一个 channel，叫做 timeout，如果超时往这个 channel 发送 true，在生产者发送数据给 jobs 的 channel，用 select 监听 timeout，如果超时则关闭 jobs 的 channel。</p></li></ol><h1 id="go-的锁是可重入的吗？"><a href="#go-的锁是可重入的吗？" class="headerlink" title="go 的锁是可重入的吗？"></a>go 的锁是可重入的吗？</h1><p>不是可重入锁。</p><p>讨论这个问题前，先解释一下“重入”这个概念。当一个线程获取到锁时，如果没有其他线程拥有这个锁，那么这个线程<br>就会成功获取到这个锁。线程持有这个锁后，其他线程再请求这个锁，其他线程就会进入阻塞等待的状态。但是如果游泳这个锁的<br>线程再请求这把锁的话，就不会阻塞，而是成功返回，这就是可重入锁。可重入锁也叫做递归锁。<br>为什么 go 的锁不是可重入锁，因为 Mutex 的实现中，没有记录哪个 goroutine 拥有这把锁。换句话说，我们可以通过<br>扩展来将 go 的锁变为可重入锁，这里就不展开了。下面是一个误用 Mutex 的重入例子：<a target="_blank" rel="noopener" href="https://github.com/guowei-gong/go-demo/commit/a6fc236853f5cd0efd4e62269cfe60a19de7a96e">https://github.com/guowei-gong/go-demo/commit/a6fc236853f5cd0efd4e62269cfe60a19de7a96e</a></p><h1 id="go-中用-for-遍历多次执行-goroutine会存在什么问题"><a href="#go-中用-for-遍历多次执行-goroutine会存在什么问题" class="headerlink" title="go 中用 for 遍历多次执行 goroutine会存在什么问题"></a>go 中用 for 遍历多次执行 goroutine会存在什么问题</h1><ol><li><p>假如在协程中打印for的下标i或当前下标的元素,会随机打印载体中的元素.</p><p> 原因有二:</p><ul><li><p>golang是值拷贝传递 for循环很快就执行完了，但是创建的10个协程需要做初始化。上下文准备，堆栈，和内核态的线程映射关系的工作，是需要时间的，比for慢，等都准备好了的时候，会同时访问i。这个时候的i肯定是for执行完成后的下标。（也可能有个别的协程已经准备好了，取i的时候，正好是5，或者7，就输出了这些数字）。</p><p> 解决的方法就是闭包，给匿名函数增加入参，因为是值传递，所以每次for创建一个协程的时候，会拷贝一份i传到这个协程里面去。 或者在开启协程之前声明一个新的变量 &#x3D; i。</p></li></ul></li><li><p>假如当前for是并发读取文件</p></li></ol><p>程序会panic:too many open files</p><p>解决的方法:通过带缓冲的channel和sync.waitgroup控制协程并发量。</p><h1 id="空结构体占不占内存空间？-为什么使用空结构体？"><a href="#空结构体占不占内存空间？-为什么使用空结构体？" class="headerlink" title="空结构体占不占内存空间？ 为什么使用空结构体？"></a>空结构体占不占内存空间？ 为什么使用空结构体？</h1><p>准确的来说，空结构体有一个特殊起点： zerobase 变量。zerobase是一个占用 8 个字节的uintptr全局变量。每次定义 struct {} 类型的变量，编译器只是把zerobase变量的地址给出去。也就是说空结构体的变量的内存地址都是一样的。</p><h1 id="进程、线程、协程的区别？"><a href="#进程、线程、协程的区别？" class="headerlink" title="进程、线程、协程的区别？"></a>进程、线程、协程的区别？</h1><p>概念定义</p><p>进程： 进程是一个具有一定独立功能的程序关于某个数据集合上的一次运行活动，是系统资源分配和独立运行的最小单位。<br>线程： 线程是进程的一个执行单元，是任务调度和系统执行的最小单位。<br>协程： 协程是一种用户态的轻量级线程，协程的调度完全由用户控制。</p><p>进程与线程的区别</p><ol><li>根本区别：进程是操作系统资源分配和独立运行的最小单位；线程是任务调度和系统执行的最小单位。</li><li>地址空间区别： 每个进程都有独立的地址空间，一个进程崩溃不影响其它进程；一个进程中的多个线程共享该进程的地址空间，一个线程的非法操作会使整个进程崩溃。</li><li>上下文切换开销区别： 每个进程有独立的代码和数据空间，进程之间上下文切换开销较大；线程组共享代码和数据空间，线程之间切换的开销较小。</li></ol><p>线程和协程的区别</p><ol><li>内存开销：创建一个协程需要2kb, 栈空间不够会自动扩容， 创建一个线程需要1M空间。</li><li>创建和销毁：创建线程是和操作系统打交道，内核态 开销更大， 协程是由runtime管理，属于用户态 开销小。</li><li>切换成本：线程切换 需要保存各种寄存器，切换时间大概在1500-2000us, 协程保存的寄存器比较少， 切换时间大概在200us, 它能执行更多的指令。</li></ol><h1 id="defer-recover-panic-执行顺序"><a href="#defer-recover-panic-执行顺序" class="headerlink" title="defer recover panic 执行顺序"></a>defer recover panic 执行顺序</h1><p>执行顺序应该为panic、defer、recover</p><ul><li>发生panic的函数并不会立刻返回，而是先层层函数执行defer，再返回。如果有办法将panic捕获到panic，就正常处理（若是外部函数捕获到，则外部函数只执行defer），如果没有没有捕获，程序直接异常终止。</li><li>Go语言提供了recover内置函数。前面提到，一旦panic逻辑就会走到defer（<strong>defer必须在panic的前面！</strong>)。调用recover函数将会捕获到当前的panic，被捕获到的panic就不会向上传递了</li><li>在panic发生时，<strong>在前面的defer中通过recover捕获这个panic，转化为错误通过返回值告诉方法调用者。</strong></li></ul><h1 id="如何解决孤儿进程的出现"><a href="#如何解决孤儿进程的出现" class="headerlink" title="如何解决孤儿进程的出现"></a>如何解决孤儿进程的出现</h1><p><strong>孤儿进程</strong>：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</p><p>解决方案</p><p>孤儿进程结束后会被 init 进程善后，并没有危害，而僵尸进程则会一直占着进程号，操作系统的进程数量有限则会受影响。</p><p><strong>僵尸进程</strong>：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</p><p>僵尸进程解决方案</p><p>进程等待—wait函数和waitpid函数<br>wait函数<br>创建一个子进程，子进程正常逻辑，父进程调用wait函数来进行等待，当子进程退出的时候，由于父进程在等待，所以子进程就不会变成僵尸进程<br>父进程一开始调用wait函数，就会阻塞在wait函数中，等待子进程<br>直到子进程退出，wait函数调用才返回，父进程接着执行wait函数之后的代码</p><h1 id="说一下reflect"><a href="#说一下reflect" class="headerlink" title="说一下reflect"></a>说一下reflect</h1><p>recflect是golang用来检测存储在接口变量内部(值value；类型concrete type) pair对的一种机制。它提供了两种类型（或者说两个方法）让我们可以很容易的访问接口变量内容，分别是reflect.ValueOf() 和 reflect.TypeOf()。</p><p>ValueOf用来获取输入参数接口中的数据的值，如果接口为空则返回0<br>TypeOf用来动态获取输入参数接口中的值的类型，如果接口为空则返回nil</p><h1 id="Golang-里怎么避免内存逃逸？"><a href="#Golang-里怎么避免内存逃逸？" class="headerlink" title="Golang 里怎么避免内存逃逸？"></a>Golang 里怎么避免内存逃逸？</h1><ol><li>不要盲目使用变量指针作为参数，虽然减少了复制，但变量逃逸的开销更大。</li><li>预先设定好slice长度，避免频繁超出容量，重新分配。</li><li>一个经验是，指针指向的数据大部分在堆上分配的，请注意。</li></ol><p>出现内存逃逸的情况有：</p><ol><li><p>发送指针或带有指针的值到channel，因为编译时候无法知道那个goroutine会在channel接受数据，编译器无法知道什么时候释放。</p></li><li><p>在一个切片上存储指针或带指针的值。比如[]*string，导致切片内容逃逸，其引用值一直在堆上。</p></li><li><p>切片的append导致超出容量，切片重新分配地址，切片背后的存储基于运行时的数据进行扩充，就会在堆上分配。</p></li><li><p>调用接口类型时，接口类型的方法调用是动态调度，实际使用的具体实现只能在运行时确定，如一个接口类型为io.Reader的变量r，对r.Read(b)的调用将导致r的值和字节片b的后续转义并因此分配到堆上。</p></li><li><p>在方法内把局部变量指针返回，被外部引用，其生命周期大于栈，导致内存溢出。</p></li></ol><h1 id="defer的执行顺序"><a href="#defer的执行顺序" class="headerlink" title="defer的执行顺序"></a>defer的执行顺序</h1><ol><li>一个函数中多个defer的执行顺序</li></ol><p>defer的作用就是把defer关键字之后的函数压入一个栈中延迟执行，多个defer的执行顺序是后进先出</p><ol start="2"><li>defer、return、返回值的执行返回顺序</li></ol><p>return最先执行，先将结果写入返回值中（即赋值）；接着defer开始执行一些收尾工作；最后函数携带当前返回值退出（即返回值）</p><h1 id="go-init-的执行顺序，注意是不按导入规则的（这里是编译时按文件名的顺序执行的）"><a href="#go-init-的执行顺序，注意是不按导入规则的（这里是编译时按文件名的顺序执行的）" class="headerlink" title="go init 的执行顺序，注意是不按导入规则的（这里是编译时按文件名的顺序执行的）"></a>go init 的执行顺序，注意是不按导入规则的（这里是编译时按文件名的顺序执行的）</h1><ol><li>init函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等</li><li>每个包可以拥有多个init函数</li><li>包的每个源文件也可以拥有多个init函数</li><li>同一个包中多个init函数的执行顺序go语言没有明确的定义(说明)</li><li>不同包的init函数按照包导入的依赖关系决定该初始化函数的执行顺序</li><li>init函数不能被其他函数调用，而是在main函数执行之前，自动被调用</li></ol></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2023/01/31/2023-01-31-%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2023/01/31/2023-01-31-%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" class="post-title-link" itemprop="url">golang内存模型</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-01-31 19:30:00" itemprop="dateCreated datePublished" datetime="2023-01-31T19:30:00+08:00">2023-01-31</time></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="栈内存（协程栈、调用栈）"><a href="#栈内存（协程栈、调用栈）" class="headerlink" title="栈内存（协程栈、调用栈）"></a>栈内存（协程栈、调用栈）</h1><ul><li>go的<strong>协程栈</strong>位于go<strong>堆内存</strong>上</li><li>go<strong>堆内存</strong>位于操作系统<strong>虚拟内存</strong>上</li></ul><p>主要作用：</p><ul><li>协程的执行路径</li><li>局部变量</li><li>函数参数</li><li>返回值</li></ul><p>下面的go程序简述了协程栈的工作流程</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a, b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	sum = a+b</span><br><span class="line">	<span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a:=<span class="number">3</span></span><br><span class="line">	b:=<span class="number">5</span></span><br><span class="line">	<span class="built_in">print</span>(sum(a, b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../img/in-post/2023-01-31/img.png" alt="img.png"></p><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><ul><li>Go使用参数拷贝（深拷贝）</li><li>传递结构体会拷贝结构体全部内容</li><li>传递结构体指针，会拷贝结构体指针</li></ul><h2 id="协程栈作用总结"><a href="#协程栈作用总结" class="headerlink" title="协程栈作用总结"></a>协程栈作用总结</h2><ul><li>协程栈记录了协程的执行现场</li><li>协程栈还记录局部变量，函数参数和返回值</li><li>Go的函数参数是值传递</li></ul><h2 id="协程栈不够大怎么办"><a href="#协程栈不够大怎么办" class="headerlink" title="协程栈不够大怎么办?"></a>协程栈不够大怎么办?</h2><p>引起协程栈不够大的主要原因:</p><ul><li>本地变量太多</li><li>栈帧太多</li></ul><h3 id="本地变量太多"><a href="#本地变量太多" class="headerlink" title="本地变量太多"></a>本地变量太多</h3><p>当协程栈空间不够大会通过变量从栈逃逸到堆上来得到缓解，因而产生<strong>逃逸</strong>问题</p><ul><li>指针逃逸<ul><li>函数返回了对象的指针<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">point</span><span class="params">()</span></span> *<span class="type">int</span> &#123;</span><br><span class="line">    a := <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> &amp;a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    i := point()</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> go build -gcflags&#x3D;-m escape.go<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># command-line-arguments</span></span><br><span class="line">./escape.go:5:6: can inline point</span><br><span class="line">./escape.go:11:12: inlining call to point</span><br><span class="line">./escape.go:12:13: inlining call to fmt.Println</span><br><span class="line">./escape.go:6:2: moved to heap: a</span><br><span class="line">./escape.go:11:12: moved to heap: a</span><br><span class="line">./escape.go:12:13: ... argument does not escape</span><br></pre></td></tr></table></figure></li></ul></li><li>空接口逃逸<ul><li>如果函数的参数是<code>interface</code>,函数的实参很可能会逃逸<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intf</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b := <span class="number">0</span></span><br><span class="line"> fmt.Println(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    intf()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">go build -gcflags=-m escape.go</span><br><span class="line"><span class="comment"># command-line-arguments</span></span><br><span class="line">./escape.go:7:13: inlining call to fmt.Println</span><br><span class="line">./escape.go:10:6: can inline main</span><br><span class="line">./escape.go:7:13: ... argument does not escape</span><br><span class="line">./escape.go:7:13: b escapes to heap</span><br></pre></td></tr></table></figure><blockquote><p>因为<code>interface&#123;&#125;</code>类型的函数往往使用反射,反射往往要求反射的对象在堆上</p></blockquote></li></ul></li><li>大变量逃逸<ul><li>一般在64位机器，超过<code>64k</code>的变量会发生逃逸</li></ul></li></ul><h4 id="逃逸原因"><a href="#逃逸原因" class="headerlink" title="逃逸原因"></a>逃逸原因</h4><ul><li>不是所有的变量都能放在协程栈</li><li>栈帧回收后，需要继续使用的变量</li><li>变量太大</li></ul><h3 id="栈帧太多"><a href="#栈帧太多" class="headerlink" title="栈帧太多"></a>栈帧太多</h3><p>go的栈初始大小为<code>2k</code>,必要时会对栈进行扩容，在<code>1.13</code>版本前使用<strong>分段栈</strong>，后期使用<strong>连续栈</strong></p><p><strong>分段栈</strong></p><p>优点：没有空间浪费</p><p>缺点：伸缩时栈指针会在不连续的空间来回反复横跳</p><p><strong>连续栈</strong></p><p>优点：空间是连续的</p><p>缺点：伸缩时开销大，需要将旧空间拷贝过来,所以当空间不足发生扩容时，变为原来的2倍<br>为了减少伸缩时的开销，当空间使用率不足<code>1/4</code>时，变为原来的<code>1/2</code></p><h1 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h1><p>在64位操作系统中</p><ul><li>Go每次申请的虚拟内存单元位<code>64MB</code></li><li>最多有<code>2^20</code>虚拟内存单元</li><li>内存单元也叫<code>headArena</code></li><li>所有的<code>headArena</code>组成了<code>mheap</code>（Go堆内存）<br><img src="/../img/in-post/2023-01-31/img_7.png" alt="img_7.png"><blockquote><p>操作系统虚拟内存的最大容量是由计算机的地址结构（CPU寻址范围）确定的,虛拟内存的实际容量&#x3D;min（内存和外存容量之和，CPU寻址范围）</p></blockquote></li></ul><blockquote><p>如：某计算机地址结构为32位，按字节编址，内存大小为512MB，外存大小为2GB。 则虚拟内存的最大容量为2^32B&#x3D; 4GB</p></blockquote><blockquote><p>虚拟内存的实际容量 &#x3D;min (2^32B,512MB+2GB)&#x3D;2GB+512MB</p></blockquote><h2 id="headArena分配方式"><a href="#headArena分配方式" class="headerlink" title="headArena分配方式"></a>headArena分配方式</h2><ul><li>线性分配（线性顺序分配）<br><img src="/../img/in-post/2023-01-31/img_1.png" alt="img_1.png"></li><li>链表分配<br><img src="/../img/in-post/2023-01-31/img_2.png" alt="img_2.png"></li><li>分级分配<br><img src="/../img/in-post/2023-01-31/img_5.png" alt="img_5.png"><br>分级分配可以看成将内存整理成不同规格按需进行分配</li></ul><p>线性分配和链表分配都会产生外部内存碎片</p><h3 id="内存管理单元mspan"><a href="#内存管理单元mspan" class="headerlink" title="内存管理单元mspan"></a>内存管理单元mspan</h3><ul><li><code>mspan</code>是内存最小使用单位</li><li>每个<code>mspan</code>为N个相同大小的“格子</li><li>一共有67中<code>mspan</code><br>mspan规格<br><img src="/../img/in-post/2023-01-31/img_4.png" alt="img_4.png"></li></ul><h3 id="中心索引-mcentral"><a href="#中心索引-mcentral" class="headerlink" title="中心索引(mcentral)"></a>中心索引(mcentral)</h3><p>go分配内存时为了达到按需分配，通过<strong>中心索引</strong>能实现快速查找到所需规格的内存,<code>mcentral</code>被放在<code>mspan</code>链表头</p><ul><li>共需要有134个<code>mcentral</code></li><li>67个组用来标记需要<code>GC</code>扫描的<code>mspan</code>，如堆中的对象</li><li>67个组用来标记不需要<code>GC</code>扫描的<code>mspan</code>,如常量</li></ul><p><img src="/../img/in-post/2023-01-31/img_3.png" alt="img_3.png"></p><h3 id="mcentral性能问题"><a href="#mcentral性能问题" class="headerlink" title="mcentral性能问题"></a>mcentral性能问题</h3><ul><li><code>mcentral</code>使用互斥锁保护</li><li>高并发场景下存在锁冲突</li><li>参考协程<code>GMP</code>模型,增加线程本地缓存</li></ul><h3 id="线程缓存mcache-本地缓存"><a href="#线程缓存mcache-本地缓存" class="headerlink" title="线程缓存mcache(本地缓存)"></a>线程缓存mcache(本地缓存)</h3><ul><li>每个<code>P</code>拥有一个<code>mcache</code><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">  id          <span class="type">int32</span></span><br><span class="line">  status      <span class="type">uint32</span> <span class="comment">// one of pidle/prunning/...</span></span><br><span class="line">  link        puintptr</span><br><span class="line">  schedtick   <span class="type">uint32</span>     <span class="comment">// incremented on every scheduler call</span></span><br><span class="line">  syscalltick <span class="type">uint32</span>     <span class="comment">// incremented on every system call</span></span><br><span class="line">  sysmontick  sysmontick <span class="comment">// last tick observed by sysmon</span></span><br><span class="line">  m           muintptr   <span class="comment">// back-link to associated m (nil if idle)</span></span><br><span class="line">  mcache      *mcache</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>一个<code>mcache</code>拥有134种<code>mspan</code>，67个需要<code>GC</code>的和67个不需要<code>GC</code>的<code>mspan</code><br><img src="/../img/in-post/2023-01-31/img_6.png" alt="img_6.png"></li></ul><h3 id="headArena结构总结"><a href="#headArena结构总结" class="headerlink" title="headArena结构总结"></a>headArena结构总结</h3><ul><li>GO使用<code>heapArena</code>向操作系统申请内存</li><li>使用<code>heapArena</code>时，以<code>mspan</code>为单位，防止碎片化</li><li><code>mcentral</code>是<code>mspan</code>们的中心索引</li><li><code>mcache</code>记录了分配给各个<code>P</code>的本地<code>mspan</code></li></ul><h3 id="对象分级"><a href="#对象分级" class="headerlink" title="对象分级"></a>对象分级</h3><p>Go分配内存时变量对象分为3个级别</p><ul><li><code>Tiny</code>微对象无指针(&lt;16B以内)</li><li><code>Small</code>小对象(16k-32k之间)</li><li><code>Large</code>大对象无指针(&gt;32K以上)</li><li>微小对象分配至普通的<code>mspan</code>(class1~class67)<ul><li>从<code>mcache</code>拿到<code>class2</code>级别<code>mspan</code></li><li>多个微对象合并成一个<code>16byte</code>存入到<code>mspan(class2)</code>的一个小单元<br><img src="/../img/in-post/2023-01-31-2/img.png" alt="img.png"></li></ul></li><li>大对象分配至0级<code>mspan</code>(class0)</li></ul><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="什么样对象需要垃圾回收"><a href="#什么样对象需要垃圾回收" class="headerlink" title="什么样对象需要垃圾回收"></a>什么样对象需要垃圾回收</h2><p>垃圾回收思路</p><ul><li>标记-清除<ul><li>标记后直接清除</li><li>优点：逻辑简单</li><li>问题：会有内存碎片产生</li></ul></li><li>标记-整理<ul><li>将碎片化内存整理后，清除多余的碎片</li><li>优点，没有内存碎片</li><li>问题：整理过程cpu开销大</li></ul></li><li>标记-复制<ul><li>复制一块新的内存，然后将旧的内存块上标记的内存整理到新的内存块上</li><li>优点，无内存碎片，内存复制快</li><li>问题：浪费空间</li></ul></li></ul><p>Go因为有独特的内存结构规格管理优势，直接选择最简单的标记-清除</p><h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><p>把根数据段上的数据作为root，基于他们进行进一步的追踪，追踪到的数据就进行标记，最后把没有标记的对象当作垃圾进行释放，是Go的GC的核心原理</p><ul><li>被栈上的指针引用（逃逸到堆上的内存变量）</li><li>被全局变量指针引用</li><li>被寄存器指针引用</li><li>上述变量被称为<code>Root Set</code>(GCROOT)<br><img src="/../img/in-post/2023-01-31-2/img_1.png" alt="img_1.png"><blockquote><p>通过DFS搜索除了G和H剩下的都不能GC掉</p></blockquote></li></ul><h3 id="GC方式"><a href="#GC方式" class="headerlink" title="GC方式"></a>GC方式</h3><p>首先一个重要的概念：<br><strong>STW</strong>：<code>stop the word</code>，指程序执行过程中，中断暂停程序逻辑，专门去进行垃圾回收。</p><h4 id="串行GC"><a href="#串行GC" class="headerlink" title="串行GC"></a>串行GC</h4><ul><li>开启<strong>STW</strong></li><li>通过DFS找到无用内存</li><li>释放堆内存</li><li>停止<strong>STW</strong></li></ul><h4 id="并行GC"><a href="#并行GC" class="headerlink" title="并行GC"></a>并行GC</h4><p>Go采用三色标记法实现并行GC<br>黑色：有用已经分析扫描<br>黑色：有用还未分析扫描<br>白色：暂时无用</p><h5 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h5><p>三色标记法过程</p><p>起初所有堆上的对象都是白色的<br><img src="/../img/in-post/2023-01-31-2/img_2.png" alt="img_2.png"><br>GC开始，遍历堆栈<code>root</code>，将直接可达的对象标记为灰色<br><img src="/../img/in-post/2023-01-31-2/img_4.png" alt="img_4.png"><br>遍历灰色结点,将直接可达的对象标记为灰色，自身标记为黑色<br><img src="/../img/in-post/2023-01-31-2/img_3.png" alt="img_3.png"><br>继续执行第三步同样的步骤，直到所有能够访问到的结点都被标记为黑色<br><img src="/../img/in-post/2023-01-31-2/img_5.png" alt="img_5.png"><br>回收所有白色标记的对象。<br><img src="/../img/in-post/2023-01-31-2/img_6.png" alt="img_6.png"><br>再次标记时，所有对象恢复为白色<br><img src="/../img/in-post/2023-01-31-2/img_7.png" alt="img_7.png"></p><h5 id="三色标记法并行时的问题"><a href="#三色标记法并行时的问题" class="headerlink" title="三色标记法并行时的问题"></a>三色标记法并行时的问题</h5><p>三色标记法在并发标记过程中会出现误回收情况：</p><p>由于是并发执行过程，如果不开启<strong>STW</strong>，GC分析过的某个白色标记，此时被业务代码进行了新的引用，被引用到之前的一个灰色的标记对象，那么此时这个变量应该就不是白色了，但是由于GC已经分析过前面的变量引用关系了，就不会把这个变量标记成灰色和黑色，导致误回收<br>初始状态的对象结构<br><img src="/../img/in-post/2023-01-31-2/img_8.png" alt="img_8.png"><br>C在标记中间时中被E引用，由于E是一开始就被分析过了，所以不再会重新分析E，导致C被误回收<br><img src="/../img/in-post/2023-01-31-2/img_9.png" alt="img_9.png"></p><h5 id="删除写屏障"><a href="#删除写屏障" class="headerlink" title="删除写屏障"></a>删除写屏障</h5><p>原理：当一个白色对象被另外一个对象时解除引用时，将该被引用对象标记为灰色（白色对象被保护）</p><p>缺点：如上面的例子，如果一开是B指向了C，B和C在断开后才会将C标记为白色，由于上述示例C在一开始就没有被引用过，所以不会被标记为黑色</p><h5 id="插入写屏障"><a href="#插入写屏障" class="headerlink" title="插入写屏障"></a>插入写屏障</h5><p>原理：当一个对象引用另外一个对象时，将另外一个对象标记为灰色。</p><p>插入写屏障可以杜绝堆空间新增的被引用的指针误回收的情况；<br>但是由于栈容量小，反应速度要求高，不能用插入屏障的机制。因此，在堆对象扫描完之后，为了不引发误回收，会对栈对象<strong>STW</strong>，然后通过三色并发标记清扫，完成GC。</p><h5 id="混合写屏障"><a href="#混合写屏障" class="headerlink" title="混合写屏障"></a>混合写屏障</h5><p>可以看到之前的插入屏障和删除屏障有明显的自身缺陷：</p><p>插入屏障：需要对栈对象重新<strong>STW</strong>遍历<br>删除屏障：回收精度低</p><p>GO 1.8采用了混合写屏障，混合写屏障，就是结合两者优势，又中和两者的劣势。混合写屏障减少<strong>STW</strong>，并且减少了扫描栈对象的时间。混合写屏障会做如下操作：</p><ul><li>GC开始时，将栈全部可达对象标记为黑色</li><li>GC期间，任何在栈上新创建的对象，均为黑色。<br><strong>将栈上的可达对象全部标黑，扫描过程中，如果某个groutine栈的对象出现引用关系变更，进行STW,但是不会对整个栈STW</strong></li><li>被删除的对象标记为灰色</li><li>被添加的对象标记为灰色</li></ul><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>GoV1.8三色标记法加混合写屏障机制，栈空间不启动屏障机制，堆空间启动屏障机制。整个过程几乎不需要<strong>STW</strong>，效率较高。</p><h3 id="GC优化"><a href="#GC优化" class="headerlink" title="GC优化"></a>GC优化</h3><p>尽量减少堆上的垃圾</p><ul><li>内存池化</li><li>减少逃逸</li><li>尽量使用空结构体</li></ul><h4 id="观察GC"><a href="#观察GC" class="headerlink" title="观察GC"></a>观察GC</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GODEBUG=gctrace=1 ./main</span><br></pre></td></tr></table></figure><p>字段含义：<br><img src="/../img/in-post/2023-01-31-2/img_10.png" alt="img_10.png"></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2023/01/31/2023-02-20-context/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2023/01/31/2023-02-20-context/" class="post-title-link" itemprop="url">context</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-01-31 19:30:00" itemprop="dateCreated datePublished" datetime="2023-01-31T19:30:00+08:00">2023-01-31</time></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="context包内部如何实现的？"><a href="#context包内部如何实现的？" class="headerlink" title="context包内部如何实现的？"></a>context包内部如何实现的？</h1><p>context是 Go 语言在 1.7 版本中引入标准库的接口。context主要用于父子任务之间的同步取消信号，本质上是一种协程调度的方式。另外在使用context时有两点值得注意：上游任务仅仅使用context通知下游任务不再需要，但不会直接干涉和中断下游任务的执行，由下游任务自行决定后续的处理操作，也就是说context的取消操作是无侵入的；context是线程安全的，因为context本身是不可变的（immutable），因此可以放心地在多个协程中传递使用。</p><h2 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h2><ul><li>Deadline — 返回 context.Context 被取消的时间，也就是完成工作的截止日期；</li><li>Done — 返回一个 Channel，这个 Channel 会在当前工作完成或者上下文被取消后关闭，多次调用 Done 方法会返回同一个 Channel；</li><li>Err — 返回 context.Context 结束的原因，它只会在 Done 方法对应的 Channel 关闭时返回非空的值;<ul><li>如果 context.Context 被取消，会返回 Canceled 错误；</li><li>如果 context.Context 超时，会返回 DeadlineExceeded 错误；</li></ul></li><li>Value — 从 context.Context 中获取键对应的值，对于同一个上下文来说，多次调用 Value 并传入相同的 Key 会返回相同的结果，该方法可以用来传递请求特定的数据；</li></ul><h2 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h2><p>在 Goroutine 构成的树形结构中对信号进行同步以减少计算资源的浪费是 context.Context 的最大作用。Go 服务的每一个请求都是通过单独的 Goroutine 处理的，HTTP&#x2F;RPC 请求的处理器会启动新的<br>Goroutine 访问数据库和其他服务。</p><p>（context树结构）</p><p><img src="/../img/in-post/2023-02-20/img.png" alt="img.png"></p><p>每一个 context.Context 都会从最顶层的 Goroutine 一层一层传递到最下层。context.Context 可以在上层 Goroutine 执行出现错误时，将信号及时同步给下层。</p><p>如果不使用 context，当最上层的 Goroutine 因为某些原因执行失败时，下层的 Goroutine 由于没有接收到这个信号所以会继续工作；但是当我们正确地使用 context.Context 时，就可以在下层及时停掉无用的工作以减少额外资源的消耗。</p><p><strong>多个 Goroutine 同时订阅 ctx.Done() 管道中的消息，一旦接收到取消信号就立刻停止当前正在执行的工作。</strong></p><h2 id="默认上下文"><a href="#默认上下文" class="headerlink" title="默认上下文"></a>默认上下文</h2><p>context 包中最常用的方法还是 context.Background、context.TODO，这两个方法都会返回预先初始化好的私有变量 background 和 todo，它们会在同一个 Go 程序中被复用。</p><ul><li>context.Background 是上下文的默认值，所有其他的上下文都应该从它衍生出来；</li><li>context.TODO 应该仅在不确定应该使用哪种上下文时使用。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span></span> Context &#123;</span><br><span class="line">    <span class="keyword">return</span> background</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TODO</span><span class="params">()</span></span> Context &#123;</span><br><span class="line">    <span class="keyword">return</span> todo</span><br><span class="line">&#125;</span><br><span class="line">这两个私有变量都是通过 <span class="built_in">new</span>(emptyCtx) 语句初始化的，它们是指向私有结构体</span><br><span class="line">context.emptyCtx 的指针，这是最简单、最常用的上下文类型。</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////     emptyCtx    ///////////////////</span></span><br><span class="line"><span class="keyword">type</span> emptyCtx <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Err() <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="取消信号"><a href="#取消信号" class="headerlink" title="取消信号"></a>取消信号</h2><p><strong>context.WithCancel</strong> 函数能够从 context.Context 中衍生出一个新的子上下文并返回用于取消该上下文的函数。一旦我们执行返回的取消函数，当前上下文以及它的子上下文都会被取消，所有的 Goroutine<br>都会同步收到这一取消信号。</p><h3 id="Context-子树的取消"><a href="#Context-子树的取消" class="headerlink" title="Context 子树的取消"></a>Context 子树的取消</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  context.WithCancel 函数的实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc) &#123;</span><br><span class="line">    c := newCancelCtx(parent)</span><br><span class="line">    propagateCancel(parent, &amp;c)</span><br><span class="line">    <span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">propagateCancel</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">    done := parent.Done()</span><br><span class="line">    <span class="keyword">if</span> done == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// 父上下文不会触发取消信号</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-done:</span><br><span class="line">		child.cancel(<span class="literal">false</span>, parent.Err()) <span class="comment">// 父上下文已经被取消</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">        p.mu.Lock()</span><br><span class="line">        <span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line">            child.cancel(<span class="literal">false</span>, p.err)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p.mu.Unlock()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">                child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">            <span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>context.newCancelCtx 将传入的上下文包装成私有结构体 context.cancelCtx；</li><li>context.propagateCancel 会构建父子上下文之间的关联，当父上下文被取消时，子上下文也会被取消：</li></ul><p><strong>propagateCancel 可能出现的情况：</strong></p><ul><li>当 parent.Done() &#x3D;&#x3D; nil，也就是 parent 不会触发取消事件时，当前函数会直接返回；</li><li>当 child 的继承链包含可以取消的上下文时，会判断 parent 是否已经触发了取消信号；<ul><li>如果已经被取消，child 会立刻被取消；</li><li>如果没有被取消，child 会被加入 parent 的 children 列表中，等待 parent 释放取消信号；</li></ul></li><li>当父上下文是开发者自定义的类型、实现了 context.Context 接口并在 Done() 方法中返回了非空的管道时；<ul><li>运行一个新的 Goroutine 同时监听 parent.Done() 和 child.Done() 两个 Channel；</li><li>在 parent.Done() 关闭时调用 child.cancel 取消子上下文； context.propagateCancel 的作用是在 parent 和 child 之间同步取消和结束的信号，保证在 parent<br>被取消时，child 也会收到对应的信号，不会出现状态不一致的情况。</li></ul></li></ul><p>context.cancelCtx 实现的几个接口方法也没有太多值得分析的地方，该结构体最重要的方法是 context.cancelCtx.cancel，该方法会关闭上下文中的 Channel 并向所有的子上下文同步取消信号</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line">        c.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    c.err = err</span><br><span class="line">    <span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">        c.done = closedchan</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">close</span>(c.done)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;</span><br><span class="line">        child.cancel(<span class="literal">false</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    c.children = <span class="literal">nil</span></span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">    <span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">        removeChild(c.Context, c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>context 包中的另外两个函数 context.WithDeadline 和 context.WithTimeout 也都能创建可以被取消的计时器上下文 context.timerCtx</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line">	<span class="keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line">	<span class="keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;</span><br><span class="line">		<span class="keyword">return</span> WithCancel(parent)</span><br><span class="line">	&#125;</span><br><span class="line">	c := &amp;timerCtx&#123;</span><br><span class="line">		cancelCtx: newCancelCtx(parent),</span><br><span class="line">		deadline:  d,</span><br><span class="line">	&#125;</span><br><span class="line">	propagateCancel(parent, c)</span><br><span class="line">	dur := time.Until(d)</span><br><span class="line">	<span class="keyword">if</span> dur &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		c.cancel(<span class="literal">true</span>, DeadlineExceeded) <span class="comment">// 已经过了截止日期</span></span><br><span class="line">		<span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">false</span>, Canceled) &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> c.err == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.timer = time.AfterFunc(dur, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			c.cancel(<span class="literal">true</span>, DeadlineExceeded)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>context.WithDeadline 在创建 context.timerCtx 的过程中判断了父上下文的截止日期与当前日期，并通过 time.AfterFunc 创建定时器，当时间超过了截止日期后会调用 context.timerCtx.cancel 同步取消信号。<br>context.timerCtx 内部不仅通过嵌入 context.cancelCtx 结构体继承了相关的变量和方法，还通过持有的定时器 timer 和截止时间 deadline 实现了定时取消的功能</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    cancelCtx</span><br><span class="line">    timer *time.Timer <span class="comment">// Under cancelCtx.mu.</span></span><br><span class="line">    deadline time.Time</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span></span> Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> c.deadline, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    c.cancelCtx.cancel(<span class="literal">false</span>, err)</span><br><span class="line">    <span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">        removeChild(c.cancelCtx.Context, c)</span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">    c.timer.Stop()</span><br><span class="line">    c.timer = <span class="literal">nil</span></span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>context.timerCtx.cancel 方法不仅调用了 context.cancelCtx.cancel，还会停止持有的定时器减少不必要的资源浪费。</p><h2 id="传值方法"><a href="#传值方法" class="headerlink" title="传值方法"></a>传值方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span></span> Context &#123;</span><br><span class="line">	<span class="keyword">if</span> key == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;nil key&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !reflectlite.TypeOf(key).Comparable() &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;key is not comparable&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	Context</span><br><span class="line">	key, val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span></span> Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> c.key == key &#123;</span><br><span class="line">		<span class="keyword">return</span> c.val</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c.Context.Value(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>context.valueCtx 结构体会将除了 Value 之外的 Err、Deadline 等方法代理到父上下文中，它只会响应 context.valueCtx.Value 方法，该方法的实现也很简单 。</p><p>如果 context.valueCtx 中存储的键值对与 context.valueCtx.Value 方法中传入的参数不匹配，就会从父上下文中查找该键对应的值直到某个父上下文中返回 nil 或者查找到对应的值。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2023/01/31/2023-02-22-slice/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2023/01/31/2023-02-22-slice/" class="post-title-link" itemprop="url">slice、append、copy</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-01-31 19:30:00" itemprop="dateCreated datePublished" datetime="2023-01-31T19:30:00+08:00">2023-01-31</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p>数组（Array）是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。因其长度的不可变动，数组在Go中很少直接使用。把一个大数组传递给函数会消耗很多内存。一般采用数组的切片</p><p>几种初始化方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr1 := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">arr2 := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">arr3 := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">0</span>:<span class="number">3</span>,<span class="number">1</span>:<span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h2><p>Slice是一种数据结构，描述与Slice变量本身分开存储的Array的连续部分。 Slice不是Array。Slice描述了Array的一部分。</p><p>slice底层是一个struct</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/slice.go</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer<span class="comment">// 指向数组的指针</span></span><br><span class="line">    <span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建slice的几种方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接通过make创建，可以指定len、cap</span></span><br><span class="line">s4 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过数组/slice 切片生成</span></span><br><span class="line"><span class="keyword">var</span> data [<span class="number">10</span>]<span class="type">int</span></span><br><span class="line">s2 := data[<span class="number">2</span>:<span class="number">8</span>]</span><br><span class="line">s3 := s2[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// append()</span></span><br><span class="line">s6 = <span class="built_in">append</span>(s4,<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接创建</span></span><br><span class="line">s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><p>append() 底层逻辑</p><ol><li>计算追加后slice的总长度n</li><li>如果总长度n大于原cap，则调用growslice func进行扩容（cap最小为n，具体扩容规则见growslice）</li><li>对扩容后的slice进行切片，长度为n，获取slice s，用以存储所有的数据</li><li>根据不同的数据类型，调用对应的复制方法，将原slice及追加的slice的数据复制到新的slice</li></ol><p>growslice 计算cap的逻辑</p><ol><li>原cap扩容一倍，即doublecap</li><li>如果指定cap大于doublecap则使用cap，否则执行如下</li><li>如果原数据长度小于1024，则使用doublecap</li><li>否则在原cap的基础上每次扩容1&#x2F;4，直至不小于cap</li></ol><p><strong>1.18更新</strong></p><p>已经不是 doublecap</p><blockquote><p>Go：v1.18对扩容策略进行了优化，主要是在1.17的基础上对第二点进行了优化</p><ol><li>当期望容量 &gt; 两倍的旧容量时，直接使用期望容量作为新切片的容量</li><li>增加一个阈值并固定为一个常量（threshold），如果旧容量小于这个阈值，则直接使用两倍的旧容量，如果大于等于阈值，那么会进入一个循环，每次增加大概1.3~2倍（取决于threshold），直到大于期望容量<br>源码大致如下：</li></ol></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Go 1.18的扩容实现代码如下，et是切片里的元素类型，old是原切片，cap等于原切片的长度+append新增的元素个数。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="type">int</span>)</span></span> slice &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  newcap := old.<span class="built_in">cap</span></span><br><span class="line">  doublecap := newcap + newcap</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">    newcap = <span class="built_in">cap</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> threshold = <span class="number">256</span></span><br><span class="line">    <span class="keyword">if</span> old.<span class="built_in">cap</span> &lt; threshold &#123;</span><br><span class="line">      newcap = doublecap</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Check 0 &lt; newcap to detect overflow</span></span><br><span class="line">      <span class="comment">// and prevent an infinite loop.</span></span><br><span class="line">      <span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">        <span class="comment">// Transition from growing 2x for small slices</span></span><br><span class="line">        <span class="comment">// to growing 1.25x for large slices. This formula</span></span><br><span class="line">        <span class="comment">// gives a smooth-ish transition between the two.</span></span><br><span class="line">        newcap += (newcap + <span class="number">3</span>*threshold) / <span class="number">4</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Set newcap to the requested cap when</span></span><br><span class="line">      <span class="comment">// the newcap calculation overflowed.</span></span><br><span class="line">      <span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        newcap = <span class="built_in">cap</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>newcap +&#x3D; (newcap + 3*threshold) &#x2F; 4<br>newcap是扩容后的容量，先根据原切片的长度、容量和要添加的元素个数确定newcap大小，最后再对newcap做内存对齐得到最后的newcap。</p><h2 id="扩容的整体逻辑（对应上述append-的2）"><a href="#扩容的整体逻辑（对应上述append-的2）" class="headerlink" title="扩容的整体逻辑（对应上述append()的2）"></a>扩容的整体逻辑（对应上述append()的2）</h2><ol><li>按照原slice的cap及指定cap计算扩容后的cap</li><li>根据计算出cap申请内存(创建新的数组)</li><li>将原slice的数据拷贝到新内存中（新数组）</li><li>返回新slice，新slilce指向新数组，len为原slice的len，cap为扩容后的cap</li></ol><p>正常我们使用，因slice的长度相对较小，append是扩容使用的是doublecap。<br>使用append后会产生新的slice，必须重新赋值到原slice上，才能更新原slice的数据。</p><h2 id="典型例题"><a href="#典型例题" class="headerlink" title="典型例题"></a>典型例题</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data := [<span class="number">10</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">slice := data[<span class="number">5</span>:<span class="number">8</span>]</span><br><span class="line">slice = <span class="built_in">append</span>(slice,<span class="number">9</span>)<span class="comment">// slice=? data=?</span></span><br><span class="line">slice = <span class="built_in">append</span>(slice,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>)<span class="comment">// slice=? data=?</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//第一次append后结果</span><br><span class="line">slice=[0 0 0 9]</span><br><span class="line">data=[0 0 0 0 0 0 0 0 9 0]</span><br><span class="line">//第二次append后结果</span><br><span class="line">[0 0 0 9 10 11 12]</span><br><span class="line">[0 0 0 0 0 0 0 0 9 0]</span><br></pre></td></tr></table></figure><p>可以看到第一次append的结果影响到了原data的数据，第二次append的结果并没有影响到了data的数据，这是为什么呢？</p><p>未append前，slice的cap是5。第一次append一个元素，未超出cap，因此直接存入数据到数组中。第二次append三个元素，append后的元素长度为7，已大于原slice的cap，因此slice需要扩容，扩容后创建了新的数组，复制了data的数据到新数组内，然后存入append的数据，变动的是新数组，原数组data自然不受影响。</p><p>append存在对原数据影响的情况，使用时还是需要注意，如有必要，先copy原数据后再进行slice的操作。</p><p>总结</p><ol><li><p>slice本身并非指针，append追加元素后，意味着底层数组数据（或数组）、len、cap会发生变化，因此append后需要返回新的slice。</p></li><li><p>append在追加元素时，当前cap足够容纳元素，则直接存入数据，否则需要扩容后重新创建新的底层数组，拷贝原数组元素后，再存入追加元素。</p></li><li><p>cap的扩容意味着内存的重新分配，数据的拷贝等操作，为了提高append的效率，若是能预估cap的大小的话，尽量提前声明cap，避免后期的扩容操作。</p></li></ol></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2023/01/28/2023-01-28-golang%E9%94%81%E5%AE%9E%E7%8E%B0%E4%B9%8BSemaphore/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2023/01/28/2023-01-28-golang%E9%94%81%E5%AE%9E%E7%8E%B0%E4%B9%8BSemaphore/" class="post-title-link" itemprop="url">golang锁实现之Semaphore</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-01-28 19:30:00" itemprop="dateCreated datePublished" datetime="2023-01-28T19:30:00+08:00">2023-01-28</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>信号量是在并发编程中常见的一种同步机制，在需要控制访问资源的进程数量时就会用到信号量，它会保证持有的计数器在 0 到初始化的权重之间波动。</p><ul><li>每次获取资源时都会将信号量中的计数器减去对应的数值，在释放时重新加回来；</li><li>当遇到计数器大于信号量大小时，会进入休眠等待其他线程释放信号；</li></ul><p>在go的锁中的底层结构体实现过程中可以看到<code>sema</code>这个关键词，如go的互斥锁或读写锁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	state <span class="type">int32</span></span><br><span class="line">	sema  <span class="type">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    w           Mutex  <span class="comment">// held if there are pending writers</span></span><br><span class="line">    writerSem   <span class="type">uint32</span> <span class="comment">// semaphore for writers to wait for completing readers</span></span><br><span class="line">    readerSem   <span class="type">uint32</span> <span class="comment">// semaphore for readers to wait for completing writers</span></span><br><span class="line">    readerCount <span class="type">int32</span>  <span class="comment">// number of pending readers</span></span><br><span class="line">    readerWait  <span class="type">int32</span>  <span class="comment">// number of departing readers</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h2><p>回顾下操作系统中信号量编程的机制</p><p>用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现了进程互斥、进程同步</p><p>信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量），可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为1的信号量 。</p><p><strong>原语</strong>是一种特殊的程序段，其执行只能一气呵成，不可被中断。 原语是由关中断&#x2F;开中断指令实现 的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”<br>因此如果能把进入区、退出区的操作都用， “原语”实现，使这些操作能 一气呵成”就能避免问题。</p><p><strong>一对原语</strong>：<code>wait(s)</code> 原语 和 <code>signall(S)</code>原语， 可以把原语理解为我们自己写的函数，函数名分别为 <code>wait</code> 和 <code>signal</code>，括号里的信号量<code>S</code> 其实就是两数调用时传入的一个参数。</p><p><code>wait</code>、<code>signal</code> 原语常简称为<code>P</code>、<code>V</code>操作（来自荷兰语 proberen 和 verhogen）</p><p>我们可以把信号量机制互斥用如下代码实现表述出来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span></span></span><br><span class="line"><span class="class">&#125; <span class="title">semaphore</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">wait</span> (<span class="title">semaphore</span> <span class="title">S</span>) &#123;</span> </span><br><span class="line">    S.value--;</span><br><span class="line">    <span class="keyword">if</span> (S.value &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        block(S.L)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span> <span class="params">(semaphore S)</span> &#123; </span><br><span class="line">    S.value++;</span><br><span class="line">    <span class="keyword">if</span> (S.value &lt;= <span class="number">0</span> ) &#123;</span><br><span class="line">        wakeup(S.L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>信号量机制通过休眠队列和wakeup(唤醒)block(挂起)机制实现</p></blockquote><h2 id="go的Semaphore的实现"><a href="#go的Semaphore的实现" class="headerlink" title="go的Semaphore的实现"></a>go的Semaphore的实现</h2><p>go里面sema的实现主要在<code>runtime/sema.go</code>文件中</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>go的<code>runtime</code>有一个全局变量<code>semtable</code>，它放置了所有的信号量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> semtable semTable</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prime to not correlate with any user patterns.</span></span><br><span class="line"><span class="keyword">const</span> semTabSize = <span class="number">251</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> semTable [semTabSize]<span class="keyword">struct</span> &#123;</span><br><span class="line">	root semaRoot</span><br><span class="line">	pad  [cpu.CacheLinePadSize - unsafe.Sizeof(semaRoot&#123;&#125;)]<span class="type">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个信号量使用semaRoot结构体来表示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> semaRoot <span class="keyword">struct</span> &#123;</span><br><span class="line">	lock  mutex</span><br><span class="line">	treap *sudog <span class="comment">// 平衡树的根节点</span></span><br><span class="line">	nwait <span class="type">uint32</span> <span class="comment">// Number of waiters. Read w/o the lock.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原语P"><a href="#原语P" class="headerlink" title="原语P"></a>原语P</h3><p><code>原语P</code>即是<code>wait</code>,在并发编程信号同步过程中用来进行阻塞等待，go的<code>sema</code>主要通过<code>semacquire1</code>来实现<code>wait</code>,通过<code>sync.runtime_Semacquire</code>来调用</p><p><code>semacquire1</code>流程:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">semacquire1</span><span class="params">(addr *<span class="type">uint32</span>, lifo <span class="type">bool</span>, profile semaProfileFlags, skipframes <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	gp := getg()</span><br><span class="line">	<span class="keyword">if</span> gp != gp.m.curg &#123;</span><br><span class="line">		throw(<span class="string">&quot;semacquire not on the G stack&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Easy case.</span></span><br><span class="line">	<span class="keyword">if</span> cansemacquire(addr) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Harder case:</span></span><br><span class="line">	<span class="comment">//	increment waiter count</span></span><br><span class="line">	<span class="comment">//	try cansemacquire one more time, return if succeeded</span></span><br><span class="line">	<span class="comment">//	enqueue itself as a waiter</span></span><br><span class="line">	<span class="comment">//	sleep</span></span><br><span class="line">	<span class="comment">//	(waiter descriptor is dequeued by signaler)</span></span><br><span class="line">	s := acquireSudog()</span><br><span class="line">	root := semtable.rootFor(addr)</span><br><span class="line">	t0 := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">	s.releasetime = <span class="number">0</span></span><br><span class="line">	s.acquiretime = <span class="number">0</span></span><br><span class="line">	s.ticket = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> profile&amp;semaBlockProfile != <span class="number">0</span> &amp;&amp; blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">		t0 = cputicks()</span><br><span class="line">		s.releasetime = <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> profile&amp;semaMutexProfile != <span class="number">0</span> &amp;&amp; mutexprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> t0 == <span class="number">0</span> &#123;</span><br><span class="line">			t0 = cputicks()</span><br><span class="line">		&#125;</span><br><span class="line">		s.acquiretime = t0</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		lockWithRank(&amp;root.lock, lockRankRoot)</span><br><span class="line">		<span class="comment">// Add ourselves to nwait to disable &quot;easy case&quot; in semrelease.</span></span><br><span class="line">		atomic.Xadd(&amp;root.nwait, <span class="number">1</span>)</span><br><span class="line">		<span class="comment">// Check cansemacquire to avoid missed wakeup.</span></span><br><span class="line">		<span class="keyword">if</span> cansemacquire(addr) &#123;</span><br><span class="line">			atomic.Xadd(&amp;root.nwait, <span class="number">-1</span>)</span><br><span class="line">			unlock(&amp;root.lock)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Any semrelease after the cansemacquire knows we&#x27;re waiting</span></span><br><span class="line">		<span class="comment">// (we set nwait above), so go to sleep.</span></span><br><span class="line">		root.queue(addr, s, lifo)</span><br><span class="line">		goparkunlock(&amp;root.lock, waitReasonSemacquire, traceEvGoBlockSync, <span class="number">4</span>+skipframes)</span><br><span class="line">		<span class="keyword">if</span> s.ticket != <span class="number">0</span> || cansemacquire(addr) &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> s.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">		blockevent(s.releasetime-t0, <span class="number">3</span>+skipframes)</span><br><span class="line">	&#125;</span><br><span class="line">	releaseSudog(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分步骤分析</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   gp := getg()</span><br><span class="line"><span class="keyword">if</span> gp != gp.m.curg &#123;</span><br><span class="line">	throw(<span class="string">&quot;semacquire not on the G stack&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一段主要是用来获取sema的当前协程栈，如果拿不到的话会抛出异常</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> cansemacquire(addr) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cansemacquire</span><span class="params">(addr *<span class="type">uint32</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        v := atomic.Load(addr)</span><br><span class="line">        <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> atomic.Cas(addr, v, v<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>atomic.Load</code>和<code>atomic.Cas</code>是原语操作：这段代码可以理解为，判断<code>addr==0</code>,如果为<code>0</code>说明<code>addr</code>被获取过了，要去走下面的流程判断是否需要阻塞，不为<code>0</code>说明<code>addr</code>拿到成功，对<code>addr</code>进行<code>-1</code>操作,此时函数直接<code>return</code>，不会发生阻塞</p><p><code>atomic.Cas</code>的汇编实现</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TEXT ·Cas(SB),NOSPLIT,$0-17</span><br><span class="line">	MOVQ	ptr+0(FP), BX</span><br><span class="line">	MOVL	old+8(FP), AX</span><br><span class="line">	MOVL	new+12(FP), CX</span><br><span class="line">	LOCK</span><br><span class="line">	CMPXCHGL	CX, 0(BX)</span><br><span class="line">	SETEQ	ret+16(FP)</span><br><span class="line">	RET</span><br></pre></td></tr></table></figure><blockquote><p>基于汇编对cpu硬件加锁实现的原子操作</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s := acquireSudog()</span><br><span class="line">root := semtable.rootFor(addr)</span><br><span class="line">t0 := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">s.releasetime = <span class="number">0</span></span><br><span class="line">s.acquiretime = <span class="number">0</span></span><br><span class="line">s.ticket = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>这一部分就是拿到<code>sudog</code>和<code>root</code>队列</p><p><code>root</code>和<code>s</code>的作用:</p><ul><li><p><code>semacquire1</code>会在<code>semtable</code>数组中找一个元素和它对应上。每个元素都有一个<code>root</code>，这个<code>root</code>是<code>Treap</code>树</p></li><li><p>最后<code>addr</code>变成一个树节点，这个树节点，有自己的一个队列，专门放被阻塞的<code>goroutine</code>。叫它阻塞队列吧。 这个阻塞队列是个双端队列，头尾都可以进。</p></li><li><p><code>semacquire1</code>把当前<code>goroutine</code>相关元数据放进阻塞队列之后，就挂起了。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    lockWithRank(&amp;root.lock, lockRankRoot)</span><br><span class="line">    <span class="comment">// 记录root等待队列数量+1</span></span><br><span class="line">    atomic.Xadd(&amp;root.nwait, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 检测addr如果不为0了，就进行唤醒</span></span><br><span class="line">    <span class="keyword">if</span> cansemacquire(addr) &#123;</span><br><span class="line">        atomic.Xadd(&amp;root.nwait, <span class="number">-1</span>)</span><br><span class="line">        unlock(&amp;root.lock)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将sudog协程放入到root队列</span></span><br><span class="line">    root.queue(addr, s, lifo)</span><br><span class="line">	<span class="comment">// 执行挂起</span></span><br><span class="line">    goparkunlock(&amp;root.lock, waitReasonSemacquire, traceEvGoBlockSync, <span class="number">4</span>+skipframes)</span><br><span class="line">    <span class="keyword">if</span> s.ticket != <span class="number">0</span> || cansemacquire(addr) &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这部分的死循环可以理解为阻塞的过程，在<code>addr</code>未唤醒之前，会将当前<code>sudog</code>假如阻塞队列，并挂起等待</p><h3 id="原语V"><a href="#原语V" class="headerlink" title="原语V"></a>原语V</h3><p><code>原语V</code>即是<code>signal</code>,在并发编程信号同步过程中用来进行唤醒，go的<code>sema</code>主要通过<code>semrelease1</code>来实现<code>signal</code>,通过<code>sync.runtime_Semacquire</code>来调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:linkname sync_runtime_Semrelease sync.runtime_Semrelease</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_Semrelease</span><span class="params">(addr *<span class="type">uint32</span>, handoff <span class="type">bool</span>, skipframes <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	semrelease1(addr, handoff, skipframes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>semrelease1</code>流程</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">semrelease1</span><span class="params">(addr *<span class="type">uint32</span>, handoff <span class="type">bool</span>, skipframes <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	root := semtable.rootFor(addr)</span><br><span class="line">	atomic.Xadd(addr, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Easy case: no waiters?</span></span><br><span class="line">	<span class="comment">// This check must happen after the xadd, to avoid a missed wakeup</span></span><br><span class="line">	<span class="comment">// (see loop in semacquire).</span></span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;root.nwait) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Harder case: search for a waiter and wake it.</span></span><br><span class="line">	lockWithRank(&amp;root.lock, lockRankRoot)</span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;root.nwait) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// The count is already consumed by another goroutine,</span></span><br><span class="line">		<span class="comment">// so no need to wake up another goroutine.</span></span><br><span class="line">		unlock(&amp;root.lock)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	s, t0 := root.dequeue(addr)</span><br><span class="line">	<span class="keyword">if</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">		atomic.Xadd(&amp;root.nwait, <span class="number">-1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	unlock(&amp;root.lock)</span><br><span class="line">	<span class="keyword">if</span> s != <span class="literal">nil</span> &#123; <span class="comment">// May be slow or even yield, so unlock first</span></span><br><span class="line">		acquiretime := s.acquiretime</span><br><span class="line">		<span class="keyword">if</span> acquiretime != <span class="number">0</span> &#123;</span><br><span class="line">			mutexevent(t0-acquiretime, <span class="number">3</span>+skipframes)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> s.ticket != <span class="number">0</span> &#123;</span><br><span class="line">			throw(<span class="string">&quot;corrupted semaphore ticket&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> handoff &amp;&amp; cansemacquire(addr) &#123;</span><br><span class="line">			s.ticket = <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		readyWithTime(s, <span class="number">5</span>+skipframes)</span><br><span class="line">		<span class="keyword">if</span> s.ticket == <span class="number">1</span> &amp;&amp; getg().m.locks == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// Direct G handoff</span></span><br><span class="line">			<span class="comment">// readyWithTime has added the waiter G as runnext in the</span></span><br><span class="line">			<span class="comment">// current P; we now call the scheduler so that we start running</span></span><br><span class="line">			<span class="comment">// the waiter G immediately.</span></span><br><span class="line">			<span class="comment">// Note that waiter inherits our time slice: this is desirable</span></span><br><span class="line">			<span class="comment">// to avoid having a highly contended semaphore hog the P</span></span><br><span class="line">			<span class="comment">// indefinitely. goyield is like Gosched, but it emits a</span></span><br><span class="line">			<span class="comment">// &quot;preempted&quot; trace event instead and, more importantly, puts</span></span><br><span class="line">			<span class="comment">// the current G on the local runq instead of the global one.</span></span><br><span class="line">			<span class="comment">// We only do this in the starving regime (handoff=true), as in</span></span><br><span class="line">			<span class="comment">// the non-starving case it is possible for a different waiter</span></span><br><span class="line">			<span class="comment">// to acquire the semaphore while we are yielding/scheduling,</span></span><br><span class="line">			<span class="comment">// and this would be wasteful. We wait instead to enter starving</span></span><br><span class="line">			<span class="comment">// regime, and then we start to do direct handoffs of ticket and</span></span><br><span class="line">			<span class="comment">// P.</span></span><br><span class="line">			<span class="comment">// See issue 33747 for discussion.</span></span><br><span class="line">			goyield()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分步骤分析</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root := semtable.rootFor(addr)</span><br><span class="line">atomic.Xadd(addr, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>到阻塞队列中拿到根结点，并对当前<code>addr</code>进行<code>加1</code>释放</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> atomic.Load(&amp;root.nwait) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对当前代码区加锁</span></span><br><span class="line">lockWithRank(&amp;root.lock, lockRankRoot)</span><br><span class="line"><span class="keyword">if</span> atomic.Load(&amp;root.nwait) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// 计数已经被其他goroutine消费，所以不需要唤醒其他goroutine</span></span><br><span class="line">    unlock(&amp;root.lock)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从阻塞队列中找到一个addr</span></span><br><span class="line">s, t0 := root.dequeue(addr)</span><br><span class="line"><span class="keyword">if</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="comment">// 等待队列计数-1</span></span><br><span class="line">    atomic.Xadd(&amp;root.nwait, <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当前代码区释放锁</span></span><br><span class="line">unlock(&amp;root.lock)</span><br></pre></td></tr></table></figure><p>这段代码的含义可以理解为，对当前区域加临时锁，主要目的从阻塞队列获取一个addr，然后检测下当前根结点的队列等待数量如果为0，说明都释放过了，直接 <code>return</code> 即可，最后对当前代码执行区域释放锁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">readyWithTime(s, <span class="number">5</span>+skipframes)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readyWithTime</span><span class="params">(s *sudog, traceskip <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">        s.releasetime = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line">    goready(s.g, traceskip)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到这里会将<code>sudog</code>的协程唤醒执行,基本释放操作到这里就结束了，后面的代码主要是针对饥饿状态下<code>g</code>的处理</p><h2 id="go的Semaphore的应用"><a href="#go的Semaphore的应用" class="headerlink" title="go的Semaphore的应用"></a>go的Semaphore的应用</h2><p>go中在互斥锁和读写锁中都用到了<code>Semaphore</code>,在<code>sync.mutex</code>和<code>sync.rwmutex</code>都有调用，当然，在其他结构体中比如waitgroup也有用到，这里只列出使用场景比较高的结构体，通过<code>runtime_SemacquireMutex</code>和<code>runtime_Semrelease</code>实现调用<br>那么为什么会采用<code>Semaphore</code>呢,主要目的还是提高高并发场景下锁的性能，正常情况下可以通过<code>CAS</code>中的自旋也可以实现协程中的通信，但是自旋操作在高并发场景下对cpu资源消耗大，并且由于协程都是<code>自旋</code>等待的，所以当一个协程拿到锁后，其它协程会发生阻塞，影响性能，通过<code>Semaphore</code>中维护休眠队列,对协程进行调度，防止全局阻塞<br>提高了协程间的调度效率,并且在信号同步的<code>P</code>中，go的阻塞是通过<code>gopark</code>实现的，<code>gopark</code>类似与<code>time.sleep</code>,是一种挂起机制，不会大量消耗cpu资源，所以说，go的锁中利用了<code>Semaphore</code>实现调度，也是它在高并发场景中一种优势的体现</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2023/01/21/2023-01-21-Goroutine/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2023/01/21/2023-01-21-Goroutine/" class="post-title-link" itemprop="url">神奇的Goroutine</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-01-21 09:30:00" itemprop="dateCreated datePublished" datetime="2023-01-21T09:30:00+08:00">2023-01-21</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h2><p>在操作系统中，一组程序按独立异步的速度执行，无论从微观还是宏观，程序都是一起执行的，我们把它叫做并行；对比地，并发是指:在同一个时间段内，两个或多个程序执行，有时间上的重叠(宏观上是同时,微观上仍是顺序执行)。</p><p>并行的计算机操作系统中多进程和多线程都不具备真正并行能力,它们通过毫秒甚至微秒级的进程(线程)切换，给人们一种错觉，它们是并行执行的，实际上严格来说，在某一时刻，cpu只能运行一个进程（线程）。</p><p>我们知道go语言的<code>Goroutine</code>是具备多任务处理能力的，往往都能听人说到，go的协程可以轻松实现单机并发几千甚至几万，并且具备并行的能力…针对这些听到的内容，总会有一种朦胧感，也会抱着疑惑，比如说，在生产环境中，<code>Goroutine</code>我开几千几万个协程是否真的没问题？它是否真的具备让任务能够达到并行的能力？<br>产生这些疑惑的原因根本还是我们不知道<code>Goroutine</code>底层是怎么运作的，也没法印证这些言论是否是正确的</p><p>想解决这些疑惑，需要弄清楚<code>Goroutine</code>的底层是怎么运作的，也可以说是<code>Goroutine</code>的调度模型</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="G"><a href="#G" class="headerlink" title="G"></a>G</h3><p><code>Goroutine</code> 在Go语言运行时使用私有结构体<code>runtime.g</code>表示。这个私有结构体非常复杂，总共包含 40 多个用于表示各种状态的成员变量，这里也不会介绍所有的字段，仅会挑选其中的一部分，首先是与栈相关的两个字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line">	stack       stack</span><br><span class="line">	stackguard0 <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>stack</code>记录了<code>low</code>和<code>high</code>,由于是栈区信息记录，可以理解为栈顶和栈底，用于表示栈区内存范围</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stack <span class="keyword">struct</span> &#123;</span><br><span class="line">	lo <span class="type">uintptr</span></span><br><span class="line">	hi <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个<code>Goroutine</code>上都持有两个分别存储 <code>defer</code> 和 <code>panic</code> 对应结构体的链表：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line">    _panic       *_panic <span class="comment">// 最内侧的 panic 结构体</span></span><br><span class="line">    _defer       *_defer <span class="comment">// 最内侧的延迟函数结构体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line">	m              *m</span><br><span class="line">	sched          gobuf</span><br><span class="line">	atomicstatus   <span class="type">uint32</span></span><br><span class="line">	goid           <span class="type">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>m — 当前 <code>Goroutine</code> 占用的线程，可能为空；</li><li>atomicstatus — <code>Goroutine</code>的状态；</li><li>sched — 存储<code>Goroutine</code>的调度相关的数据；</li><li>goid — <code>Goroutine</code> 的<code>ID</code></li></ul><p>上述四个字段中，我们需要展开介绍<code>sched</code>字段的<code>runtime.gobuf</code>结构体中包含哪些内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> gobuf <span class="keyword">struct</span> &#123;</span><br><span class="line">	sp   <span class="type">uintptr</span></span><br><span class="line">	pc   <span class="type">uintptr</span></span><br><span class="line">	g    guintptr</span><br><span class="line">	ret  sys.Uintreg</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>sp — (stack point)栈指针；</li><li>pc — (program counter)程序计数器；</li><li>g — 持有<code>runtime.gobuf</code>的<code>Goroutine</code>；</li><li>ret — 系统调用的返回值；<br>这些内容会在调度器保存或者恢复上下文的时候用到，其中的栈指针和程序计数器会用来存储或者恢复寄存器中的值，改变程序即将执行的代码。<br>结构体<code>runtime.g</code>的<code>atomicstatus</code>字段存储了当前<code>Goroutine</code>的状态。除了几个已经不被使用的以及与<code>GC</code>相关的状态之外，<code>Goroutine</code>可能处于以下 9 种状态：<table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td><code>_Gidle</code></td><td>刚刚被分配并且还没有被初始化</td></tr><tr><td><code>_Grunnable</code></td><td>没有执行代码，没有栈的所有权，存储在运行队列中</td></tr><tr><td><code>_Grunning</code></td><td>可以执行代码，拥有栈的所有权，被赋予了内核线程 M 和处理器 P</td></tr><tr><td><code>_Gsyscall</code></td><td>正在执行系统调用，拥有栈的所有权，没有执行用户代码，被赋予了内核线程 M 但是不在运行队列上</td></tr><tr><td><code>_Gwaiting</code></td><td>由于运行时而被阻塞，没有执行用户代码并且不在运行队列上，但是可能存在于 Channel 的等待队列上</td></tr><tr><td><code>_Gdead</code></td><td>没有被使用，没有执行代码，可能有分配的栈</td></tr><tr><td><code>_Gcopystack</code></td><td>栈正在被拷贝，没有执行代码，不在运行队列上</td></tr><tr><td><code>_Gpreempted</code></td><td>由于抢占而被阻塞，没有执行用户代码并且不在运行队列上，等待唤醒</td></tr><tr><td><code>_Gscan</code></td><td>GC 正在扫描栈空间，没有执行代码，可以与其他状态同时存在</td></tr></tbody></table></li></ul><p>上述状态中比较常见是 <code>_Grunnable</code>、<code>_Grunning</code>、<code>_Gsyscall</code>、<code>_Gwaiting</code> 和 <code>_Gpreempted</code>五个状态,虽然<code>Goroutine</code>在运行时中定义的状态非常多而且复杂，但是我们可以将这些不同的状态聚合成三种：等待中、可运行、运行中，运行期间会在这三种状态来回切换：</p><ul><li>等待中：<code>Goroutine</code> 正在等待某些条件满足，例如：系统调用结束等，包括 <code>_Gwaiting</code>、<code>_Gsyscall</code>和<code>_Gpreempted</code>几个状态；</li><li>可运行：<code>Goroutine</code> 已经准备就绪，可以在线程运行，如果当前程序中有非常多的 <code>Goroutine</code>，每个 <code>Goroutine</code> 就可能会等待更多的时间，即 <code>_Grunnable</code>；</li><li>运行中：<code>Goroutine</code> 正在某个线程上运行，即 <code>_Grunning</code>；<br><img src="/../img/in-post/2023-01-21/img_2.png" alt="img_2.png"></li></ul><h3 id="M"><a href="#M" class="headerlink" title="M"></a>M</h3><p>Go 语言并发模型中的 M 是操作系统线程。调度器最多可以创建 10000 个线程，但是其中大多数的线程都不会执行用户代码（可能陷入系统调用），最多只会有<code>GOMAXPROCS</code>个活跃线程能够正常运行。</p><p>在默认情况下，运行时会将<code>GOMAXPROCS</code>设置成当前机器的核数，我们也可以在程序中使用<code>runtime.GOMAXPROCS</code>来改变最大的活跃线程数。</p><p>Go 语言会使用私有结构体<code>runtime.m</code>表示操作系统线程，这个结构体也包含了几十个字段，这里先来了解几个与<code>Goroutine</code>相关的字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> &#123;</span><br><span class="line">	g0   *g</span><br><span class="line">	curg *g</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>g0</code>是一个运行时中比较特殊的<code>Goroutine</code>，它会深度参与运行时的调度过程，包括<code>Goroutine</code>的创建、大内存分配和<code>CGO</code>函数的执行<br>在后面<code>Goroutine</code>的调度过程中，<code>g0</code>是负责调度工作的核心<code>worker</code></p><h3 id="P"><a href="#P" class="headerlink" title="P"></a>P</h3><p>调度器中的处理器 P 是线程和 <code>Goroutine</code> 的中间层，它能提供线程需要的上下文环境，也会负责调度线程上的等待队列，通过处理器 P 的调度，每一个内核线程都能够执行多个 <code>Goroutine</code>，它能在 <code>Goroutine</code> 进行一些 I&#x2F;O 操作时及时让出计算资源，提高线程的利用率。</p><p>因为调度器在启动时就会创建<code>GOMAXPROCS</code>个处理器，所以 Go 语言程序的处理器数量一定会等于<code>GOMAXPROCS</code>，这些处理器会绑定到不同的内核线程上。</p><p><code>runtime.p</code>是处理器的运行时表示，作为调度器的内部实现，它包含的字段也非常多，其中包括与性能追踪、垃圾回收和计时器相关的字段，这些字段也非常重要，但是在这里就不展示了，我们主要关注处理器中的线程和运行队列：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">	m           muintptr</span><br><span class="line">	runqhead <span class="type">uint32</span></span><br><span class="line">	runqtail <span class="type">uint32</span></span><br><span class="line">	runq     [<span class="number">256</span>]guintptr</span><br><span class="line">	runnext guintptr</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h3><ul><li>G — 表示 <code>Goroutine</code>，它是一个待执行的任务；</li><li>M — 表示操作系统的线程，它由操作系统的调度器调度和管理；</li><li>P — 表示处理器，它可以被看做运行在线程上的本地调度器；</li></ul><h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><p><code>Goroutine</code>的调度流出比较复杂，这里只列举它的调度流程,不影响流程分析的地方直截图调度的关键函数，一些重要的过程分析会贴代码分析</p><p>Go语言运行时会调用<code>runtime.mstart</code>以及<code>runtime.mstart1</code>，并调用 <code>runtime.schedule</code> 进入调度循环：<br><img src="/../img/in-post/2023-01-21/img_3.png" alt="img_3.png"><br>其中在<code>mstart1</code>中会启动<code>g0 Goroutine</code><br><img src="/../img/in-post/2023-01-21/img_4.png" alt="img_4.png"><br><code>mstart1</code>最后调用<code>schedule</code>开始进行调度工作<br><img src="/../img/in-post/2023-01-21/img_5.png" alt="img_5.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">	<span class="keyword">var</span> gp *g</span><br><span class="line">	<span class="keyword">var</span> inheritTime <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> _g_.m.p.ptr().schedtick%<span class="number">61</span> == <span class="number">0</span> &amp;&amp; sched.runqsize &gt; <span class="number">0</span> &#123;</span><br><span class="line">			lock(&amp;sched.lock)</span><br><span class="line">			gp = globrunqget(_g_.m.p.ptr(), <span class="number">1</span>)</span><br><span class="line">			unlock(&amp;sched.lock)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">		gp, inheritTime = runqget(_g_.m.p.ptr())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">		gp, inheritTime = findrunnable()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	execute(gp, inheritTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>runtime.schedule</code> 函数会从下面几个地方查找待执行的 <code>Goroutine</code></p><ul><li>为了保证公平，当全局运行队列中有待执行的 <code>Goroutine</code> 时，通过 <code>schedtick</code> 保证有一定几率会从全局的运行队列中查找对应的 <code>Goroutine</code>；</li><li>从处理器本地的运行队列中查找待执行的 <code>Goroutine</code>；</li><li>如果前两种方法都没有找到 <code>Goroutine</code>，会通过 <code>runtime.findrunnable</code> 进行阻塞地查找 <code>Goroutine</code></li></ul><p>通过<code>schedule</code>获取的<code>Goroutine</code>会调用<code>execute</code>,通过<code>runtime.gogo</code>将 Goroutine 调度到当前线程上。<br><img src="/../img/in-post/2023-01-21/img_6.png" alt="img_6.png"></p><p><code>runtime·gogo</code>通过汇编插入指令在新的协程栈中插入<code>goexit</code>栈帧,目的是为了在后面执行完业务函数后能够回调回来，<br>同时<code>MOVL gobuf_pc(BX)</code>指令还会记录执行函数的程序计数器，最后执行<code>JMP</code>跳转到程序计数器代码位置执行代码</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime·gogo(SB), NOSPLIT, $8-4</span><br><span class="line">	MOVL buf+0(FP), BX     // 获取调度信息</span><br><span class="line">	MOVL gobuf_g(BX), DX</span><br><span class="line">	MOVL 0(DX), CX         // 保证 Goroutine 不为空</span><br><span class="line">	get_tls(CX)</span><br><span class="line">	MOVL DX, g(CX)</span><br><span class="line">	MOVL gobuf_sp(BX), SP  // 将 runtime.goexit 函数的 PC 恢复到 SP 中</span><br><span class="line">	MOVL gobuf_ret(BX), AX</span><br><span class="line">	MOVL gobuf_ctxt(BX), DX</span><br><span class="line">	MOVL $0, gobuf_sp(BX)</span><br><span class="line">	MOVL $0, gobuf_ret(BX)</span><br><span class="line">	MOVL $0, gobuf_ctxt(BX)</span><br><span class="line">	MOVL gobuf_pc(BX), BX  // 获取待执行函数的程序计数器</span><br><span class="line">	JMP  BX </span><br></pre></td></tr></table></figure><p>当<code>Goroutine</code>中运行的函数返回时，程序会跳转到<code>runtime.goexit</code>所在位置执行该函数 ：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime·goexit(SB),NOSPLIT,$0-0</span><br><span class="line">	CALL	runtime·goexit1(SB)</span><br><span class="line"></span><br><span class="line">func goexit1() &#123;</span><br><span class="line">	mcall(goexit0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<code>goexit0</code>，该函数在<code>g0</code>栈上，可在<code>runtime.goexit0</code>找到</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goexit0</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	casgstatus(gp, _Grunning, _Gdead)</span><br><span class="line">	gp.m = <span class="literal">nil</span></span><br><span class="line">	...</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	gp.labels = <span class="literal">nil</span></span><br><span class="line">	gp.timer = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	dropg()</span><br><span class="line">	gfput(_g_.m.p.ptr(), gp)</span><br><span class="line">	schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在最后<code>runtime.goexit0</code>会重新调用<code>runtime.schedule</code>触发新一轮的<code>Goroutine</code>调度，Go语言中的运行时调度循环会从<code>runtime.schedule</code>开始，最终又回到<code>runtime.schedule</code>，我们可以认为调度循环永远都不会终止。</p><h2 id="调度流程"><a href="#调度流程" class="headerlink" title="调度流程"></a>调度流程</h2><p>整个调度链路比较长，我们可以通过一张图来整理下它的工作流程,其中业务代码逻辑为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> do1()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> do2()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../img/in-post/2023-01-21/img_8.png" alt="img_8.png"></p><h2 id="GMP模型"><a href="#GMP模型" class="headerlink" title="GMP模型"></a>GMP模型</h2><p>通过上述流程我们可以归纳出gmp模型</p><p><img src="/../img/in-post/2023-01-21/img_1.png" alt="img_1.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>再回到一开始的问题，</p><ul><li>再生产环境中，<code>goroutine</code>我开几千几万个协程是否真的没问题？<ul><li>针对问题1，我们已经有了很明确的答案，go协程和g1协程的并发执行是在M(线程)中执行的,由于不需要保存线程切换时的cpu上下文信息，是很轻量的，它是通过在用户空间中维护了一套<code>Goroutine</code>的调度管理池子，操作系统中并不知道<code>Goroutine</code>存在，不涉及到cpu上下文切换，所以可以很明确的回答是可以很轻松实现单机创建上千甚至上万个协程的<br>当然也不是任何时候都可以这样创建，当发生系统调用时，需要m线程发生系统调用，所以会产生两次<code>用户态</code>到<code>内核态</code>的切换，这时会涉及到cpu上下文切换，这一点还是需要注意的<br>至于为什么不在协程里去做系统调用，这一点我们在<a href="https://enpsl.github.io/2021/06/02/2021-06-01-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/#%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">进程与线程-线程实现方式</a>小节中阐述过用户空间实现的线程的缺点，同时，<code>goroutine</code>的这种协程实现方式也是属于<a href="https://enpsl.github.io/2021/06/02/2021-06-01-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/#%E6%B7%B7%E5%90%88%E5%AE%9E%E7%8E%B0">进程与线程-线程实现方式-混合实现</a>方式</li></ul></li><li>它是否真的具备让任务能够达到并行的能力？<ul><li>第二个问题，通过<code>gmp</code>模型的归纳可以知道，当操作系统核心数&gt;1时，M是多个，是可以实现真正意义上的并行的</li></ul></li></ul><p>参考文献:</p><ul><li><a href="https://enpsl.github.io/2021/06/02/2021-06-01-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/#%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">进程与线程-线程实现方式</a></li><li>[Go语言设计与实现]</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2023/01/17/2023-01-15-go-map%E5%8E%9F%E7%90%86/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2023/01/17/2023-01-15-go-map%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">GO MAP原理</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-01-17 19:30:00" itemprop="dateCreated datePublished" datetime="2023-01-17T19:30:00+08:00">2023-01-17</time></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="GO-MAP原理"><a href="#GO-MAP原理" class="headerlink" title="GO MAP原理"></a>GO MAP原理</h1><p>hmap结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	count     <span class="type">int</span>    <span class="comment">// map的元素数量</span></span><br><span class="line">	flags     <span class="type">uint8</span>  <span class="comment">//状态标识，用于控制goroutine写入和扩容的状态</span></span><br><span class="line">	B         <span class="type">uint8</span>  <span class="comment">// 用于计算buckets数量，计算公式2^B</span></span><br><span class="line">	noverflow <span class="type">uint16</span> <span class="comment">// 溢出桶数量</span></span><br><span class="line">	hash0     <span class="type">uint32</span> <span class="comment">// hash 种子</span></span><br><span class="line">	buckets    unsafe.Pointer <span class="comment">// 2^B Buckets count ==0时可能为nil(此处是万能指针类型，实际是对应下面的bmap)</span></span><br><span class="line">	oldbuckets unsafe.Pointer <span class="comment">// 扩容后的旧bucket数组</span></span><br><span class="line">	nevacuate  <span class="type">uintptr</span>        <span class="comment">// 迁移计数器，此指针之前的所有桶已被迁移，即nevacuate指向桶数组已迁移桶的最高下标</span></span><br><span class="line">	extra *mapextra <span class="comment">//溢出桶结构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	tophash [bucketCnt]<span class="type">uint8</span> <span class="comment">// bucketCnt == 8每个桶固定8个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><p>通过make函数和hint指定元素数量来初始化map</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, hint)</span><br></pre></td></tr></table></figure><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>目前的现代编程语言基本都支持使用字面量的方式初始化哈希，一般都会使用 key: value 的语法来表示键值对，Go 语言中也不例外：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hash := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">	<span class="string">&quot;1&quot;</span>: <span class="number">2</span>,</span><br><span class="line">	<span class="string">&quot;3&quot;</span>: <span class="number">4</span>,</span><br><span class="line">	<span class="string">&quot;5&quot;</span>: <span class="number">6</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当哈希表中的元素数量少于或者等于 25 个时，编译器会将字面量初始化的结构体转换成以下的代码，将所有的键值对一次加入到哈希表中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">hash[<span class="string">&quot;1&quot;</span>] = <span class="number">2</span></span><br><span class="line">hash[<span class="string">&quot;3&quot;</span>] = <span class="number">4</span></span><br><span class="line">hash[<span class="string">&quot;5&quot;</span>] = <span class="number">6</span></span><br></pre></td></tr></table></figure><p>一旦哈希表中元素的数量超过了 25 个，编译器会创建两个数组分别存储键和值，这些键值对会通过如下所示的 for 循环加入哈希：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">26</span>)</span><br><span class="line">vstatk := []<span class="type">string</span>&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, ... ， <span class="string">&quot;26&quot;</span>&#125;</span><br><span class="line">vstatv := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ... , <span class="number">26</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(vstak); i++ &#123;</span><br><span class="line">    hash[vstatk[i]] = vstatv[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论是<code>字面量</code>或是<code>make</code>方式map底层都是通过<code>makemap</code>函数来创建</p><h3 id="makemap"><a href="#makemap" class="headerlink" title="makemap"></a>makemap</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *maptype, hint <span class="type">int</span>, h *hmap)</span></span> *hmap &#123;</span><br><span class="line">	mem, overflow := math.MulUintptr(<span class="type">uintptr</span>(hint), t.bucket.size)</span><br><span class="line">	<span class="keyword">if</span> overflow || mem &gt; maxAlloc &#123;</span><br><span class="line">		hint = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// initialize Hmap</span></span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">		h = <span class="built_in">new</span>(hmap)</span><br><span class="line">	&#125;</span><br><span class="line">	h.hash0 = fastrand()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find the size parameter B which will hold the requested # of elements.</span></span><br><span class="line">	<span class="comment">// For hint &lt; 0 overLoadFactor returns false since hint &lt; bucketCnt.</span></span><br><span class="line">	B := <span class="type">uint8</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> overLoadFactor(hint, B) &#123;</span><br><span class="line">		B++</span><br><span class="line">	&#125;</span><br><span class="line">	h.B = B</span><br><span class="line"></span><br><span class="line">	<span class="comment">// allocate initial hash table</span></span><br><span class="line">	<span class="comment">// if B == 0, the buckets field is allocated lazily later (in mapassign)</span></span><br><span class="line">	<span class="comment">// If hint is large zeroing this memory could take a while.</span></span><br><span class="line">	<span class="keyword">if</span> h.B != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> nextOverflow *bmap</span><br><span class="line">		h.buckets, nextOverflow = makeBucketArray(t, h.B, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">			h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">			h.extra.nextOverflow = nextOverflow</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>makemap</code> 函数通过指定<code>hint</code>来通过<code>B</code>计算bucket数量<br>计算公式</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hint ≤ 2^B * 6.5</span><br></pre></td></tr></table></figure><p>通过B数量指定hmap会创建2^B个桶和一些溢出桶</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> b &gt;= <span class="number">4</span> &#123;</span><br><span class="line">	<span class="comment">// Add on the estimated number of overflow buckets</span></span><br><span class="line">	<span class="comment">// required to insert the median number of elements</span></span><br><span class="line">	<span class="comment">// used with this value of b.</span></span><br><span class="line">	nbuckets += bucketShift(b - <span class="number">4</span>)</span><br><span class="line">	sz := t.bucket.size * nbuckets</span><br><span class="line">	up := roundupsize(sz)</span><br><span class="line">	<span class="keyword">if</span> up != sz &#123;</span><br><span class="line">		nbuckets = up / t.bucket.size</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当桶的数量小于 2^4 时，由于数据较少、使用溢出桶的可能性较低，会省略创建的过程以减少额外开销；</li><li>当桶的数量多于 2^4 时，会额外创建 2^𝐵−4 个溢出桶；</li></ul><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>为什么需要扩容，当<code>溢出桶</code>承装元素超过8个时，溢出桶的<code>mapextra</code>指向新的溢出桶，直到能够满足承装元素数目,此时，hash查找会退化成链表查找，时间复杂度为O(n)<br>扩容判断条件:</p><ul><li>当前未在扩容状态并且负载因子&gt;&#x3D;6.5</li><li>有太多的<code>溢出桶</code><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">    hashGrow(t, h)</span><br><span class="line">    <span class="keyword">goto</span> again <span class="comment">// Growing the table invalidates everything, so try again</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> map扩容为渐进式扩容，只在map操作当前桶时才对当前桶进行扩容<br>扩容步骤分为<code>hashGrow</code>和<code>growWork</code></li><li><code>hashGrow</code>不做桶元素迁移，只是将当前桶指向oldbuckets，然后创建等量的buckets和溢出桶作为newbuckets指向hmap.buckets<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">h.B += bigger #更新B</span><br><span class="line">h.flags = flags #更新扩容状态</span><br><span class="line">h.oldbuckets = oldbuckets</span><br><span class="line">h.buckets = newbuckets</span><br><span class="line">h.nevacuate = <span class="number">0</span> #扩容计数器</span><br><span class="line">h.noverflow = <span class="number">0</span> #溢出桶数量</span><br></pre></td></tr></table></figure></li><li>growWork会在元素赋值是触发当前桶操作，然后对当前桶进行扩容,将将旧桶数据驱逐到新桶,操作步骤在growWork.evacuate</li></ul><p>evacuate里的扩容方式分为等量扩容和非等量扩容</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">    <span class="comment">// Only calculate y pointers if we&#x27;re growing bigger.</span></span><br><span class="line">    <span class="comment">// Otherwise GC can see bad pointers.</span></span><br><span class="line">    y := &amp;xy[<span class="number">1</span>]</span><br><span class="line">    y.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">    y.k = add(unsafe.Pointer(y.b), dataOffset)</span><br><span class="line">    y.e = add(y.k, bucketCnt*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="等量扩容"><a href="#等量扩容" class="headerlink" title="等量扩容"></a>等量扩容</h3><p>对hash后的key后B位计算桶号，然后将元素等量分配</p><p>例如：hash(a)的二进制为0101110001010110，扩容前B&#x3D;2，桶号为10&#x3D;2，扩容后桶号为110，桶号为110&#x3D;6，将元素平均分配到这两个桶</p><h3 id="非等量扩容"><a href="#非等量扩容" class="headerlink" title="非等量扩容"></a>非等量扩容</h3><p>非等量扩容不扩容桶的数量，由于之前产生过很多溢出桶，但是溢出桶的元素很稀疏，所以只是将桶序号重新整理，清到多余的溢出桶，然后整理到新的buckets，</p><p>##查找和写入</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><ul><li>查找主要分为<code>mapaccess1</code>和<code>mapaccess2</code>两个函数，区别就是<code>mapaccess2</code>在找到目标值时会多返回一个true，在未找到时会返回false</li><li>查找流程hmap里通过tophash找到对应buckets桶号,再到bmap里区寻找tophash高8位对应的key,如果不在当前桶就去溢出桶里找，如果溢出桶找不到说明元素不在map,返回false</li><li>如果查找时正在扩容，会判断oldbucktes是否为nil，不为nil找旧桶，缩减m找到旧桶编号去找旧桶元素位置<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//hash&amp;m找到桶编号作为偏移值找到对应的bmap结构体</span></span><br><span class="line">b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line"><span class="keyword">if</span> c := h.oldbuckets; c != <span class="literal">nil</span> &#123; 	<span class="comment">//存在旧桶，说明正在扩容状态中</span></span><br><span class="line">	<span class="keyword">if</span> !h.sameSizeGrow() &#123; 			<span class="comment">//判断是否翻倍扩容</span></span><br><span class="line">		m &gt;&gt;= <span class="number">1</span> <span class="comment">//翻倍扩容时，新的桶数是旧的2倍，m需要减半才能找到旧桶编号</span></span><br><span class="line">	&#125;</span><br><span class="line">	oldb := (*bmap)(add(c, (hash&amp;m)*<span class="type">uintptr</span>(t.bucketsize))) <span class="comment">//找到对应的旧桶位置</span></span><br><span class="line">	<span class="keyword">if</span> !evacuated(oldb) &#123;</span><br><span class="line">		b = oldb <span class="comment">//如果旧桶没有完成数据迁移，那么更新b指向旧桶bmap</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">top := tophash(hash) <span class="comment">//取hash值高八位，因为bmp.tophash中0-4是标志位，所以hash值小于5的自动加5</span></span><br><span class="line"> bucketloop:</span><br><span class="line"> <span class="comment">//遍历当前bmp和溢出桶</span></span><br><span class="line"> ...</span><br></pre></td></tr></table></figure></li></ul><h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><ul><li>函数首先会检查 <code>map</code> 的标志位 <code>flags</code>。如果 <code>flags</code> 的写标志位此时被置 1 了，说明有其他协程在执行“写”操作，进而导致程序 <code>panic</code>。这也说明了 <code>map</code> 对协程是不安全的。</li><li>扩容是渐进式的，如果 <code>map</code> 处在扩容的过程中，那么当 <code>key</code> 定位到了某个 <code>bucket</code> 后，需要确保这个 <code>bucket</code> 对应的老 <code>bucket</code> 完成了迁移过程。即老 <code>bucket</code> 里的 <code>key</code> 都要迁移到新的 <code>bucket</code> 中来（分裂到 2 个新 <code>bucket</code>），才能在新的 <code>bucket</code> 中进行插入或者更新的操作。<br>上面说的操作是在函数靠前的位置进行的，只有进行完了这个搬迁操作后，我们才能放心地在新 <code>bucket</code> 里定位 <code>key</code> 要安置的地址，再进行之后的操作。</li><li>如果这个 <code>bucket</code> 的 <code>8</code> 个 <code>key</code> 都已经放置满了，那在跳出循环后，发现 <code>inserti</code> 和 <code>insertk</code> 都是空，这时候需要在 <code>bucket</code> 后面挂上 <code>overflow bucket</code>。当然，也有可能是在 <code>overflow bucket</code> 后面再挂上一个 <code>overflow bucket</code>。这就说明，太多 <code>key hash</code> 到了此 <code>bucket</code>。<br>在正式安置 <code>key</code> 之前，还要检查 <code>map</code> 的状态，看它是否需要进行扩容。如果满足扩容的条件，就主动触发一次扩容操作。</li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul><li>首先会检查 <code>h.flags</code> 标志，如果发现写标位是 1，直接 <code>panic</code>，因为这表明有其他协程同时在进行写操作。</li><li>计算 key 的哈希，找到落入的 <code>bucket</code>。检查此 <code>map</code> 如果正在扩容的过程中，直接触发一次搬迁操作。</li><li>删除操作同样是两层循环，核心还是找到 <code>key</code> 的具体位置。寻找过程都是类似的，在 <code>bucket</code> 中挨个 <code>cell</code> 寻找。</li><li>找到对应位置后，对 <code>key</code> 或者 <code>value</code> 进行“清零”操作： 最后，将 <code>count</code> 值减 <code>1</code>，将对应位置的 <code>tophash</code> 值置成 <code>Empty</code>。</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://enpsl.github.io/2023/01/15/2023-01-17-sync-map%E5%8E%9F%E7%90%86/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="enpsl"><meta itemprop="description" content="my blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="彭诗亮的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/2023/01/15/2023-01-17-sync-map%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">GO SYNC MAP原理</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-01-15 19:30:00" itemprop="dateCreated datePublished" datetime="2023-01-15T19:30:00+08:00">2023-01-15</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="SYNC-MAP"><a href="#SYNC-MAP" class="headerlink" title="SYNC MAP"></a>SYNC MAP</h2><p>map不支持并发读写，原因是:</p><ul><li>map底层的<code>hmap</code>的<code>flags</code>做了状态标志，并发读写会panic</li><li>底层控制的本质是防止扩容时，读map操作读到旧桶，写map正在做扩容迁移，将旧桶数据迁移到新桶，从而造成数据读取不正确</li></ul><h3 id="解决map并发问题"><a href="#解决map并发问题" class="headerlink" title="解决map并发问题"></a>解决map并发问题</h3><h4 id="加锁-mutex"><a href="#加锁-mutex" class="headerlink" title="加锁(mutex)"></a>加锁(mutex)</h4><p>加锁会导致同一时刻只能一个协程就操作map,性能比较差</p><h4 id="sync-map"><a href="#sync-map" class="headerlink" title="sync map"></a>sync map</h4><p>map结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu Mutex</span><br><span class="line">	read atomic.Value <span class="comment">// readOnly</span></span><br><span class="line">	dirty <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry</span><br><span class="line">	misses <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> readOnly <span class="keyword">struct</span> &#123;</span><br><span class="line">    m       <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry</span><br><span class="line">    amended <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">    p unsafe.Pointer <span class="comment">// *interface&#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/in-post/2023-01-17/syncmap.png" alt="map struct"></p><h5 id="正常读写"><a href="#正常读写" class="headerlink" title="正常读写"></a>正常读写</h5><p>正常读写操作<code>read map</code>，对map进行读取添加或修改操作</p><h5 id="追加"><a href="#追加" class="headerlink" title="追加"></a>追加</h5><p>比如追加的d&#x3D;&gt;D的kv:</p><p>先去<code>read map</code>查找有没有<code>d</code>,需要对<code>dirty map</code>上<code>mutex</code>锁,防止其他协程操作<code>dirty map</code>，然后在<code>dirty map</code>追加<code>d</code>，并将d.entry指向<code>万能指针</code>,由<code>万能指针</code>指向对应的值<br>同时将<code>readmap</code>的<code>amended</code>赋值为<code>true</code><br><img src="/img/in-post/2023-01-17/mapappend.png" alt="append map"></p><p><img src="/img/in-post/2023-01-17/appendsuccess.png" alt="append map success"></p><h5 id="追加后的读"><a href="#追加后的读" class="headerlink" title="追加后的读"></a>追加后的读</h5><p>先去<code>read map</code>去看有没有该<code>k</code>，没有检查<code>amended</code>，如果为<code>true</code>则去查<code>dirty map</code>,并将<code>misses++</code>,当<code>misses</code>加到和<code>dirty map</code> kv数量相等时，提升<code>dirty map</code>为<code>read map</code></p><p>sync map dirty提升流程:<br><img src="/img/in-post/2023-01-17/dirtyup.png" alt="remove read map"><br><img src="/img/in-post/2023-01-17/dirtyup1.png" alt="dirty map up"></p><p>当再一次追加新元素时会重建<code>dirty map</code><br><img src="/img/in-post/2023-01-17/dirtyup2.png" alt="rebuild dirty map"></p><h5 id="追加后再删除"><a href="#追加后再删除" class="headerlink" title="追加后再删除"></a>追加后再删除</h5><ul><li>正常删除d：<br>正常删除主要操作<code>read map</code>,删除流程参考下图<br> <img src="/img/in-post/2023-01-17/delete.png" alt="delete"></li><li>追加d后再次删除d：<br>先去<code>read map</code>去看有没有该<code>k</code>,没有检查<code>amended</code>，如果为<code>true</code>加锁，去<code>dirty map</code>查找,找到后删除k,并将<code>pointer</code>指向<code>nil</code><br><img src="/img/in-post/2023-01-17/img_7.png" alt="append delete"><br>然后将<code>dirty map</code>提升至<code>read map</code>,<code>amended</code>改为false<br><img src="/img/in-post/2023-01-17/img_6.png" alt="append delete dirty up"><br>最后下次追加时重建<code>dirty map</code><br><img src="/img/in-post/2023-01-17/img_5.png" alt="append delete rebuild dirty"><br>重建<code>dirty map</code>时，由于<code>read map</code>此时<code>d</code>指向<code>nil</code>，所以重建<code>dirty map</code>不会重建<code>d</code><br>之后操作<code>read map</code>,并将<code>d</code>标记为<code>expunged</code>，提醒后面操作<code>read map</code>的d时，不用改为<code>nil</code>，直接从<code>map</code>当前<code>buckets</code>删除</li></ul><blockquote><p>由于sync map只有在追加时才会操作<code>dirty map</code>，所以可理解追加、读写分离</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>map在扩容时存在并发问题</li><li>sync map使用<code>dirty map</code>和<code>read map</code>解决扩容问题</li><li>不存在扩容操作时直接读写<code>read map</code></li><li>存在扩容操作时操作<code>dirty map</code></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article><nav class="pagination"> <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a></nav></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">enpsl</p><div class="site-description" itemprop="description">my blog</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">50</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">9</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2023</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">enpsl</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动</div></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script></body></html>